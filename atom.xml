<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[萧宸宇]]></title>
  <subtitle><![CDATA[如果不能成为拯救世界的神，那就堕落到征服世界的魔吧。]]></subtitle>
  <link href="http://iiiyu.com/atom.xml" rel="self"/>
  <link href="http://iiiyu.com"/>
  <updated>2014-03-18T14:31:14.398Z</updated>
  <id>http://iiiyu.com/</id>
  <author>
    <name><![CDATA[萧宸宇]]></name>
    <email><![CDATA[chenyuxiao@sumi-sumi.com]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[iOS笔记(33) 格志周年系列之夏令时(一)]]></title>
    <link href="http://iiiyu.com/2014/03/18/learning-ios-notes-thirty-three/"/>
    <id>http://iiiyu.com/2014/03/18/learning-ios-notes-thirty-three/</id>
    <published>2014-03-18T13:23:35.000Z</published>
    <updated>2014-03-18T14:31:06.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人学习记录使用,也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="开篇扯淡">开篇扯淡</h2>
<p>两月没写blog，没羞没皮了。以后作息规律一些，blog更新还是频繁一些。格志在2014年2月11日就整整上线一周年了。2013一年做格志，由于自己的技术实在比较菜。导致从上线的第一天起，整个团队跟着一直打补丁。小的坑就不说了，大的坑有两，一个iCloud + Core Data世界性难题。一个是全球时间问题。这篇blog就用来专门记下时间的坑。中间还有个插曲——格志在三月上线了2.0的全新专门为iOS 7设计的版本。时间问题在去年10月份改完以为对了就没有改过。结果3月9号是3月的第二个周日，美国地区进入夏令时。格志中又再次发生了时间问题，导致日记显示不全。之前开会说过放错不可怕，可怕的是放同样的错误。再次放错以后我都呆住了。那可是我写过测试用例的啊。结果当时一run测试就挂掉了。瞬间脑子蒙掉。然后上周通宵了一天，基本每天到3点把世界时间问题给彻底搞定。（希望是彻底）所以趁着我现在还有印象，记录一下。</p>
<a id="more"></a>


<h2 id="国际化">国际化</h2>
<p>我们所以会遇到世界时间的问题主要有几个原因：</p>
<ol>
<li>格志的定位是一个全球市场的产品</li>
<li>我们团队(真实情况是我是一个土鳖)并没有很国际化的背景</li>
<li>格志是一个颗粒度为天的日记应用（Day One等另外几个比较出名的App其实是一个moment为颗粒度）</li>
<li>格志在设计数据存储的时候用了时间作为日记的唯一标识符号</li>
</ol>
<p>所以，最初的版本。我是用了一天的00:00:00分来作为日记的时间。</p>
<p>用了这个库</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>https:<span class="comment">//github.com/erica/NSDate-Extensions</span>

<span class="comment">// pod </span>
pod <span class="string">'NSDate-Extensions'</span>, <span class="string">'~&gt; 0.0.1'</span>
</pre></td></tr></table></figure>

<p>里面的这个方法(先贴出来)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>- (NSDate *) dateAtStartOfDay
{
	NSDateComponents *components = [CURRENT_CALENDAR components:DATE_COMPONENTS fromDate:self];
	components.hour = 0;
	components.minute = 0;
	components.second = 0;
	return [CURRENT_CALENDAR dateFromComponents:components];
}
</pre></td></tr></table></figure>

<p>来获取每天开始的时间。</p>
<p>然后第一个版本我们就这样欢乐开心的上线了。然后iCloud爆大坑。开始填了2个月的iCloud坑和数据修复。在某个时间，一个中国高富帅用户发Email来说，他去泰国旅游的时候，日记都不见了。我才隐约发觉日记的时间有问题！！</p>
<p>日期出了啥问题？</p>
<p>待续</p>
<h2 id="小结">小结</h2>
<p>上周作息实在不规律，现在需要调整一下。本来应该一次性写完发的，但是怕自己懒惰（比如上次的开了头就没有继续，所以我决定每天都写一点就算少一点还是把他发掉）</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[读 Jony Ive: The Genius Behind Apple's Greatest Products 笔记]]></title>
    <link href="http://iiiyu.com/2014/01/08/read-jony-ive/"/>
    <id>http://iiiyu.com/2014/01/08/read-jony-ive/</id>
    <published>2014-01-08T12:51:37.000Z</published>
    <updated>2014-03-18T12:27:29.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人记录使用，也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站，这样您将能在第一时间获取本站信息。</p>
<h2 id="开篇扯淡">开篇扯淡</h2>
<p>发现之前的读书笔记写的好少啊。 都是每年的一月份写一次，然后一整年都没有写。其实并不是没有看书而已，只是看了没写而已。2013除了专业的书籍还是看了一些乱七八糟的书籍。比如开始看王小波，看冯唐。对了<a href="http://weibo.com/ooyor" target="_blank">ooyor</a>大神同学去台湾做出国毕业旅行游的时候还给我带来了一本冯唐实体的小黄书《不二》。还有就是2013年初看完柴静的《看见》和李承鹏《全世界人民都知道》,而且还去不在书店签了4本。亲笔签名哦！其他的看了也就没有印象了。</p>
<p>其实读大学以来，每年的书籍开销都是一笔不小的数目。这就造成了一个严重的问题！每次不管是短途迁移还是长途迁移都搬书搬的欲仙欲死。所以，2013我都是可以买电子书坚决不买实体书。如果没有电子书，我就等电子书出来。如果没有电子书，不是很想看的就不买了。电子书多好迁移啊，一个iPad就带走千万本。不过也有些郁闷，我KK的全套在字节社里面结果现在字节社快挂的样子，多看上买了目前最多的书，但是被小米收掉以后不喜欢它的作风。现在我已经全面的转向了豆瓣读书。图灵社区也买了些然后丢多看里面看。（多看在我这里已经沦为Good Reader的替代品）。</p>
<p>恩，2014希望我想看的书都出电子版吧！让电子化来的更加猛烈一些。</p>
<h2 id="Jony_Ive">Jony Ive</h2>
<p>这次的书总有种是为了敛财而来，作为一个Apple的脑残粉。其实Apple这40年来的各种事件和经历。已经在无数的书籍、文章、电影里面一次一次的重复了很多很多次。每看一次就对Apple的印象丰满一些。到现在Apple在我心中已经是一种具体的形状。这次的Jony Ive传记对我来说，也只是对于Apple印象的一个补充而已。</p>
<h3 id="年少成名">年少成名</h3>
<p>大英帝国的子民，而大英帝国好歹是工业革命的发起地。虽然美帝现在势不可挡。但是200年来的现代化进程底蕴是天朝这种年轻的2b国度无法比拟的。而且Jony Ive人家老爸<br>人家16-7岁的时候就已经各种拿奖了。</p>
<h1 id="PS">PS</h1>
<p>这篇blog的创建时间是1月8号。现在时刻是3月18号。所以我还是把他发掉把。只开了头而已。现在记不住了。</p>
<p>一月到三月瞟过的书有：</p>
<p>「从你的全世界路过」 （看错作者买错书了）</p>
<p>三本Objective C的</p>
<p>GEB瞟了几页。</p>
<p>豆瓣上冲了150.忘记买了些啥了记得有几本挺贵。反正是不在多看上买书了。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/read book notes/" term="read book notes"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[2013年度总结]]></title>
    <link href="http://iiiyu.com/2013/12/31/2013-annual-summary/"/>
    <id>http://iiiyu.com/2013/12/31/2013-annual-summary/</id>
    <published>2013-12-31T13:57:54.000Z</published>
    <updated>2014-02-17T04:21:47.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人记录使用，也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站，这样您将能在第一时间获取本站信息。</p>
<h2 id="生活">生活</h2>
<h3 id="注定的漂泊">注定的漂泊</h3>
<p>在16岁的时候，我就会隐约觉得我会一生注定漂泊。这种感觉以我的文字水平很难用完整表达出来。不过18岁以后的每一年换一个住的地方。直接用事实验证了这个16岁的直觉。本来以为我会在厦大住够2年的，命中注定，天煞孤星。房子要拆迁只有另外找地方了。继续这一年一个地方的节奏。</p>
<a id="more"></a>


<h3 id="极品房东">极品房东</h3>
<p>我想如果不是今天发生的事情我是不会写入的。说真的我一直觉得国足，城管，整个教育，盗版，没节操，所有的敏感词。其实都是表面，去深究根本原因的人们都消失不见了。所以在这种无力的大环境前提下。面对这些事情我常常手足无措，不知道应该用什么样的态度去面对这些事情。我只能告诉自己，这是一个又一个生动又真实的移民广告。来生不做中国人。拉回来说，现在应该称为前房东。来厦门几次找房子都很仓促。都没有留下足够的时间来好好的找房子。第一次是来面试结束以后，一直住酒店。厦门的酒店价格大家懂的。然后也是找了中介就草草决定。电梯海景房，一套隔断成6套。我的是其中之一。旁边有个貌似厦大的女生。经常去夜店，凌晨2-3点回来。这个没啥，关键带一群女生回来。喝了些多不多的酒。然后开始评论男人，给男人打电话扯淡。嘛当，几个月搞的神经衰弱啊。 直接说了没有用。几次想怕起来搞个小电影开最大声音。但是觉得我都出声提醒警告无效的情况下。貌似也没用。然后就是住了半年房东要涨200，当时怕过不了试用，就直接滚蛋没干签一年。然后最后几天天天中介带人过来看，态度很嚣张。最后退房的时候，我在帝都找妹子去了。委托了蒋韩同学过去退押金。一个很能扯淡的河南汉子硬是被两中年妇女说的毫无招架之力。唉。反正被扣了钱。不过也难为他了。找啊找，然后我们投资人说有个朋友的朋友有住房子。当时遇到国庆要去帝都找妹子。找房子带搬家就一周时间。然后想着恩好像有点熟人类似的关系应该没啥问题就定下来了，没有签合同（这个为现在埋下了巨大的隐患）。厦大里面最古老的房子没有之一，每层有共用厕所（没有独立卫生间）。唯一两个电器空调和热水器。我进去的时候起码画了2000添置洗衣机，电磁炉等物品才能住的。第二次交租突然告诉我有个物业管理费，嘛当，当初就写了个收据，没啥合同。一定说是跟我说过的。恶心坏了。没窗帘，我自己挂。空调坏了，我自己修。电灯坏了我自己换。嘛当，想着也没有啥大事情就自己弄好了。不要这么娘炮。天天找房东。结果呢一年到期人家2话不说，呵呵因为物价上涨，所以房租也要涨。我从来没有拖欠过每次交租。而且他是教职工租房房子，很是便宜，然后一年到期的头7天突然跟我说下一年的房租要涨200.之前跟我没有任何联系。因为没有合同人家就是要涨就涨。但是他的房子几乎没啥成本，是厦大租给教职工做福利的。然后我想找房子，但是那个月突然有工作要忙。最后没能找到满意的。我只能说是要继续住。然后叫他过来当面说了1小时。晓之以情，动之以理。最后喉咙都感觉出血的情况下。在他带来各种不平等条约的合同上只涨100.签了1年。这不，住了没2月就要拆。收到消息到搬走也之有10天左右的时间。就在2013.12.30日我打电话跟房东说我2013.12.31日要搬走。然后晚上过来交接一下房租的事情。（这个时候我有一个月的押金，和交了3个月只住了两个月的房租）他满口答应没有问题。 2013.12.31日晚我回到老房子跟他打电话问他什么时候过来交接。第一，他矢口否认我交过一个月的押金。并且否认之后签的合同上同样写着交了押金的条目。第二，以其他理由推脱不能来交接。真的，当时我整就无语在空中。然后我叫他当面过来对质。我还有他写的收据。然后我拍照发过去给他。他又说2014年1月1日。转帐给我。基于很多很多小的细节。我在离开房子的时候拍了些照片。以防止要出什么妖蛾子。</p>
<p>在这个劣币驱逐良币。权利利益群体更加压迫普通群体的地方。我唯一找到的解决方案就是移民。</p>
<p>这段写的异常愤怒。下面写点轻松的。</p>
<h3 id="完全正版化">完全正版化</h3>
<p>其实，全面转到Linux的时候，已经很少用盗版了，除了虚拟机里面的Windows是盗版。然后全面用Mac以后，几乎没有啥盗版。只是一开始的时候也没入啥App。但是2013年，我买正版没有三千也有两千了把。第一次买超过100rmb App的时候还是很纠结。但是买过了以后就没啥感觉了。然后买了几次以后。感觉300左右的App还是能在接受的范围内。所以，看到心仪的App一般就入了。6rmb这种几乎都是顺点的。所以，2013年对我来说是完全正版化的一年。对了，我没有虚拟机，所以我也没有用Windwos。所以，现在我可以自豪的说，我现在Mac上面全部App是正版。当然今年的正版化，我还尝试过音乐。不过iTunes里面中国区买不到。天朝的几家付费的我都冲过一两个月尝试了一下。但是都没有心仪的。不过后来Xiami For Mac。确实做的好，本来我对虾米的印象是很糟糕的。但是Xiami For Mac居然能改变我对虾米的看法。真的做的好。然后今年去电影院的次数也满多，iMax也看了不少场。对了，如果你一定要揪出来说，我只能说我承认我看的爱情动作片还是盗版。不过我也会尝试着弄成正版。</p>
<h2 id="工作">工作</h2>
<h3 id="Sumi">Sumi</h3>
<p>来厦门也快两年，其实长开智以后，只要某一刻突然停下来回头瞅瞅，都会发出时间过的好快的感觉。文人骚客说就是“人生天地之间，若白驹过隙，忽然而已”。 </p>
<p>2013过年一来，大概迷茫过3-4个月的样子。迷茫的原因是我周围都是一堆“一条龙”能搞定的人儿。我所谓的”一条龙”就是现在流行的”full stack developer”。</p>
<p>我boss Kevin Cao。 泪流满面，工作室来过好多波人参观。如果是熟悉的人都会说一句“Kevin是我见过从设计到技术都能达到国际水准的一个人”。如果不熟悉的人听到啥“Grid Diary是你设计的？还是你写的？我这么多年来第一次见过又能设计又能写代码的”。可想我一个hello world级别的小菜程序员压力有多大了么。</p>
<p>90后”一条龙”王放放同学，泪流满面，从后端，前端，设计，iOS，Android, MacOSX App.一条龙了。居然tm的还是文科生跨界友情客串。你叫一个读了破壁坑爹4年的软件工程专业的88年大龄hello world级别程序员情何以堪。</p>
<p>90后“一条龙”廖逸聪小朋友， 泪流满面，又是一个从后端，前端，设计，iOS，Android, MacOSX App.一条龙了。而且华丽丽的看清楚了破壁坑爹的软件学院本质。大二休学闯荡江湖。然后见到我的时候大部分时间拉着我聊南怀瑾。然后时不时的送自己烤的小饼干给我吃。嘛当，不仅可以写的一手好代码，还能做的好一手小饼干。恩我去面壁思过去了。</p>
<p>当看到我司RoR高富帅写起iOS也绝不含糊。旁边的100平土豪灰用起Photoshop也是一溜一溜的时候。我就纠结了，嘛当，写个程序写hello world级别。连个PS都不会用。太丢人了。</p>
<p>在这样一群优秀的人儿当中，那时候我想，嘛当我也可以画图的嘛。好歹小学时候画小金鱼拿过小红花的。这样我跟小聪妹子骗来了一本「像艺术家一样思考」。然后郑重其事的去厦大小超市里面买了铅笔和纸准备学习画画。初级目标是理解美。中级目标是也能自己熟练的捣鼓点UI。终极目标是向Boss那样一条龙下来。而且是高水准的一条龙。</p>
<p>可是事实就是任何东西没有经过一万小时的锤炼是无法成为专家的。只有幼儿园水平却想着要弄出专家级别的东西。而弄不出来的时候我心情就会变的很压抑、烦躁。白天工作的时候思绪就会不集中，素描也没有能坚持下去。就画了大概2周左右的时间。</p>
<p>在学习素描的过程中，我不仅仅想学画画这样一个技能。我就是想一口吃成一个胖子。我还同时看着后端而且后端我还在Golang Ruby NodeJS中徘徊。今天这个配置环境Go写个hello world折腾一下。明天弄个Vim环境试试Ruby的写法。 大后天弄个Textmate的bundle写一下NodeJS。每个东西都浅尝辄止的学习。却想做出一个庞大的系统出来。</p>
<p>最后，我居然还在开始看着OSX编程。也不知道脑子咋想的。觉得自己在iOS端输出不够，就逃避的想说恩。我去先学一学OSX。到时候项目快速推进到OSX上。来弥补我在iOS端的薄弱输出。事实是OSX上面的坑更多。各种API一点都没有iOS上的好用。而且桌面端的思路跟移动端的思路完全是两个概念。双修其实是有难度有门槛的事情。</p>
<p>各种折腾2-3个月，我还是那个我。无法画出漂亮的UI，写不出比hello world更加复杂的后端，写不了OSX的程序，本来应该写好的iOS代码的质量也没有得到提高。时间成本在折腾中流失。</p>
<p>在我的各种愤怒中。萌小萌同学和Boss让我意识到。如果单项技能没有一万小时的修炼是无法达到我想要的高度的。而我不能三心二意的做事情。这样反而影响到了工作质量。</p>
<p>我用了一段时间艰难的让自己承认自己只是一个天资普通的人。我只有踏踏实实的一个小时一个小时单线程的努力。累计到了一万小时才是最终的王道。</p>
<h3 id="代码_&amp;&amp;_技术">代码 &amp;&amp; 技术</h3>
<p>今年早些时候，Allen Xu（又是一个全端工程师，你们够了！！！天天刺激我）的引荐。我有幸被唐巧加入他的群里。诚惶诚恐，巧哥的群有点像传说中大佬caoz的群的方式。进群的唯一标准是巧哥觉得你ok。虽然不可能像caoz的群里那种随便一个都是大佬。但是目测巧哥的群里大部分伙伴们的实力（其实就是除了我）应该能代表目前中国iOS&amp;&amp;Cocoa的顶级实力。肯定有一些潜伏的大神还没有露面出现。不过现在群列表里都是开发这百万用户，千万用户，亿级用户产品的大大们。平时有个啥问题丢进群里。几乎是立马可以得到解决方案。群里也经常分享整个业界的最新资讯。2013年能进巧哥的群，是一个非常大的惊喜。从里面收获颇多。</p>
<p>2013年的代码质量从被review的情况上来看，可读性依然一塌糊涂。最更本的原因是我只会一个一个的单词（还经常打错）。而无法连成一句完整的话。其实我有很努力的去改进这个问题。都变成每次写代码，起函数名字是整个写代码过程中花费时间最长的部分。但是效果不明显。</p>
<p>今年技术关注的重点依然集中于iCloud。由于过年前的匆忙修改，并且没有覆盖测试，导致iCloud出错。最终导致Grid Diary没能一炮而红。其实主要责任是我的。为了解决第一次发布版本的错误。我们用了整整2个月，不停的推出版本来修复错误。而因为没有写测试用例覆盖测试。往往我们修复了一个问题，结果就引出了其他问题。关于Gird Diary这一年遇到的坑。我觉得可以重新写一篇blog了。</p>
<p>然后为了解决iCloud + Core Data同步的问题。又去尝试设计过iCloud + Document的方法去同步。然后在建立索引。但是由于demo完成度太低。和老用户升级带来的麻烦。此方案最终抛弃。所以现在依然是iCloud + Core Data的同步方式。</p>
<p>今年另外一个重点关注的东西是ReactiveCocoa。虽然我还是hello world级别。不过在github上watch一个这样活跃的项目收获还是巨大的。可以看到什么是开发的热情和执行的高效。看到他们为了一个名字而讨论怎么样才合适。所以ReactiveCocoa对我来说不仅仅带来了一种新的设计思想和代码编写方式。它还为我展示了一个国际化开源项目的活力。</p>
<h2 id="感情">感情</h2>
<h3 id="父母">父母</h3>
<p>其实在16-7岁的时候跟父母的关系其实蛮紧张的。因为年少吧，现在能多为其他人考虑问题以后。那就多体谅父母。只是亲尚在，不远游。自己在外面漂泊着如果父母有个什么事情也帮助不了的时候觉得自己挺自私的。不过爸妈还是很尊重我的意思，我也很感谢他们并没有强迫我去做我不喜欢做的事情。</p>
<h3 id="萌小萌">萌小萌</h3>
<p>和萌小萌有时候也会斗斗小脾气，拌拌小嘴。经过无数次的商量。异地恋的弊端应该都全部解决了。然后今年准备去给未来丈母娘看看，希望能是一个好的结果。</p>
<h3 id="兄弟">兄弟</h3>
<p>今年好兄弟应该说还是比较圆满了。老闷和飞哥多年后的今天终于找到了各自的真爱，可喜可贺。wwl荣升当爹不说，多年的盘终于出去取得突破性进展。回去抱大腿的日子指日可待。六的结婚日程应该已经提上日程，大豪宅已经住上，差不多也是当爹的节奏了。鑫哥？鑫哥号称只剩下钱了。随时可以回去抱大腿了。</p>
<h2 id="计划">计划</h2>
<p>说好听点我并不是一个循规蹈矩的人。说实际情况就是自制力极其差，拖延症状严重。每次制定的新年计划都是像是个安慰剂。安慰一下拖沓了一年的自己。给自己心里暗示说恩下一年会做的好一点。其实25年来每次都这样的说法，而每次只有等到12月31日的时候来悔恨自己。</p>
<p>所以此时此刻我很矛盾。 不知道是否应该把2014年的计划下来。</p>
<p>2014年，我希望我能好好的学习一下洋文。</p>
<p>2014年，我希望萌小萌能快乐过每一天。</p>
<p>2014年，我希望长辈身体健康。</p>
<p>2014年，我希望我能和Sumi继续走在改变世界的路上。</p>
<h2 id="最后">最后</h2>
<p>最后，这就是我2013年的一些碎碎念。从2013一直写到了2014. 就给我的伙伴们当个乐呵乐呵的东西看看呗。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/just-talk/" term="just-talk"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(32) UbiquityStoreManager 学习笔记1]]></title>
    <link href="http://iiiyu.com/2013/12/25/learning-ios-notes-thirty-two/"/>
    <id>http://iiiyu.com/2013/12/25/learning-ios-notes-thirty-two/</id>
    <published>2013-12-25T15:22:33.000Z</published>
    <updated>2014-02-17T04:20:43.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人学习记录使用,也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="开篇扯淡">开篇扯淡</h2>
<p>现在都是进入互联网时代，一个互联网的App数据肯定是存在互联网上的。到处都是云，到处都是服务器。如果数据是存储在云端or服务器端。每次数据的读取和修改直接作用于服务器。这样不管你用多少设备，多少平台。数据都能保证是唯一的。但是还有些App需要一些更好的性能和效果的时候往往等不起网络的数据传来传去。这时候需要一些折中的办法来解决这些问题。iCloud就是Apple给出的解决方案。就普通用户来看，iCloud应该是在Apple系中的最优选择。但是从开发者的角度来看iCloud就是个无穷无尽的深渊。</p>
<p>全球有很多开发者致力开发第三方库以便让iCloud能被使用。 </p>
<p>UbiquityStoreManager就是其中之一。</p>
<a id="more"></a>

<h2 id="UbiquityStoreManager">UbiquityStoreManager</h2>
<p><a href="https://github.com/lhunath/UbiquityStoreManager" target="_blank">UbiquityStoreManager</a>是一个core data持久化层的控制器。</p>
<p>UbiquityStoreManager在iOS 6时代是使用GPLv3协议。所以好像使用者不是很多。iOS 7 Core Data 关于iCloud引入了新的机制和新API以后UbiquityStoreManager迅速跟进。并且更换了协议使用了Apache v2。所以如果你有iOS 7的App想使用iCloud + Core Data这种hard模式。UbiquityStoreManager是第一个应该推荐的库。</p>
<p>UbiquityStoreManager不同于其他解决方案。大部分都是在iCloud上面继续构建一层来保证数据同步的完整一致性。UbiquityStoreManager仅仅是解决了就只单纯使用iCloud就会遇到的问题。比如数据出错了怎么办。从本地数据迁移到iCloud数据。从修改日记来重建数据库等。</p>
<h2 id="UbiquityStoreManager解决的问题">UbiquityStoreManager解决的问题</h2>
<ol>
<li>提供在iCloud和本地Store直接切换</li>
<li>在用户没有iCloud store 的时候自动的把local data 合并到iCloud（使用本地数据重建iCloud）</li>
<li>所有与iCloud有联系事件处理：1. 切换iCloud帐号 2. 删除iCloud数据 3. 删除本地数据 4. 导入其他设备变换的ubiquitous 5. 恢复有错误的transaction logs。</li>
<li>其他的一些实用功能：1.从transaction logs重建cloud store 2. 从cloud store 重建transatction logs 3. 删除cloud store 4. Ability to nuke the entire cloud container 5. 把一个store里面全部的entities合并到另外一个store</li>
</ol>
<p>在iCloud+CoreData的官方解决方案中，对于开发者来说完全的黑箱子操作。难于开发和调试bug。而且经验不足完全会被很多坑拉进泥潭里面。使得开发更本无法进行下去。所以仔细研究UbiquityStoreManager。是我建议踏入iCloud + Core Data开发的必修课。</p>
<h2 id="总结">总结</h2>
<p>只是我学习中的一点笔记和注释翻译而已。留给自己看看。如果有不对的地方，欢迎指出。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[简单测评Bong(深度吐槽,胆小、承受能力差和心脏病人需要陪同观看。谢谢合作)]]></title>
    <link href="http://iiiyu.com/2013/12/21/evaluation-bong/"/>
    <id>http://iiiyu.com/2013/12/21/evaluation-bong/</id>
    <published>2013-12-21T11:47:02.000Z</published>
    <updated>2014-02-17T04:21:39.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人记录使用，也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站，这样您将能在第一时间获取本站信息。</p>
<h2 id="开篇扯淡">开篇扯淡</h2>
<p>今天为了测试Bong支持游泳的说法，我差点挂在厦大的游泳馆里面。这天太冷了，而我自己又对自己的身体素质预估不住，跑去露天的游泳池。偌大一个标准池就我一个人，随意做了几下准备运动抵不住冷风吹，深吸一口气眼睛一闭跳进去。XXX，我能说脏话么。蛋都要冻掉的节奏啊，心中顿时把年少时候在电视上看到冬天跳入结冰河水游泳的新闻编者草泥马过了千万遍。顿时想转身起来，但是一想到下去还钥匙时候丢人死了。就奋力的向前游。接下来，我体验到了在水里皮肤会有痛的经历。记忆力从来没有过的。由于水温比身体温度低很多全身的皮肤感到刺痛，寒冷刺皮肤啊。扛着想今天至少要游1km吧。游了200m的时候开始全身麻木or适应了刺痛感，好过一点。咬牙游到600m的时候还觉得可以到1000m的结果650m米的时候开始感到不适。以自己科学常识隐约觉得是体温下降太多导致。所以就在700m的时候翻身上岸。经过长途跋涉回到宿舍里面赶紧冲了一个热水澡。然后躲到被窝里面小睡了1个小时才感觉命回来了。</p>
<p>我并没有才入手就吐槽，而是使用了5天。打了两次羽毛球，游了一次泳。才开始吐槽的哦。</p>
<a id="more"></a>

<h2 id="缘由">缘由</h2>
<p>2013这一年没入啥大件，但是小东西弄了一堆。也蛮浪费钱的唉。智能穿戴设备去年年末火的时候就一直寻思着入一个看看，不过一直狠不下心来。而今年入夏以后主要运动几经波折固定在了游泳上，深度观察以后觉得靠谱的两家<a href="http://www.fitbit.com" target="_blank">fitbit</a>和<a href="https://jawbone.com" target="_blank">jawbone</a>的手环都不能支持游泳。所以一直在等待一个支持游泳的手环出来。</p>
<p>然后在11月的某天，看weibo的时候看到kenwone上在卖一个国产手环，听说过的另外一个国产手环(咕咚)节操早就掉没了。这个好像还不错的样子。点过去一看。靠可以检测游泳，最重要的是一个VIP特权。号称这一批用户可以永久享受每一代设备更新。我靠爱占小便宜技能开启。然后怂恿着大厨先弄了一个。然后自己也就付款了一个。小算盘打着，这么高调。至少能撑过2代吧。那就至少有两个。有两个的话，就差不多保本有赚了。啊哈哈。</p>
<p>所以我入Bong有三个理由</p>
<ol>
<li>我想试试智能手环之类</li>
<li>支持游泳</li>
<li>性价比</li>
</ol>
<h2 id="Bong的整个运营">Bong的整个运营</h2>
<p>买了bong，然后关注了多关注了bong。weibo时不时瞅两眼。</p>
<p>说微信公共帐号。这次发现公共帐号还是蛮有必要的。</p>
<ol>
<li>保存了每天更新</li>
<li>虽然在我看来每天的内容做的一般。但是起码有人味。不那么机械冷冰冰。</li>
</ol>
<p>通过weixin好感度提高蛮多的。</p>
<p>然后说第一次跳票，其实都很能理解。所以第一次听说也才10几个的退款率。整个前期运营功不可没。</p>
<p>不过后来的整个运营就只能用惨不忍睹来形容了。</p>
<p>跳票以后的进度不清楚。然后承诺的15号发货。15号虽然发了大部分(猜测)。但是被发货的用户们(我)对整个顺丰订单毫无信息。已经习惯了taobao系流程的我来说很不习惯。没有安全感。就算整个订单系统来不及做。丢一个excel表格起码也能丢上去把。起码能有个地方能查到啊。很遗憾什么都没有。</p>
<p>我知道bong现在才8个人。按照官方说法是有1400个要发。算发一个需要5分钟。简单算术8个人需要做15个小时才能发完。按照官方说法感觉肯定发一个的时间超过5分钟。所以觉得他们在一天之类肯定发不完。</p>
<p>我想说的是，说是跳票到15号。不是就算到15号才拿到货开始发把。既然跳票了，应该把这个发货时间也算进去。比如说15号发，应该是13号左右开始包装填写。然后15号叫来顺丰就妥妥的一次性发出去。坐等用户反馈。都使用跳票技能，就多跳两天准备充分肯定更好。</p>
<h2 id="开启吐槽模式">开启吐槽模式</h2>
<h3 id="到手">到手</h3>
<p>恩，怀着激动的心情。我在17号拿到了bong。</p>
<p>下面是多图杀流量时间</p>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1ebrmul7yq1j20hs0nutcs.jpg" alt=""></p>
<p>盒子怎么说呢。之前在weixin上运营的时候玩了一手，说是第一批盒子质量不好，换了一批，当时似曾相识的感觉。不过我以为是为了追求品质。不过打开顺丰袋子的一个感觉是。艹，这个不会是第一批盒子吧。浓浓的山寨感觉。</p>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1ebrn32vsfkj20hs0nujuy.jpg" alt=""></p>
<p>恩knewone还多送了点东西，不过自己这张贴纸感觉不喜欢。本来想贴到电脑上的。但是上手感觉质量跟github的贴纸有一定差距加上这个小怪物不是我的菜。就没有贴了。然后是钥匙收纳盒。没想到用到哪里。自己住的地方被告知20天内搬离。又是一把辛酸泪。</p>
<p><img src="http://ww1.sinaimg.cn/large/a6d3226bgw1ebrn7laek8j20hs0nuwhv.jpg" alt=""></p>
<p>恩 bong的包装盒就不多说了，几张卡片。一张有团队成员签名。一张是类似说明书。两张强调VIP的尊贵身份。</p>
<h3 id="吐槽手环本身">吐槽手环本身</h3>
<p>首先是外形</p>
<p>官网上是这样<br><img src="http://ww1.sinaimg.cn/large/a6d3226bgw1ebrnhjrlbuj20z10k9769.jpg" alt=""></p>
<p>实际上是这样</p>
<p><img src="http://ww1.sinaimg.cn/large/a6d3226bgw1ebrnospqpyj20jm0qadj0.jpg" alt=""></p>
<p>首先，两头是细的这种设计。啥时候变成了水桶腰设计。</p>
<p>第二，我买的是黑色的把。为啥看着跟银色一个样子。这是cosplay iPhone5s的太空灰么。</p>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1ebrnxonhknj20hs0nuwi1.jpg" alt=""><br>我不知道这张能不能清楚的看到。灯的地方被胶糊住了。这个感觉太恶心了。是拿到手以后最恶心的地方。也可能是期望抱太高了，导致的心里落差。前期的运营以为bong是注重细节的团队。但是嘴上说说和实际做到是有差距的。这里我看见了bong的差距。</p>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1ebro51k5cqj20hs0nuwi1.jpg" alt=""><br>转过来，我第一次看见bong是怎么充电的。一直说的都是点触式充电。才知道 原来后面有两个孔啊。保密性做的很好啊。然后图上在两个充电孔下面也能清楚的看到，明显的由于某次没有对准而导致使劲压下去造成的刮痕。再次觉得嘴上说说和实际做到是有差距的。</p>
<p>手环的两侧接缝触有一层摸上去明显不平整。</p>
<p>正面上有一条淡淡的线。觉得应该是材质本身的线。但是出现在正面稍微仔细就能看见。</p>
<p>嗯，基本上硬件部分就这么多了。</p>
<h3 id="吐槽说明书以及整个引导流程">吐槽说明书以及整个引导流程</h3>
<p>说明书叫那个简单啊，一个卡片几句话搞定。还以为是已经设计到返璞归真的地步了手上即用。但是还是看了一遍。(此时此刻卡片没在，而且是5天前发生的事情了，凭借印象说了)</p>
<p>首先出现的是一句最好使用PC链接。环顾四周，方圆10米内没有发现一台PC。那OSX可以不可以，我也不知道。唉，先插上试试呗。</p>
<p>接下来一句话引起了我的注意。说的是插上大概五分钟就可以拿下来使用了。！！！！！</p>
<p>插上大概五分钟？是多于五分钟 还是小于5分钟？如果不插会发生什么呢？插到5分钟的时候会发生什么呢？ 插久了又会发生什么呢？有没有提示啊。靠。那5分钟我需要怎么计算呢。打开手机的秒表功能么。我很难想象一个让我都手足无措的东西。去介绍给媳妇儿用。或者带给爸妈用。</p>
<p>然后我以为App里面应该会有详细说明的！！！！结果没有！！！连接前和连接后都没有。</p>
<h3 id="吐槽App">吐槽App</h3>
<p>自己做iOS的，难免吐狠了点。bong团队看到了不要介意。又或者你们都拿到投资了要不把App外包给我们国际大厂Sumi来做把。</p>
<ol>
<li>第一次发短信的时候注册不上</li>
<li>远看想扁平化设计 近看背景还有材质</li>
<li>这是Moves的白天版本么</li>
<li>每次打开都要Loading。为啥不先打开再载入数据啊</li>
<li>我在第三天的时候app叫重新登录一次。然后第一天的数据没了。</li>
<li>为啥tableview上的排列时间是00:00在最上面。不应该是当前时间在第一个位置么</li>
<li>除了跑步以外，其他的都归类到运动里面去了么。分类太少了</li>
<li>各种统计图表有待改进</li>
<li>电量检测不准确 第一次使用了一小时看掉了10%多的电量。现在用了5天了。掉了7%的电量。而且最近两天都没有电量变化</li>
</ol>
<h2 id="吐槽使用中的情况">吐槽使用中的情况</h2>
<ol>
<li>早上唤醒的时候只有一次。现在是冬天啊，不能多摇几次么</li>
<li>一开始我带左手，后来打羽毛球的时候想想带在了右手。导致刷牙的时候会震动一下进入类似散步模式。</li>
<li>不能识别多种运动</li>
<li>记得说过可以记步的。但是实际没有。觉得有记步的数据会更好。</li>
</ol>
<h2 id="总结">总结</h2>
<p>好累啊 写一晚上了就这么多把</p>
<h3 id="优点">优点</h3>
<ul>
<li>自动识别睡眠</li>
<li>防水 可游泳， 虽然我也游了200m的自由泳但是没有识别</li>
<li>如果发第二代的话性价比高</li>
</ul>
<h3 id="缺点">缺点</h3>
<p>今天blog内容。</p>
<h2 id="One_more_thing">One more thing</h2>
<p>如果给我来运营，我会把这次bong的人数控制在200人左右。尽量做好第一批口碑。然后把第一批变成死忠粉。根据反馈来不断迭代很进化。然后在把已经行之有效的小米打法拿来打一次。</p>
<p>其实跳票的时候 只退了10几个人我觉得已经几乎要做到了。但是如果说能收到以后在退款。我想这个数量应该是惊人的。而且把之前前期做的所有努力付之一炬。</p>
<p>然后App的话我会提供很多种运动种类给用户选择。然后数据上传做数据分析和机器学习。这样以后就能识别更多的运动类型了。</p>
<p>恩 福利就说这么多。多的留着啊哈哈。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/just-talk/" term="just-talk"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(31) CocoaPods 手把手五分钟教你制作自己的podspec文件]]></title>
    <link href="http://iiiyu.com/2013/12/19/learning-ios-notes-thirty-one/"/>
    <id>http://iiiyu.com/2013/12/19/learning-ios-notes-thirty-one/</id>
    <published>2013-12-19T12:11:16.000Z</published>
    <updated>2014-02-17T04:20:45.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人记录使用，也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站，这样您将能在第一时间获取本站信息。</p>
<h2 id="开篇扯淡">开篇扯淡</h2>
<p>圣诞渐进，各种App都在黑五一波冰点。可以遇见的是12月25号前也会有一大波来临。但是！！！今年买软件貌似已经花了很多钱了。而且，也没有几个想入的了。所以就忍忍吧。</p>
<p>然后，做个宣传啊。我们国际化大厂Sumi的App Grid Diary在紧锣密鼓的开发2.0. 完全iOS7设计。各种给力。到时候希望能给大家带来一个好的App吧。</p>
<a id="more"></a>

<h2 id="CocoaPods">CocoaPods</h2>
<p>CocoaPods 不必在介绍了吧。如果你是一个iOS or OSX的开发者。然后你跟我说你还没有用过CocoaPods。我肯定会觉得你不够潮(low爆了)。</p>
<p>其实我之前又写过两篇介绍CocoaPods的</p>
<p>只不过时间有点久远了。而且CocoaPods更新很快。有了很多新的特性和功能。 截至我写这篇blog。我的pod version是0.28.0。</p>
<p>不过还是具有参考价值</p>
<p><a href="http://iiiyu.com/2012/10/26/learning-ios-notes-fourteen/">使用CocoaPods</a></p>
<p><a href="http://iiiyu.com/2013/03/01/learning-ios-notes-sixteen/">配置自己的CocoaPods库</a></p>
<h2 id="五分钟手把手">五分钟手把手</h2>
<p>在上面的<a href="http://iiiyu.com/2013/03/01/learning-ios-notes-sixteen/">配置自己的CocoaPods库</a>里面。当时只是初步的使用pods。在学习的过程中。很多理解都很浅显。现在终于用了一年多CocoaPods。有点小心得就来记录一下。</p>
<p>github现在每天必看网站。一个是工作需要，另外一个是上面神奇的东西太多太多了。学无止境啊。</p>
<p>使用CocoaPods管理第三方库有时候就会遇到这样的尴尬。好不容易找到了一个心仪的库,却发现CocoaPods里面搜索不到。</p>
<p>怎么办 怎么办</p>
<p>来乖。手把手交你来写hello world。</p>
<p>栗子：  <a href="https://github.com/premosystems/XCAsyncTestCase" target="_blank">XCAsyncTestCase</a></p>
<p>首先，去把它fork到自己的项目里面去。(什么不会fork？去面壁去)</p>
<p>然后，把fork到自己帐号下的项目clone出来 cd进去</p>
<p>输入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>pod spec <span class="built_in">create</span> <span class="keyword">https</span>://github.com/iiiyu/XCAsyncTestCase
</pre></td></tr></table></figure>

<p>接着你会看到</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613gw1ebpcdvd99xj20lc09f0ui.jpg" alt=""></p>
<p>这个很正常，很多项目都没有tag。反正在自己的下面。可以瞎搞。给项目加入一个tag。以便pod能自动识别。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>git <span class="built_in">tag</span> <span class="attribute">-a</span> <span class="number">0.0</span><span class="number">.1</span> <span class="attribute">-m</span> <span class="string">"Tag release 0.0.1”

git push —tags

rm -rf XCAsyncTestCase.podspec

pod spec create https://github.com/iiiyu/XCAsyncTestCase</span>
</pre></td></tr></table></figure>

<p>接着你会看到</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613gw1ebpcfwf0wsj20i6023mxh.jpg" alt=""></p>
<p>OK。 然后用你自己喜欢的编辑器打开。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>mate XCAsyncTestCase<span class="preprocessor">.podspec</span>
</pre></td></tr></table></figure>

<p>接着其实不用怎么改里面的内容 </p>
<p>我把注释删掉 作者改成原来的作者。然后需要的源码位置改成正确的</p>
<p>大概就是这样</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613gw1ebpcik0lh1j20ry0db0v9.jpg" alt=""></p>
<p>当然 最重要的是s.source_files这个。你要把你要包含的文件路径找对了。 然后用通配符匹配好了。就OK了。</p>
<p>当然其他项，你看看注释啥的 选择性的填一些。在这里是一个五分钟的hello world。不深入讨论</p>
<p>接着 把修改好的文件push到github上去</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>git add XCAsyncTestCase.podspec

git commit -am <span class="string">"add XCAsyncTestCase.podspec file”</span>

git push
</pre></td></tr></table></figure>

<p>最后，在你项目的Podfile里面加入这个第三方库的地址。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>pod <span class="string">'XCAsyncTestCase'</span>, <span class="symbol">:git</span> =&gt; <span class="string">'https://github.com/iiiyu/XCAsyncTestCase.git'</span>
</pre></td></tr></table></figure>

<p>就可以畅快的使用pod install了</p>
<p>五分钟打完收工有木有。很简单直白有木有。</p>
<p>当然这里只是一个hello world。 如果库中有一些高端设置比如要包含资源文件啊。 加入库依赖啊。 配置一些xcconfig。更多内容 请查看<a href="http://cocoapods.org" target="_blank">越来越好看的官方网站</a></p>
<h2 id="CocoaPods福利时间">CocoaPods福利时间</h2>
<p>以下是我平时使用经常用到的Podfile会用到的一些写法。</p>
<h3 id="福利一">福利一</h3>
<p>首先是有一些库编译时候会有警告。但是作为一个有洁癖的人呢不想看见这些</p>
<p>可以在platform :ios,  ‘x.0’的后面加入这句</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function_or_atom">inhibit_all_warnings</span><span class="exclamation_mark">!</span>
</pre></td></tr></table></figure>

<p>这样编译这些第三方库的时候就没有那些烦人的小警告了。</p>
<h3 id="福利二">福利二</h3>
<p>使用福利一是不是很爽呢。但是有一个神库ReactiveCocoa。当你关闭所有警告的时候。它就编译不过了。可急坏了。其实很简单对他单独设置打开编译警告就好了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>pod <span class="string">'ReactiveCocoa'</span>, <span class="string">'~&gt; 2.1.8'</span>, <span class="symbol">:inhibit_warnings</span> =&gt; <span class="keyword">true</span>
</pre></td></tr></table></figure>

<h3 id="福利三">福利三</h3>
<p>如果你有多个Targets需要pod的库怎么办<br>也很简单。Podfile的头部加入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>link_with [<span class="string">'AAAAA'</span>, <span class="string">'BBBBB'</span>]
</pre></td></tr></table></figure>

<p>AAAAA和BBBBB都是你target的名字，这样不同的target都会有pod库了。我主要是用来解决Unit Test需要pod install一些库的问题。当初也是找了老半天才找到。</p>
<h2 id="总结">总结</h2>
<p>CocoaPods很好用。而且一直在进化。我发现我怎么写介绍都只停留在很浅显的基础上。更多更深入的内容需要自己使用了。然后慢慢积累的。总之。不用CocoaPods的Cocoa开发太不潮了。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(30) Core Data是如何保存的？]]></title>
    <link href="http://iiiyu.com/2013/12/02/learning-ios-notes-thirty/"/>
    <id>http://iiiyu.com/2013/12/02/learning-ios-notes-thirty/</id>
    <published>2013-12-02T10:33:18.000Z</published>
    <updated>2014-02-17T04:20:41.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人记录使用，也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站，这样您将能在第一时间获取本站信息。</p>
<h2 id="开场扯淡">开场扯淡</h2>
<p>恩 一个月没有写一篇blog了。恩。就这样把。</p>
<a id="more"></a>

<p>学习使用Core Data也一年多了。之前以为3个月就可以登堂入室。事实是我图样图森破。到现在我也才勉强hello world而已。</p>
<p>比如这个问题 <strong>Core Data是如何保存的</strong>。</p>
<p>一直使用<a href="http://github.com/magicalpanda/MagicalRecord" target="_blank">MagicalRecord</a> 都被宠习惯了。 直接就调用MR_saveToPersistentStoreAndWait。反正能存进去，也没有太仔细的思考。</p>
<p>恩 最近对Core Data的技能点在进行增加中。所以还是多记录一些。</p>
<p>恰好看见了 DM大神的 blog <a href="http://mentalfaculty.tumblr.com/post/65682908577/how-does-core-data-save" target="_blank">How Does Core Data Save?</a></p>
<p>也不算翻译，就是自己写个自己的精简版本看看。</p>
<h2 id="Core_Data是如何保存的">Core Data是如何保存的</h2>
<ol>
<li>当然是NSManagedObjectContext调用save方法的时候。</li>
<li>这时候context里面持有的那些NSManagedObject将会自己调用自己的willSave方法。</li>
<li>NSManagedObjectContextWillSaveNotification发出。</li>
<li>开始验证。这个验证可能是你在data model里面写的。也可以是在NSManagedObject里面代码写的。</li>
<li>验证结束以后数据就合并到NSPersistentStoreCoordinator和NSPersistentStore里面。</li>
<li>如果你在合并的时候更改了数据。这时候会重新验证数据。</li>
<li>这个时候已经把需要验证过的合并数据存到持久化介质当中。</li>
<li>最后NSManagedObjectContextDidSaveNotification这个通知发出。</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<p><a href="http://mentalfaculty.tumblr.com/post/65682908577/how-does-core-data-save" target="_blank">How Does Core Data Save?</a></p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(29) 爱不释手的ReactiveCocoa之UIButton]]></title>
    <link href="http://iiiyu.com/2013/10/15/learning-ios-notes-twenty-nine/"/>
    <id>http://iiiyu.com/2013/10/15/learning-ios-notes-twenty-nine/</id>
    <published>2013-10-15T13:53:11.000Z</published>
    <updated>2014-02-17T04:20:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="开场扯淡">开场扯淡</h2>
<p>ReactiveCocoa的迭代速度相当快，一群富有才华和激情的人们在不断的进化ReactiveCocoa。欣欣向荣的景象啊。我这种hello world级别的也就只能使用他们的劳动成果了。上篇blog的时候我还在用1.9.x的版本 现在我已经全面转向2.x了。值得注意的是霓虹友人提交的cocoapods上ReactiveCocoa 2.1 版本我无法编译通过。目前我使用的还是2.0的版本。</p>
<p>介于一个月没有更新blog的速度，这次来写少一点的内容。</p>
<a id="more"></a>


<h2 id="传统的UIButton_Target_Action_方式">传统的UIButton Target Action 方式</h2>
<p>之前我们使用UIButton的点击方法一般有两种。一种是直接从xib里面拖一个IBAction出来在里面写代码。</p>
<p>另外一种是代码创建的 比如这样 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="built_in">UIButton</span> *myButton = [[<span class="built_in">UIButton</span> alloc] init...];
[myButton addTarget:something action:<span class="keyword">@selector</span>(myAction) forControlEvents:UIControlEventTouchUpInside];
</pre></td></tr></table></figure>

<p>然后在下面写一个myAction的方法来进行操作。</p>
<p>这样对我来说存在两个问题：</p>
<ol>
<li>button对应的方法分开了。在阅读代码的时候，当我想知道这个button对应的方法或者反过来action方法对应的button。通常需要跳转一次以上才能知道。(也许是我的阅读代码习惯比较原始)</li>
<li>我在action方法里面如果需要引用一个变量的时候，无法使用局部变量。通常就需要把这个资源设计为一个property。尽管这个资源或者变量只是在action里面调用一次。(这个也许是我写代码的问题)</li>
</ol>
<p>这两个可能在我遇见ReactiveCocoa都不能叫问题。但是在ReactiveCocoa里面我发现了更加优美的解决方法。好开心。</p>
<h2 id="ReactiveCocoa方式的UIButton">ReactiveCocoa方式的UIButton</h2>
<p>由于ReactiveCocoa高深的知识点，我也弄不太清楚。下面我只是说明怎么用的hello world级别。更多内容请阅读github上的项目主页。</p>
<p>如果使用xib。只需拖一个IBOutlet的property出来。比如这样</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIButton</span> *xibButton;
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="built_in">NSString</span> *helloWorld = @<span class="string">"hello world!!!"</span>;
<span class="keyword">self</span><span class="variable">.xibButton</span><span class="variable">.rac_command</span> = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) {
	<span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, helloWorld);
	<span class="keyword">return</span> [RACSignal empty];
}];
</pre></td></tr></table></figure>

<p>如果是代码创建一切照旧</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="built_in">NSString</span> *helloWorld = @<span class="string">"hello world!!!"</span>;
<span class="built_in">UIButton</span> *myButton = [<span class="built_in">UIButton</span> buttonWithType:UIButtonTypeSystem];
myButton<span class="variable">.frame</span> = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">50</span>);
[myButton setTitle:@<span class="string">"Say"</span> forState:UIControlStateNormal];
[<span class="keyword">self</span><span class="variable">.view</span> addSubview:myButton];
myButton<span class="variable">.rac_command</span> = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) {
	<span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, helloWorld);
	<span class="keyword">return</span> [RACSignal empty];
}];
</pre></td></tr></table></figure>

<p>这些代码我一般写在viewDidLoad方法里面。当然你可以在正确的地方使用他们。<br>运行试试。哇。魔法一般。完全解决我在传统的UIButton遇到的两个问题。</p>
<h2 id="总结">总结</h2>
<p>嗯嗯，这种小主题的blog写起来轻松愉快。大概40分钟就可以完成。以后要多多写小主题。这样跟写程序一样，化繁为简。这次就少扯淡了。期待我的下篇blog。啊哈哈</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(28) ReactiveCocoa 迎接下一个更加美好的世界（2013-10-13 update 2.0）]]></title>
    <link href="http://iiiyu.com/2013/09/11/learning-ios-notes-twenty-eight/"/>
    <id>http://iiiyu.com/2013/09/11/learning-ios-notes-twenty-eight/</id>
    <published>2013-09-11T12:45:13.000Z</published>
    <updated>2014-02-17T04:20:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="扯淡">扯淡</h2>
<p>习惯了，每次再写技术的东西的时候总要唠叨几句。本来唠叨的东西我应该会写成另外的blog。不过每次给自己下了一个底线要少少的写这些唠叨的话语。原因一是觉得我爱唠叨的话语可能会导致blog被墙。原因之二我不希望我变成一个IT评论家。</p>
<p>对了,我发现我还是挺爱挖坑的。目前有两坑没有填完。一个是Core Data系列。一个是iCloud系列。两个系列我都只写了一个Hello World级别并没有再深入的继续写。恩，要抓紧了。其实ReactiveCocoa这个我觉得也可以作为一个系列来写。不过想了想我这种Hello World的水平。也写不出这么多来。就暂时写一篇好了。</p>
<a id="more"></a>

<h2 id="什么是ReactiveCocoa">什么是ReactiveCocoa</h2>
<p>如果你有看Github的Trending Objective-C榜单，那你肯定是见过ReactiveCocoa了。如果你在weibo上关注唐巧、onevcat等国内一线知名开发者。那也应该听说过ReactiveCocoa了。</p>
<p>ReactiveCocoa更加被Mattt Thompson大神称为开启一个新Objective-C纪元。</p>
<p>当然也有人声称ReactiveCocoa是Cocoa的未来。<a href="http://spin.atomicobject.com/2013/04/28/reactivecocoa/" target="_blank">ReactiveCocoa: The Future of Cocoa Programming</a></p>
<p>我自己粗犷把现在的Objective-C分为两个阶段。</p>
<p>第一个阶段就是我学Cocoa开发之前的阶段：就是把Objective-C做出来的那群NeXT的大神，确定面向对象思想，确定消息机制，确定各种模式最后变成了Apple的主力开发语言。到后面OS X的各种库。iOS的各种库。</p>
<p>第二个阶段就是我学Cocoa开发之后的阶段：开始clang发力，配合Objective-C的快速进化：ARC，block，现代Objective-C语法。使其Objective-C不断获得现代语言类如Ruby, Python的优秀特性。</p>
<p>现在，说的最多的就是ReactiveCocoa将会把Objective-C带到下一个里程碑中。</p>
<p>ReactiveCocoa是一个基于Functional Reactive Programming编程思想的Objective-C实现开源的第三方库。最初的作者是Github的大神（Josh Abernathy &amp; Justin Spahr-Summers）。应该是再开发Github For Mac时候的附属产物。当然，我们必需得明白有时候附属产物要比真主牛逼的多了去了。比如万艾可，再比如青霉素，再再比如老干妈。</p>
<p>等等 什么是Functional Reactive Programming</p>
<h3 id="Functional_Reactive_Programming">Functional Reactive Programming</h3>
<p><a href="http://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank">wiki解释</a></p>
<h4 id="Reactive_Programming">Reactive Programming</h4>
<p><a href="http://zh.wikipedia.org/wiki/响应式编程" target="_blank">wiki 响应式编程</a></p>
<h4 id="Functional_programming">Functional programming</h4>
<p><a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank">wiki Functional programming</a></p>
<p>恩 简单来说 </p>
<pre><code><span class="attribute">Functional Reactive Programming </span>=<span class="string"> Functional programming + Reactive Programming</span>
</code></pre><p>(PS:特么太偷懒了还是解释一下)</p>
<p>简单以</p>
<p>a = b + c</p>
<p>为例</p>
<p>通常情况下在执行a = b + c的值的时候b和c当时是什么值。a就是当时的b+c。然后后来不管b和c怎么变化，a都不会改变。</p>
<p>但是在Execl中设置a格子=b格子+c格子的值。a的值就会随着b和c值的改变而改变。然后我还可以搞的高级一点f = a + d。 f格子的值也会随着b、c、d的值而改变。这就是使用Functional Reactive Programming以后会发生的情况。</p>
<p>Reactive的特性使得可以随时响应变化。Functional的特性使得他们可以串起来。</p>
<h3 id="来自微软实验室的编程思想">来自微软实验室的编程思想</h3>
<p>在<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/README.md#more-info" target="_blank">ReactiveCocoa的readme</a>我们看到ReactiveCocoa是基于.NET的Reactive Extensions(Rx)来的。啧啧身为一个脑残果粉不解释的我。也必须承认微软其实曾经一度集聚这世界上一大批大牛。这批大牛在闲着玩的时候做出来的玩具也指不定哪天就拯救世界了。</p>
<h4 id="Rx">Rx</h4>
<p>所以我也找了点Rx的资料来看看</p>
<p>中文里面比较全面的是这个<br><a href="http://www.cnblogs.com/yangecnu/archive/2012/11/03/Introducting_ReactiveExtensions.html" target="_blank">Reactive Extensions入门</a></p>
<p>里面有一堆链接和一个视频。c#实在看不懂，就只看了15分钟左右。不过那看上去蛮帅的哥们一开始说他在编程中遇到的问题。恰巧是我最近遇到的问题：就是我有两个在非主线程的异步操作。而我有可能需要等两个异步操作都完成的时候进行下一步操作。这种情况我一直没有找到比较优美的解决方法。直到遇见ReactiveCocoa，仿佛看见了希望。</p>
<h4 id="Model-View-ViewModel">Model-View-ViewModel</h4>
<p><a href="http://en.wikipedia.org/wiki/Model_View_ViewModel" target="_blank">洋文wiki</a></p>
<p><a href="http://baike.baidu.com/view/3507915.htm" target="_blank">中文wiki</a></p>
<p>FRP倾向于技术理论上的方法论。MVVM则是程序模式的方法论。就好比FRP给了一把解牛的刀。MVVM就是如何解牛的方法论。</p>
<p>相对来说MVVM通常跟MVC拿来比较。在我看来，没有绝对的好和坏。找个适合的就好了。再说我对两个东西的了解不够深入。</p>
<p><a href="http://cocoasamurai.blogspot.com/2013/03/basic-mvvm-with-reactivecocoa.html" target="_blank">Basic MVVM with ReactiveCocoa</a></p>
<p>这篇blog应该就写的蛮清楚了。</p>
<p>这是github上iOS的 MVVM例子<a href="https://github.com/Machx/MVVM-IOS-Example" target="_blank">MVVM-IOS-Example</a></p>
<p>大家可以感受一下。</p>
<h2 id="ReactiveCocoa的基本使用方法">ReactiveCocoa的基本使用方法</h2>
<p>(终于写到正主了,泪流满面)</p>
<p>这里借用Limboy的<a href="http://blog.leezhong.com/ios/2013/06/19/frp-reactivecocoa.html" target="_blank">blog</a>中的一段话作为开场解释。(因为我想了好久都没有想出超过他的比喻方法)</p>
<pre><code><span class="tag">ReactiveCocoa</span>是<span class="tag">github</span>去年开源的一个项目，是在<span class="tag">iOS</span>平台上对<span class="tag">FRP</span>的实现。<span class="tag">FRP</span>的核心是信号，信号在<span class="tag">ReactiveCocoa</span>(以下简称<span class="tag">RAC</span>)中是通过<span class="tag">RACSignal</span>来表示的，信号是数据流，可以被绑定和传递。
可以把信号想象成水龙头，只不过里面不是水，而是玻璃球(<span class="tag">value</span>)，直径跟水管的内径一样，这样就能保证玻璃球是依次排列，不会出现并排的情况(数据都是线性处理的，不会出现并发情况)。水龙头的开关默认是关的，除非有了接收方(<span class="tag">subscriber</span>)，才会打开。这样只要有新的玻璃球进来，就会自动传送给接收方。可以在水龙头上加一个过滤嘴(<span class="tag">filter</span>)，不符合的不让通过，也可以加一个改动装置，把球改变成符合自己的需求(<span class="tag">map</span>)。也可以把多个水龙头合并成一个新的水龙头(<span class="tag">combineLatest</span><span class="pseudo">:reduce</span><span class="pseudo">:)</span>，这样只要其中的一个水龙头有玻璃球出来，这个新合并的水龙头就会得到这个球。
</code></pre><h3 id="替代KVO">替代KVO</h3>
<p><del>官方例子：官方的例子貌似用了比较老的函数。我改完以后看见<a href="http://www.jdon.com/45581" target="_blank">什么是函数响应式编程(Functional Reactive Programming:FRP)</a>他也是这么改的。说明一下。</del></p>
<p>经过后来的使用才发现特么官方例子是2.0的。 现在重新改一下。随便说一句，用cocoapods安装的2.1.编译不过。具体原因还没有看。建议使用2.0</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">@property</span> (<span class="keyword">strong</span>) <span class="built_in">NSString</span> *username;

[RACObserve(<span class="keyword">self</span>, username) subscribeNext:^(<span class="built_in">NSString</span> *newName) {
								<span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, newName);
							}];
</pre></td></tr></table></figure>

<p>在这句代码以后，只要你的username有变化。都可以打印出来。实现了KVO的功能却减少了无数的代码。体现了绑定和响应。</p>
<p>高级一个点的官方例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>[[RACObserve(<span class="keyword">self</span>, username)
  filter:^(<span class="built_in">NSString</span> *newName) {
		<span class="keyword">return</span> [newName hasPrefix:@<span class="string">"j"</span>];
	}]
 subscribeNext:^(<span class="built_in">NSString</span> *newName) {
	 <span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, newName);
 }];
</pre></td></tr></table></figure>

<p>第一个例子是简单的所有变化都会响应到。但是可能我只想响应部分情况。这时候就用filter来过滤。filter的block返回YES的情况就是需要触发的情况。其他就补返回。所以这代码以后。 username以j开头的才能打印出来。</p>
<h3 id="流的实现">流的实现</h3>
<p>以下是<a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/" target="_blank">Getting Started with ReactiveCocoa</a>的例子和图片</p>
<p>如何以最少的代码实现一个时钟应用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>RAC(<span class="keyword">self</span>, timeLabel<span class="variable">.text</span>) = [[[RACSignal interval:<span class="number">1</span> onScheduler:[RACScheduler currentScheduler]] startWith:[<span class="built_in">NSDate</span> date]] map:^<span class="keyword">id</span> (<span class="built_in">NSDate</span> *value) {
	<span class="built_in">NSLog</span>(@<span class="string">"value:%@"</span>, value);
	NSDateComponents *dateComponents = [[<span class="built_in">NSCalendar</span> currentCalendar] components:NSHourCalendarUnit |
	 NSMinuteCalendarUnit | 
	 NSSecondCalendarUnit fromDate:value];
	<span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:@<span class="string">"%02ld:%02ld:%02ld"</span>, (<span class="keyword">long</span>)dateComponents<span class="variable">.hour</span>, (<span class="keyword">long</span>)dateComponents<span class="variable">.minute</span>, (<span class="keyword">long</span>)dateComponents<span class="variable">.second</span>];
}];
</pre></td></tr></table></figure>

<p>实现的逻辑顺序是这样的。设置一个间隔为一秒。从现在开始调用的函数。并把当前实际传入。 这个函数返回一个NSString。 然后把这个NSString和界面上的textField绑定在了一起。从而实现了我认为我见过最简单时钟程序。表现了流和绑定响应。</p>
<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/chaining.png" alt="原blog中对上述代码的流的形容图"></p>
<h3 id="组合">组合</h3>
<p>几乎每个ReactiveCocoa的Demo里面都会出现的例子。</p>
<p>(继续盗图图)</p>
<p><img src="http://blog.leezhong.com/image/FRP_register_demo.png" alt=""></p>
<p>这个是用的leezhong的图。 应该是从<a href="https://speakerdeck.com/andrewsardone/reactivecocoa-at-mobidevday-2013" target="_blank">这个演讲PPT里面来的，点过去还有视频哦</a></p>
<p>就是说在必需验证每个所填写的数值符合标准。Button才能点击。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>RAC(<span class="keyword">self</span>, submitButton<span class="variable">.enabled</span>) = [RACSignal combineLatest:@[<span class="keyword">self</span><span class="variable">.usernameField</span><span class="variable">.rac_textSignal</span>,
				 <span class="keyword">self</span><span class="variable">.passwordField</span><span class="variable">.rac_textSignal</span>]
	reduce:^<span class="keyword">id</span> (<span class="built_in">NSString</span> *userName, <span class="built_in">NSString</span> *password) {
	<span class="keyword">return</span> @(userName<span class="variable">.length</span> &gt;= <span class="number">6</span> && password<span class="variable">.length</span> &gt;= <span class="number">6</span>);
}];
</pre></td></tr></table></figure>

<p>简单的解释就是把usernameField和passwordField的信号绑定在了一起做reduce处理以后。返回一个BOOL值去跟self.submitButton.enabled进行绑定。</p>
<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/combining.png" alt=""></p>
<p>囧。再次发现和leezhong借用的代码和图都是一样的。</p>
<h3 id="异步和网络">异步和网络</h3>
<p>(丢个链接 等心情好了 在补。。。)</p>
<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa#when-to-use-reactivecocoa" target="_blank">when-to-use-reactivecocoa</a></p>
<h2 id="总结">总结</h2>
<p>其实我对ReactiveCocoa了解还是在hello world阶段。 很多东西都理解的很粗糙。上面这一大陀blog。很多地方写的肯定不好。欢迎指出。其实很多时候觉得确实中文原创的技术文章十分少。很大一部分都是翻译的。国外的技术文章也确实写的牛写的好。但是总觉得自己应该写点自己思考的东西。</p>
<p>对于ReactiveCocoa来说，我认为它确实是一个好东西。正如leezhong所说<br>    RAC统一了对KVO、UI Event、Network request、Async work的处理，因为它们本质上都是值的变化(Values over time)。</p>
<p>其实App上90%的操作不就只有这些么。所以我会一直对ReactiveCocoa投入时间去学习和使用。顺便说一句。阿里Mac Lab出品的Xiami for Mac。是我见过国内最好的Mac App之一。他们也用了ReactiveCocoa。然后你可以想象对他们做出那些响应交互ReactiveCocoa为他们提供了强有力的输出。</p>
<h2 id="参考资料">参考资料</h2>
<h3 id="FRP">FRP</h3>
<p><a href="http://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank">wiki Functional reactive programming</a></p>
<p><a href="http://blog.zhaojie.me/2009/09/functional-reactive-programming-for-csharp.html" target="_blank">趣味编程：Functional Reactive Programming</a></p>
<p><a href="http://www.haskell.org/haskellwiki/Functional_Reactive_Programming" target="_blank">haskell Functional Reactive Programming</a></p>
<p><a href="http://zh.wikipedia.org/wiki/响应式编程" target="_blank">wiki 响应式编程</a></p>
<p><a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank">wiki Functional programming</a></p>
<p><a href="http://www.infoq.com/cn/articles/functional-reactive-programming" target="_blank">函数式反应型编程(FRP) —— 实时互动应用开发的新思路</a></p>
<p><a href="http://www.jdon.com/45581" target="_blank">什么是函数响应式编程(Functional Reactive Programming:FRP)</a></p>
<p><a href="http://www.cnblogs.com/yangecnu/archive/2012/11/03/Introducting_ReactiveExtensions.html" target="_blank">Reactive Extensions入门</a></p>
<h3 id="ReactiveCocoa">ReactiveCocoa</h3>
<p><a href="http://blog.leezhong.com/ios/2013/06/19/frp-reactivecocoa.html" target="_blank">ReactiveCocoa与Functional Reactive Programming</a></p>
<p><a href="https://speakerdeck.com/joshaber/better-code-for-a-better-world" target="_blank">Better Code for a Better World by Josh Abernathy</a></p>
<p><a href="http://nshipster.com/reactivecocoa/" target="_blank">nshipster Reactive​Cocoa</a></p>
<p><a href="http://spin.atomicobject.com/2013/04/28/reactivecocoa/" target="_blank">ReactiveCocoa: The Future of Cocoa Programming</a></p>
<p><a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/" target="_blank">Getting Started with ReactiveCocoa</a></p>
<p><a href="http://www.teehanlax.com/blog/reactivecocoa/" target="_blank">Functional Reactive Programming on iOS with ReactiveCocoa</a></p>
<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/BasicOperators.md" target="_blank">Basic Operators</a></p>
<p><a href="http://cocoasamurai.blogspot.com/2013/03/basic-mvvm-with-reactivecocoa.html" target="_blank">Basic MVVM with ReactiveCocoa<br>MVC - One Pattern to Rule them all</a></p>
<p><a href="http://twocentstudios.com/blog/2013/04/03/the-making-of-vinylogue/#design" target="_blank">How I Wrote Vinylogue for iOS With ReactiveCocoa</a></p>
<p><a href="https://github.com/RoCry/rocry.github.com/wiki/Project_ReactiveCocoa" target="_blank">来自好友RoCry的推荐</a></p>
<p><a href="https://speakerdeck.com/andrewsardone/reactivecocoa-at-mobidevday-2013" target="_blank">ReactiveCocoa at MobiDevDay 2013</a></p>
<p><a href="https://vimeo.com/65637501" target="_blank">ReactiveCocoa at MobiDevDay 2013视频</a></p>
<p><a href="http://blog.maybeapps.com/#fn:p42894317939-5" target="_blank">Input and Output</a></p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(27) iCloud(三) key-Value Stroe]]></title>
    <link href="http://iiiyu.com/2013/09/02/learning-ios-notes-twenty-seven/"/>
    <id>http://iiiyu.com/2013/09/02/learning-ios-notes-twenty-seven/</id>
    <published>2013-09-02T14:21:13.000Z</published>
    <updated>2014-02-17T04:20:22.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是NSUserDefaults">什么是NSUserDefaults</h2>
<p>NSUserDefaults的持久化本体是一个<a href="http://zh.wikipedia.org/zh/Plist" target="_blank">plist</a>.内存单例是一个操作类似NSDictionary的类。 而NSUserDefaults的出现我想是因为在每一个程序当中。我们都会设定一些选项。比如桌面壁纸、声音大小、提醒日期等，我们希望就算App关闭以后。我们再次打开的时候还在的东西。但是它并不适合存储App中关键的内容和用户自己产生的大量数据。 大量数据应该用更加合理的方式去做持久化(Document or Core Data).</p>
<a id="more"></a>

<h3 id="NSUserDefaults简单代码讲解">NSUserDefaults简单代码讲解</h3>
<p>使用NSUserDefaults其实巨简单。 </p>
<p>大概步骤如下:</p>
<ol>
<li>首先通过一个单例获得持久化plist的内存映射。</li>
<li>然后就可以用这个单例的实例类进行读写操作。</li>
<li>读当然没啥问题，但是写了的话这时候只是操作了在内存里面的这个单例实例。需要做持久化的动作。为什么这个动作要自己来做呢。我想是持久化都是进行IO操作。而IO操作其实很多时候就是性能的瓶颈所在。我们可能很短的时间内一次性操作很多次NSUserDefaults。这样就只用在结束的时候保存一次。IO操作就很少。反之如果每次写NSUserDefaults的时候都去做持久化。那刚刚的情况就会在很短的时间内操作多次IO。这是应该避免的。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="comment">// 首先把数据从plist里面读到内存里面的单例来</span>
<span class="built_in">NSUserDefaults</span> *standardDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];

<span class="comment">// 进行增加or修改操作</span>
[standardDefaults setObject:@<span class="string">"a123456789"</span> forKey:@<span class="string">"userID"</span>];
[standardDefaults setInteger:<span class="number">24</span> forKey:@<span class="string">"age"</span>];
[standardDefaults setBool:<span class="literal">YES</span> forKey:@<span class="string">"isLogin"</span>];

<span class="comment">// 删除操作</span>
[standardDefaults removeObjectForKey:@<span class="string">"debts"</span>];

<span class="comment">// 从内存里面写入plist进行持久化</span>
[standardDefaults synchronize];

<span class="comment">// 读取操作</span>
<span class="built_in">NSString</span> *userID = [standardDefaults stringForKey:@<span class="string">"userID"</span>];
<span class="built_in">BOOL</span> isLogin = [standardDefaults boolForKey:@<span class="string">"isLogin"</span>];
</pre></td></tr></table></figure>

<p>当然还有现代一点的写法。下面两种都是一个效果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// 常见方法</span>
<span class="built_in">NSUserDefaults</span> *standardDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];
<span class="keyword">if</span> ([standardDefaults stringForKey:@<span class="string">"favoriteColor"</span>] == <span class="literal">nil</span>) {
[standardDefaults setObject:@<span class="string">"Green"</span> forKey:@<span class="string">"favoriteColor"</span>];
[standardDefaults synchronize];
}

<span class="comment">// 现代高端上档次方法</span>
<span class="built_in">NSUserDefaults</span> *standardDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];
[standardDefaults registerDefaults:@{@<span class="string">"favoriteColor"</span>: @<span class="string">"Green"</span>}];
[standardDefaults synchronize];
</pre></td></tr></table></figure>

<h2 id="iCloud的Key-Value">iCloud的Key-Value</h2>
<p>简单的，可以把iCloud的key-value当作一个在云端的NSUserDefaults。</p>
<p>我的用法是，App的Setting最终设置决定的还是NSUserDefaults。iCloud的Key-Value作为数据源来对NSUserDefaults进行修改。这样的优点在于，就算iCloud关闭或者iCloud的数据没有同步回来。你的App依然可以正常的工作和运行。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">NSUserDefaults</span> *standardDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];
</pre></td></tr></table></figure>

<p>对应</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">NSUbiquitousKeyValueStore* store </span>=<span class="string"> [NSUbiquitousKeyValueStore defaultStore];</span>
</pre></td></tr></table></figure>

<p>其他操作跟NSUserDefaults一样一样的。</p>
<p>只有一个值得注意的是NSUbiquitousKeyValueStore需要去监听<br>NSUbiquitousKeyValueStoreDidChangeExternallyNotification事件。就可以知道NSUbiquitousKeyValueStore是否已经同步更新完成。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>NSUbiquitousKeyValueStore* store = [NSUbiquitousKeyValueStore defaultStore];
[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span>
          selector:<span class="keyword">@selector</span>(updateKVStoreItems:)
          name:NSUbiquitousKeyValueStoreDidChangeExternallyNotification
          object:store];
[store synchronize];
</pre></td></tr></table></figure>

<p>然后实现updateKVStoreItems:方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)updateKVStoreItems:(<span class="built_in">NSNotification</span>*)notification {
   <span class="comment">// Get the list of keys that changed.</span>
   <span class="built_in">NSDictionary</span>* userInfo = [notification userInfo];
   <span class="built_in">NSNumber</span>* reasonForChange = [userInfo objectForKey:NSUbiquitousKeyValueStoreChangeReasonKey];
   <span class="built_in">NSInteger</span> reason = -<span class="number">1</span>;
 
   <span class="comment">// If a reason could not be determined, do not update anything.</span>
   <span class="keyword">if</span> (!reasonForChange)
      <span class="keyword">return</span>;
 
   <span class="comment">// Update only for changes from the server.</span>
   reason = [reasonForChange integerValue];
   <span class="keyword">if</span> ((reason == NSUbiquitousKeyValueStoreServerChange) ||
         (reason == NSUbiquitousKeyValueStoreInitialSyncChange)) {
      <span class="comment">// If something is changing externally, get the changes</span>
      <span class="comment">// and update the corresponding keys locally.</span>
      <span class="built_in">NSArray</span>* changedKeys = [userInfo objectForKey:NSUbiquitousKeyValueStoreChangedKeysKey];
      NSUbiquitousKeyValueStore* store = [NSUbiquitousKeyValueStore defaultStore];
      <span class="built_in">NSUserDefaults</span>* userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];
 
      <span class="comment">// This loop assumes you are using the same key names in both</span>
      <span class="comment">// the user defaults database and the iCloud key-value store</span>
      <span class="keyword">for</span> (<span class="built_in">NSString</span>* key in changedKeys) {
         <span class="keyword">id</span> value = [store objectForKey:key];
         [userDefaults setObject:value forKey:key];
      }
   }
}
</pre></td></tr></table></figure>

<p>超级简单吧。</p>
<h2 id="第三方库推荐">第三方库推荐</h2>
<p>当然有大神写的第三方库。并且实现了NSUserDefaults白名单功能。因为可能你存在NSUserDefaults里面的东西不想要也不需要全部同步到NSUbiquitousKeyValueStore上去把。</p>
<p>对了忘记说一点NSUbiquitousKeyValueStore可是有大小和条目限制的。你不要把他当作无穷无尽的东西来用。具体限制是最大空间1 MB。 最多1024个key。记住不要拿来当作主要数据存储哦。</p>
<p>MK大神应该还是如雷贯耳的把。 不知道么。 MKNetworkKit是他写的。还不知道么。<br><a href="http://www.amazon.com/gp/product/1118449959/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1118449959&amp;linkCode=as2&amp;tag=blogmugunthku-20" target="_blank">iOS 6 Programming Pushing the Limits: Advanced Application Development for Apple iPhone, iPad and iPod Touch</a> 可是他写的哦。我和我的小伙伴都从MK大神的书里面学到很多不错的东西</p>
<p><a href="https://github.com/MugunthKumar/MKiCloudSync" target="_blank">MKiCloudSync</a></p>
<p><a href="https://github.com/Daij-Djan/DDiCloudSync" target="_blank">DDiCloudSync</a></p>
<p><a href="https://github.com/futuretap/FTiCloudSync" target="_blank">FTiCloudSync</a></p>
<h2 id="总结">总结</h2>
<p>参考资料：</p>
<p><a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/UserDefaults/Introduction/Introduction.html" target="_blank">Preferences and Settings Programming Guide</a></p>
<p><a href="http://gibuloto.com/blog/nsuserdefaults/" target="_blank">NSUserDefaults (plist) 筆記</a></p>
<p><a href="http://www.doubleencore.com/2013/03/back-to-basics-forgotten-nsuserdefaults/" target="_blank">Back to Basics: Forgotten NSUserDefaults</a></p>
<p><a href="http://www.techotopia.com/index.php/Synchronizing_iPhone_iOS_5_Key-Value_Data_using_iCloud" target="_blank">Synchronizing iPhone iOS 5 Key-Value Data using iCloud</a></p>
<p><a href="http://useyourloaf.com/blog/2011/10/24/sync-preference-data-with-icloud.html" target="_blank">Sync Preference Data With iCloud</a></p>
<p><a href="http://www.raywenderlich.com/6015/beginning-icloud-in-ios-5-tutorial-part-1" target="_blank">Beginning iCloud in iOS 5 Tutorial Part 1</a></p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(26) iCloud(二) 准备工作]]></title>
    <link href="http://iiiyu.com/2013/08/26/learning-ios-notes-twenty-six/"/>
    <id>http://iiiyu.com/2013/08/26/learning-ios-notes-twenty-six/</id>
    <published>2013-08-26T14:43:11.000Z</published>
    <updated>2014-02-17T04:20:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="开发支持iCloud的上半部分前期准备">开发支持iCloud的上半部分前期准备</h2>
<ul>
<li><p>需要申请一个开发者的帐号。理论上iOS和Mac OSX的都OK。考虑到我只有iOS的情况下，我的文章里面的例子默认只是iOS的。</p>
</li>
<li><p>你需要一台iOS设备，并且iOS版本必须大于等于5.最好大于等于6. 最最好大于等于7。</p>
</li>
<li><p>Xcode不用说至少是MAS里面最新的</p>
</li>
<li><p>然后去建立App Bundle ID的页面去把iCloud支持打开。</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e88hq7q78aj20sa0g2tav.jpg" alt="1"></p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e88hqn9gdej20s60h2wgz.jpg" alt="2"></p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e88hqn9gdej20s60h2wgz.jpg" alt="3"></p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e88hts5dkpj20k70en75m.jpg" alt="4"></p>
<ul>
<li>bundle id需要生成带你测试设备的证书</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e88htyxylrj20rw0egmzm.jpg" alt="5"></p>
<p>(PS:截图太累了 换成文章描述)</p>
<p>这样才能算iCloud的前期工作做完了一半。</p>
<p><strong>以下涉及到NDA内容请自行屏蔽</strong><br><a id="more"></a></p>
<ul>
<li>据说Xcode5里面支持直接开启iCloud支持，推送服务支持等。不用去登录网页了。</li>
</ul>
<ul>
<li>据说Xcode5支持iCloud调试了不需要真机了。可是特么只是支持iCloud Key-Value。Document和Core Data还是需要你一台强力的真机。</li>
</ul>
<p>(详细和剩下的大家自行脑补)</p>
<h2 id="开发支持iCloud的下半部分前期准备">开发支持iCloud的下半部分前期准备</h2>
<ul>
<li>建立一个跟上部分bundle id一样的工程项目</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e88iciw7yaj212w0qfn0a.jpg" alt="6"></p>
<ul>
<li><p>然后在工程里面把entitlements勾上以后。</p>
</li>
<li><p>支持key-value stroe把勾选上</p>
</li>
<li><p>支持Document和Core Data要添加ubiquity containers</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e88id4vlv3j20jc0a63z9.jpg" alt="7"></p>
<p>到这里，总算是把准备工作弄好了。每一个支持iCloud的App。都必须经过上面的步骤。不可跳过直接去写代码。切记切记。</p>
<h2 id="开发iCloud基本思维">开发iCloud基本思维</h2>
<ol>
<li>iCloud是网络远端的数据存储服务。最终目的是确保所有设备上的所有数据一致性。 </li>
<li>使用iCloud的机制不是纯网络服务。简单的说就是在没有网络的情况下。你的App应该是可以畅通无阻的运行，并且没有缺失功能。iCloud存储的是数据的源头，App里面应该会有对应的缓存确保这样的机制。所以有多少台设备，就有多少份缓存的数据。</li>
<li>缓存数据的份数多了，为了保持数据的一致性。需要同步机制来保持更新，这时候不可避免的会产生数据冲突。就需要解决冲突。</li>
</ol>
<p>所以，只要是使用了iCloud。不论那种形式。我们都必须面对下面的几种情况并且需要对这些情况进行响应的处理：</p>
<ol>
<li>何时开启iCloud同步服务</li>
<li>在App内部关闭了iCloud以后，App的应对措施。</li>
<li>在App外部关闭了iCloud以后，App的应对措施。</li>
<li>开启iCloud以后，iCloud数据和本地数据之间的处理。</li>
<li>开启iCloud以后，正在同步数据时，UI的应对措施。</li>
<li>使用iCloud以后，当数据完成更新的时候。UI的应对措施。</li>
<li>iCloud数据冲突时候App的处理。</li>
</ol>
<p>以上是临时能回忆起来的一些需要处理的情况。真实情况可能要复杂的多。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[深夜吐槽多看]]></title>
    <link href="http://iiiyu.com/2013/08/22/tu-cao-duo-kan/"/>
    <id>http://iiiyu.com/2013/08/22/tu-cao-duo-kan/</id>
    <published>2013-08-21T17:48:34.000Z</published>
    <updated>2014-02-17T04:19:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="深夜吐槽多看">深夜吐槽多看</h2>
<p>好吧，作为一个喜欢看书的人和觉得多看做的确实好的普通用户。我把我个人的想法完整的表达一下。</p>
<a id="more"></a>

<h2 id="前提">前提</h2>
<p>首先，在国内阅读App上对我来说。多看目前已经遥遥领先。其实记得当初在iOS上引爆中文阅读的是唐茶从&lt;失控&gt;到&lt;史蒂夫·乔布斯传&gt;。让人觉得电子中文阅读还可以这么美。而多看是从Kindle起来，所以说做阅读的时间不比唐茶短。真正的混战是在字节社、多看(更新了一个版本)、豆瓣阅读上。三个App我都在对比，都在用。KK的全部书籍我都是在字节社买的。当时字节社的书更新较快。多看出于一个跟随者的角色当中。一般是字节社上了多看才上。两个都想做成中文电子书的最大平台，那时候机会看起来势均力敌甚至字节社还要有一些优势。其实那时候我喜欢的豆瓣阅读的风格。豆瓣阅读的设计平淡如茶。不像字节社的大红和多看的大黄。可惜豆瓣貌似没有想往阅读方向上大力发展。至于现在，半年都不更新一次的豆瓣阅读已经很少打开了。简单点说后来是字节社被下架很长时间。书目的种类和网上书店被多看给超越。多看也在一直努力。App做的越来越好,UI交互的重新设计，PDF的重排达到逆天的级别(我想这跟Kindle的技术积累密不可分)。至于我现在想买书的首选是多看。这段主要是表达我确实是喜欢多看阅读的。</p>
<p>其次，说一下我不喜欢的。 我不喜欢小米。跟我不喜欢隔壁大胸的妹子理由一样。 不喜欢就不喜欢呗，跟她胸大不大没关系。虽然现在多看和小米是好基友。看意图也是多看要成为小米整个体系重要的一部分。问题是我特么的不喜欢小米，没有小米手机。我就是一个普普通通的多看用户。我想用多看，而不是想用小米的一部分。然后这里就能说到帐号迁移了。我根本不想迁移去变成小米帐号。为此我还特意去多看的官网上面去看了Q&amp;A.得到的结论就是迁移是必需的。必需就是没有选择的余地。我真心觉得这个迁移很恶心，至少恶心到我觉得如果我能找到一个替代的App。我宁愿去用其他的App。结果目前还真没有能替代多看的。悲从心中来啊。虽然说迁移给了5米币啥的。但是感觉上就是把人领出去卖了，然后在卖的路上买了颗糖给吃的感觉。</p>
<h2 id="发现Bug">发现Bug</h2>
<p>相当相当的不爽。但是这些恶心的事情，都没有能阻止我想用多看看书的欲望。当我发现多看居然在搞活动。100以下卖多少送多少。想想每月买书支出应该也有个两三百。所以相当于5折了。心想还不错。暂时不想迁移这个事情来恶心自己了。结果特么在开始前的半小时我发现，特么只能是Android用户才有优惠顿时崩溃了。感觉不会在爱了，赶紧在微波上@多看的运营妹子问怎么办。然后回复我叫我借一台Android在上面购买。我方圆几百公里就特么认识一台Android。赶紧过去献媚的叫人家借我用用。 当我小心翼翼的捧这高端大气上档次的米1笨手笨脚的登录多看的时候。觉得能剩点钱还是值得的。当我点开多看准备把冯唐的书全部收掉的时候。发现都是下载。没有购买。赶紧问问手机的高富帅。人家说刚刚买了这几本！！！！多看你是闹那样。登出了这种私人用户信息都不清空。思考了一下。征求了高富帅的意见，我把多看App删除了。然后用高富帅的3G网络畅快的重新下载了一个多看App。然后又小心翼翼的捧这高端大气上档次的米1笨手笨脚的登录多看。结果特么结果还是一样的啊。人家购买过的。我没有购买的登录进去是下载，不是购买。简单点说就是大Bug啊。用户信息都特么乱穿掉了。这时候我只能手里握着100块。以45度仰望天空。默默的在微波上留言吐槽一下。</p>
<h2 id="回应反馈">回应反馈</h2>
<p>接下来是回应一下 happia 这位应该是多看员工。</p>
<p>happia的回复我整理一下大概内容如下：</p>
<p>我：为什么只有Android做活动？</p>
<p>happia：这次之所以指定了平台，是米币中心出于安全考虑，只允许在手机上进行。其实iOS平台和Kindle平台都不支持用米币买书，这个限制只是不允许在网页上参与。</p>
<p>我：为什么会有用户信息在登出的情况下还会混乱的bug？</p>
<p>happia：1、因为这次是米币第一次做公开的优惠活动，所以会谨慎很多，涉及到大规模交易的事情都要很小心，弄不好最后银行结算会出大问题。现在还在积累电子支付经验的阶段。2、这本书如果已经下载了，那就不会再显示购买按钮，而是显示阅读。你在书架上看看有没有这本书？</p>
<p>对于绝大多数情况，这样是最好的选择</p>
<p>简单的说，一个手机上在多看阅读上上用多个账户的情况很少，而且既然书架上已经有了，又要去换个账号买一次的情况更少。既然书架上已经有了，一般人都会直接打开，而不会再去买一次。这个情况已经属于特例中的特例了。</p>
<p>下面是回复吐槽：</p>
<p>至今没有搞懂你们策划为什么不允许在网页上参与。解释为支付安全考虑。毫无说服力，就算说策划的只想做Android就不做其他我都能接受。因为根本无法理解Android上支付能比网页支付安全。更何况可以是在你Android上购买了然后跳转到支付宝去网页上支付。还是说只要对普通用户解释为安全问题比较好解释？</p>
<p>米币。呵呵都往虚拟货币搞。 想的倒是很美好。这也是为什么我不想迁移的原因。</p>
<p>然后是bug的解释。我在微波上回复了一句：神逻辑。现在来解释一下什么意思.我工作以后渐渐的受到影响还是蛮尊重版权。现在电脑上可以自豪的说是全正版。反正买不起的就不用了呗。因为既然我喜欢的软件我希望作者在把他做的更好。对于书也是一样，我喜爱的文字，喜欢的思想。我都愿意付出一点。让作者能够收获一些。继续写出好看的文字，重要的智慧。让他知道自己的付出是有收获的。扯远了。 拉回来。</p>
<p>所以，当我用我的帐号去登录多看的时候。这时候的信息应该是我的。就算之前的帐号有下载过书籍作为缓存。但是我的帐号里面没有这本书，这本书是不应该显示在书架上的。然后我也可以购买啥的。这个对于我来说才是正常逻辑。也符合目前看起来的版权问题。</p>
<p>关于电子书的版权的情况现在我自己也很纠结。实体书，我买了。我可以随便借给任何人看。没有任何问题。但是电子书呢？公然的丢到网络上必然是不行的。但是我周围的人呢。可以借给他们看么。我也不知道答案。所以，现在我周围都是一本书说好看。然后大家就一起买。一个是电子书总体来说还是相对较便宜。一个是大家版权意思都在逐渐提高了。</p>
<p>最后扯回来这个bug。大可有一个帐号买了所有的书。然后进行分享。然后大家也只是偶然登录了一下这个有所有书的帐号。然后下载了全部的书。然后登录回来了自己的帐号。那这个时候，我看的书是正版？盗版？</p>
<h2 id="总结吐槽">总结吐槽</h2>
<p>哎。没忍住。一下吐槽这么多。</p>
<p>最后的吐槽： 进来多看上的书是越来越多了。但是质量下降的厉害。比如那本&lt;改变未来的九大算法&gt; 翻译如同丢到google翻译 然后就拿出来卖。很是失望，希望能有退款通道。对这种没有节操的书进行退款处理</p>
<p>还有就是为啥自己导入的PDF观看的时间没有进入阅历中啊！！！！！</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/just-talk/" term="just-talk"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(25) iCloud(一) 概览]]></title>
    <link href="http://iiiyu.com/2013/08/19/learning-ios-notes-twenty-five/"/>
    <id>http://iiiyu.com/2013/08/19/learning-ios-notes-twenty-five/</id>
    <published>2013-08-19T14:29:37.000Z</published>
    <updated>2014-02-17T04:20:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是iCloud">什么是iCloud</h2>
<p>iCloud是苹果公司提供的云服务的总称。每一个拥有Apple ID的用户都拥有5G大小的空间使用权。用户可以使用iCloud的空间来进行数据的备份，联系人备份，照片备份，应用备份等。好处就是当你有多台设备或者是换新的设备的时候。可以有无差别的体验。</p>
<p>对于开发者来说，iCloud相当于提供了一种官方形式的云端存储形式。帮助你的App实现所谓理想的状态。不论用户在什么设备打开App。 里面的数据，设置，形状，大小。都跟他上次打开的一模一样。这样你的App会给你的用户非一般的体验。</p>
<h2 id="开发慎用iCloud">开发慎用iCloud</h2>
<p>上一段说了iCloud的优点，其实是接近意淫中的理想状态。我以近一年的血泪史告诫，初级开发者，应该避免使用iCloud。中高级开发者视项目规划内容酌情使用。如果能有其他方案替代iCloud，建议优先使用其他方案。</p>
<p>初级开发者: iCloud的三种存储方式 Key-Value， Documents， Core Data都是在之前已有的框架上进行扩展的高级接口。换言之，你应该先具备了这三种技术的基本知识再开始考虑学习iCloud。 iCloud + Key-Value对应的基础是NSUserDefaults。 iCloud + Documents对应的基础是使用文档进行数据存储(NSFileManager,NSFileCoordinator,NSFileWrapper,NSCoding等一系列持久化数据存储到文件的问题). iCloud + Core Data的对应基础就是Core Data。本来是强烈建议如果没有这些基础的人不要直接来学习iCloud的。但是谁都是一步一步走过来的，如果要用到iCloud的某一种方式。建议先把基础的持久化方式原理弄懂了，在看iCloud的部分。不然学习门槛的过高，会使得进度无法按时推进。</p>
<p>中高级开发者：如果是已经用过Key-Value，Documents，Core Data的。应该会很快能明白iCloud的原理。 而进行开发。但是值得注意的是，iCloud的使用和调试会非常的消耗时间和精力。并且和你的当前网络状态息息相关。然后会出现各种诡异的情况。这个时候你都需要淡定很超级的耐心。去找到这些坑，然后慢慢的积累经验去绕过这些坑。（在这里先挖坑，后面在慢慢写我的一些使用经验）</p>
<a id="more"></a>

<h1 id="为什么要用iCloud">为什么要用iCloud</h1>
<p>既然iCloud这么多坑。为什么还要使用iCloud进行开发呢？这个问题最近半年的每周的某些时候我都会这样的问自己。 </p>
<p>个人觉得最重要的是:</p>
<p><strong>在需要数据统一的服务里面，几乎所有的第三方服务和自己搭建服务器为了识别唯一的用户。都需要进行一次注册流程。这是不可避免的。但是把注册用户的流程接入App里面。对我来说不能第一次打开就畅快的使用App是难以忍受的。iCloud由于是基于Apple ID的，相当于一个正常的用户来说是必备的。所以，使用iCloud技术可以避免注册用户流程。和App登入功能。即开即用的体验会大大提高。</strong></p>
<p>(注意，在这里我说的是几乎所有的第三方服务不包括Dropbox。Dropbox<a href="https://www.dropbox.com/developers/datastore" target="_blank">新的Datastore API</a>和本身Dropbox的普及率感觉会比注册要好一些。继续挖坑以后填)</p>
<p>其他的原因我觉得不是很重要但是还是列出来：</p>
<ol>
<li>iCloud是Apple的服务。好歹是市值4000亿刀的公司。理论上来说比小公司靠谱一些把。</li>
<li>iCloud是Apple自家的服务。App里面如果使用到了iCloud服务。理论上来说会被官方推荐的机率大了一些</li>
<li>如果以后做Apple全平台(iOS,Mac)自然对接起来应该方便一些。(感觉这个是YY)</li>
</ol>
<h2 id="除了iCloud还能用啥">除了iCloud还能用啥</h2>
<h3 id="Dropbox">Dropbox</h3>
<p>第一个顺位的自然是<a href="https://www.dropbox.com/developers" target="_blank">Dropbox</a>.</p>
<p>Dropbox不仅仅是一个无处不在的U盘。它还可以变成你App的数据存储端。而且新的Datastore API也显示着Dropbox会大力的发展成为App的数据端的决心。</p>
<h3 id="Parse">Parse</h3>
<p><a href="https://www.parse.com" target="_blank">Parse</a>的顺位也相当高。 原因在于，Parse的服务不仅仅有Data。还具备推送、社交分享等一系列高端大气上档次的功能。而且它的SDK覆盖了所有主流平台(iOS OSX Android JS WP8 W8 .NET)。更加重要的是，它在一定数据和请求量上是免费的。如果你的用户做到超过它的免费额度。我觉得这个时候你也就能轻松负担起它的付费版了。顺便说一句Parse应该是被Facebook收了。所以，应该对他们充满信心。</p>
<h3 id="avoscloud">avoscloud</h3>
<p>推荐<a href="https://cn.avoscloud.com" target="_blank">avoscloud</a>的理由很简单。这是好基友Summer参与开发的。 作为好基友肯定要鼎力推荐一下。 AVOS看起来是国际高端大气上档次的大厂。但是这个cloud，应该是完全由在天朝的团队开发的(个人猜想). 为什么要推荐？起码人家的文档是中文的，阅读起来没障碍。 有问题了，还可以直接去weibo吐槽也不当心人家看不懂好吧。</p>
<h3 id="helios">helios</h3>
<p>当然如果你喜欢自己搞定一切。那你还是可以自己搭建自己的服务器的。如果你需要一个类似的参考<a href="http://helios.io" target="_blank">Mattt大神的helios</a>你不应该错过。如果你写iOS or Mac OS X开发超过三月，还不知道Mattt大神。那你应该恶补一下圈子里面的知识了。Mattt大神就是主导AFNetworking的那个啊。 不说围绕着AFNetworking衍生出来的庞大类库。 当一个<a href="http://nshipster.com" target="_blank">NSHipster</a>就造福一方啊。</p>
<h2 id="总结_&amp;&amp;_瞎扯蛋">总结 &amp;&amp; 瞎扯蛋</h2>
<p>好久好久没有更新Blog。鄙视一下自己懒的不成样子了。其实好几次想写点扯淡的东西。但是总觉得技术Blog就应该有个技术Blog的样子。不要总是在扯淡。扯着扯着就变成IT评论家的感觉。今天黑这个，明天黑那个的。不好，应该自己踏踏实实的静心学习。最近就是因为心太乱了，导致各种问题。不过期待能把这个iCloud的系列坑给填好。也能算给自己学习了一年iCloud的使用做出一个总结不至于白弄了一年。</p>
<p>最后嫌弃我写的太慢的同学。那就给一个入口地址：从<a href="http://developer.apple.com/library/Mac/documentation/General/Conceptual/iCloudDesignGuide/Chapters/Introduction.html#//apple_ref/doc/uid/TP40012094-CH1-SW1" target="_blank">这里</a>加油把</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(24) 关于使用xCode的Tab来提高开发效率]]></title>
    <link href="http://iiiyu.com/2013/06/03/learning-ios-notes-twenty-fort/"/>
    <id>http://iiiyu.com/2013/06/03/learning-ios-notes-twenty-fort/</id>
    <published>2013-06-03T08:32:08.000Z</published>
    <updated>2014-02-17T04:20:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>通过Google分析来看blog的访问统计。发现评价阅读时间也就一分钟不到。但是之前都习惯性写长篇大论。这次换一种方式来写blog。尽量写短一些的小一些的题目。使得更新数量上去。</p>
<p>这次我来说说怎么设置Tab来提高在xCode的工作效率。</p>
<h1 id="我是如何使用Tab来提高效率的">我是如何使用Tab来提高效率的</h1>
<h2 id="xCode的Tab是什么">xCode的Tab是什么</h2>
<p>诺，就是这一个东西。 </p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e5b26nmyqij20oq00v0sp.jpg" alt=""></p>
<p>使用过各种浏览器的你一定不会陌生。对在xCode里面我们也可以开出多个页面。而且每一个页面的状态是单独保存的。</p>
<a id="more"></a>

<h2 id="如何提高效率">如何提高效率</h2>
<p>因为在实际的代码编写过程中，我们可能需要来回的查找和阅读代码。会很自然的在多个文件中跳转编辑。这时候单个编辑页面明显拖累了速度。所以我们需要多个页面来回切换就会很爽。</p>
<p>如上图所示。我习惯性长开着这几个Tab。</p>
<h2 id="UI">UI</h2>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e5b1quy5pij207409wt99.jpg" alt=""></p>
<p>如图所示，我们可以在圈起来的地方设置关键词过滤显示的文件<br>这样我的名为UI的Tab就只会显示storyboard。这样改UI点击起来会很方便</p>
<h2 id="Data">Data</h2>
<p>同理可得这个表情用来显示data model的。</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e5b1uqa7yhj207w094mxd.jpg" alt=""></p>
<h2 id="VC">VC</h2>
<p>显示ViewController的</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e5b1v4lkuyj207x0933z6.jpg" alt=""></p>
<h2 id="Debug">Debug</h2>
<p>Debug这个Tab有些特殊。并不是我手动创建的。而且我配置了编译行为出来的。<br>这样每次Run的时候都会跳到这个名为Debug的Tab里面。这样做的原因是，我改了一个地方的代码。运行以后可能在其他地方挂掉了（或者在其他地方打了断点）。然后跟着进去看了看。然后想回到之前改代码的地方就会很麻烦。</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e5b1ws3qu9j20ku0f8mzu.jpg" alt=""></p>
<p>这样设置了以后，就没有上述烦恼了。</p>
<h1 id="顺便说一句">顺便说一句</h1>
<p>希望这些对你有所帮助。</p>
<p>顺便说一句：Tab直接的切换可以使用快捷键 Command + Shift + ([, ]) 其实这个快捷键适用于绝大部分有Tab的App。 都可以完成切换功能</p>
<p>再顺便说一句： xCode本身内存消耗很大，开Tab。感觉很是消耗内存。如果内存吃紧的话。应该去升级内存了。不然开多个Tab只会降低工作效率并不会提高。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(23) iOS进行单元测试OCUnit+xctool]]></title>
    <link href="http://iiiyu.com/2013/05/23/learning-ios-notes-twenty-three/"/>
    <id>http://iiiyu.com/2013/05/23/learning-ios-notes-twenty-three/</id>
    <published>2013-05-23T06:51:31.000Z</published>
    <updated>2014-02-17T04:20:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="iOS进行单元测试OCUnit+xctool">iOS进行单元测试OCUnit+xctool</h1>
<h2 id="单元测试">单元测试</h2>
<h3 id="什么是单元测试">什么是单元测试</h3>
<p><a href="http://zh.wikipedia.org/wiki/单元测试" target="_blank">wiki解释</a></p>
<p>简单说来就是为你的方法多专门写一个测试函数。以保证你的方法在不停的修改开发中。保持正确。如果出错，第一时间让你知道，这样从最小单位开始监控来保证软件的质量。</p>
<h3 id="我为什么要单元测试">我为什么要单元测试</h3>
<p>其实要开始写单元测试的原因是，由于我的原因格志的存储逻辑一直有问题。 一个是代码写的比较搓，一个是修改存储的逻辑的话。影响面比较大。可能修复了一个bug而引入了未知的多个bug。为了Sumi早日达到国际化大厂的标准。决定上单元测试于格志。其实最根本的目的还是想要项目变的更加可靠。</p>
<h3 id="单元测试的一般方法">单元测试的一般方法</h3>
<p>关于测试的书，一搜就一大把。都有高深的理论和方法来指导怎么写单元测试的方法。我觉得嘛不用搞了这么复杂。 无非就3种时候会去想写测试：</p>
<ol>
<li>代码完成以后</li>
<li>开始写代码之前</li>
<li>修复了一个bug以后</li>
</ol>
<p>第一种是完成了代码，恩我要测试一下我写的这些方法可靠不可靠。那这时候可以写测试。</p>
<p>第二种一个著名的方法论TDD。主要思想就是在写代码之前，就全部设计好借口。函数名字什么的。然后在写能通过测试的函数。</p>
<p>第三种就是发现了bug，我修复了这个bug。为了确保修复是成功的。那就写个测试吧。</p>
<p>我觉得啊，着三种都没有什么好或差。能写测试的少年都是好少年。何必这么在意什么时候去写呢。</p>
<p>一个完整的测试类组成像下图</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e58jl2toiej20fh0a1aam.jpg" alt=""></p>
<p>在一开始可能测试方法里面需要一些上下文环境。这些可以在Setup里面去完成。然后才可是执行自己写的测试方法。 然后测试结束以后，可能产生了一些垃圾数据文件什么的。这时候你可以在TearDown方法里面把他们处理掉。</p>
<p>以上大部分都是我自己的粗浅理解，如果你需要更多关于单元测试请阅读更加系统专业的书籍。</p>
<a id="more"></a>


<h2 id="OCUnit">OCUnit</h2>
<p>OCUnit是xCode里面自己带的单元测试框架。不必安装第三方的其他库就可以使用。最简单的就是创建项目的时候你把单元测试的那个勾点上。xCode就会自动的为你加入一个单元测试的target。快捷键Command + U。就可以运行测试。最喜欢这样方便又好用的东西了。当然运行OCUnit的测试输出的内容实在惨不忍睹。</p>
<h3 id="创建一个OCUnit的Unit_Test">创建一个OCUnit的Unit Test</h3>
<h4 id="新项目使用OCUnit">新项目使用OCUnit</h4>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58kyt9nyhj20k80dnabp.jpg" alt=""></p>
<p>选上Unit Test</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58kzfmxkij20ei0c93zt.jpg" alt=""></p>
<p>会自动的建立一个Target</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58l0l72wvj20uf0b4q51.jpg" alt=""></p>
<p>自动的为你添加好需要的类库</p>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e58l164wjkj20al0d7dh0.jpg" alt=""></p>
<p>为你添加一个Unit Test的类</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e58l1uogchj20an03cq39.jpg" alt=""></p>
<p>看一眼Scheme 只有一个。</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58l315fwmj20jg0d70ua.jpg" alt=""></p>
<p>看看Scheme里面是怎么写的。</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58l4n4ozrj209c04vdg1.jpg" alt=""></p>
<p>用Command + U运行一下测试看看结果。这是没有通过的。因为自动生成的模板就是不通过的。具体一会儿分析代码。</p>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e58l6bue5gj20zc070mze.jpg" alt=""></p>
<p>看看终端的输出。渣一般的难看。根本无法高识别度的分清。</p>
<h4 id="已经存在的项目使用OCUnit">已经存在的项目使用OCUnit</h4>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58t46ki0fj20770cgdgd.jpg" alt=""></p>
<p>这是一个一开始没有选择过Unit Test的项目</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58t52kpxhj20ce0jg0tn.jpg" alt=""></p>
<p>点击增加Target</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e58t5vnb0bj20k80dndhf.jpg" alt=""></p>
<p>选择Unit testing Bundle</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58t6jsonij20k80dnmys.jpg" alt=""></p>
<p>为我们的测试bundle取一个名字</p>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e58t75sbt3j20bq03h3yu.jpg" alt=""></p>
<p>我们可以看到Scehme多出来了一个。这时候如果选择的是App的Scehme。Command + U。是没有运行测试的。要选择我们新建立的Test Scehme。再按Command + U.就运行了测试了。</p>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e58t96mpj1j20jg0d775q.jpg" alt=""></p>
<p>如何为App的Scehme添加Test。使得不用切换Scehme，就可以运行Unit Test。</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58thyodnkj20b40cswet.jpg" alt=""></p>
<p>然后选择你建立的Unit Test bundle。 打完收工。</p>
<h3 id="OCUnit使用的宏">OCUnit使用的宏</h3>
<p>STAssertEqualObjects(a1, a2, description, …)</p>
<p>STAssertEquals(a1, a2, description, …)</p>
<p>STAssertEqualsWithAccuracy(a1, a2, accuracy,description, …)</p>
<p>STFail(description, …)</p>
<p>STAssertNil(a1, description, …)</p>
<p>STAssertNotNil(a1, description, …)</p>
<p>STAssertTrue(expr, description, …)</p>
<p>STAssertTrueNoThrow(expr, description, …)</p>
<p>STAssertFalse(expr, description, …)</p>
<p>STAssertFalseNoThrow(expr, description, …)</p>
<p>STAssertThrows(expr, description, …)</p>
<p>STAssertThrowsSpecific(expr, specificException, description, …)</p>
<p>STAssertThrowsSpecificNamed(expr, specificException, aName, description, …)</p>
<p>STAssertNoThrow(expr, description, …)</p>
<p>STAssertNoThrowSpecific(expr, specificException, description, …)</p>
<p>STAssertNoThrowSpecificNamed(expr, specificException, aName, description, …)</p>
<h3 id="比较经常使用的宏">比较经常使用的宏</h3>
<p>STAssertTrue(expr, description, …)<br>STAssertFalse(expr, description, …)<br>STAssertNil(a1, description, …)<br>STAssertNotNil(a1, description, …)<br>STAssertEqualObjects(a1, a2, description, …)<br>STAssertEquals(a1, a2, description, …)<br>STFail(description, …)<br>STAssertThrows(expr, description, …)</p>
<h3 id="写了几个测试方法的例子">写了几个测试方法的例子</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)testOne {
	<span class="built_in">NSString</span> *string1 = @<span class="string">"test"</span>;
	<span class="built_in">NSString</span> *string2 = @<span class="string">"test"</span>;
	STAssertThrows([string1 isEqualToString:string2], @<span class="string">"FAILURE"</span>);
}

- (<span class="keyword">void</span>)testTwo
{
    <span class="keyword">int</span> i = <span class="number">0</span>;
    <span class="keyword">int</span> j = <span class="number">1</span>;
    STAssertTrue(i &lt; j, @<span class="string">" i: %d, j: %d"</span>, i,j);
}

- (<span class="keyword">void</span>)testThree
{
    
    <span class="built_in">NSString</span> *oneStr = @<span class="string">"hello"</span>;
    <span class="built_in">NSString</span> *twoStr = @<span class="string">"world"</span>;
    STAssertFalse([oneStr isEqualToString:twoStr], @<span class="string">"oneStr:%@, twoStr:%@"</span>, oneStr, twoStr);
}

- (<span class="keyword">void</span>)testFour
{
    <span class="built_in">NSArray</span> *array = <span class="literal">nil</span>;
    STAssertNil(array, @<span class="string">"array:%@"</span>, array);
}


- (<span class="keyword">void</span>)testFive
{
    <span class="built_in">NSDictionary</span> *dict = @{@<span class="string">"hello"</span>: @<span class="string">"word"</span>};
    STAssertNotNil(dict, @<span class="string">"dict:%@"</span>, dict);
}

- (<span class="keyword">void</span>)testSix
{
    <span class="built_in">NSNumber</span> *oneNum = @<span class="number">100</span>;
    <span class="built_in">NSNumber</span> *twoNum = @<span class="number">200</span>;
    STAssertEqualObjects(oneNum, twoNum, @<span class="string">"oneNum:%@ twoNum:%@"</span>,oneNum, twoNum);
}

- (<span class="keyword">void</span>)testSeven
{
    <span class="built_in">NSArray</span> *oneArray = @[@<span class="number">11</span>, @<span class="number">22</span>, @<span class="number">33</span>];
    <span class="built_in">NSArray</span> *twoArray = [oneArray copy];
    STAssertEqualObjects(oneArray, twoArray, @<span class="string">"oneArray:%@, twoArray:%@"</span>, oneArray, twoArray);
}


- (<span class="keyword">void</span>)testEight
{
    NSUInteger uint_1 = <span class="number">4</span>;
	NSUInteger uint_2 = <span class="number">4</span>;
	STAssertEquals(uint_1, uint_2, @<span class="string">"FAILURE"</span>);
}
    
    
- (<span class="keyword">void</span>)testExample
{
    STFail(@<span class="string">"Unit tests are not implemented yet in HelloAfterAddOCUnitUnitTest"</span>);
}
</pre></td></tr></table></figure>

<p>一会儿用xctool跑个华丽丽的出来看。</p>
<h2 id="xctool">xctool</h2>
<h3 id="xctool是什么">xctool是什么</h3>
<p>xctool是Facebook开源的一个命令行工具，用来替代苹果的xcodebuild工具。</p>
<p><a href="https://github.com/facebook/xctool" target="_blank">github</a></p>
<p>官方演示</p>
<p><img src="https://fpotter_public.s3.amazonaws.com/xctool-uicatalog.gif" alt=""></p>
<p>你可以用它来Build你的App。跑Tests。而且它跑Test输出是华丽丽的彩色。比xCode自带的不知好看多少倍。OCUnit本来被吐槽无数，遇上了xctool以后就逆袭了啊。</p>
<p>世界上最最牛的SNS出品，肯定不会坑爹啊。</p>
<h3 id="安装xctool">安装xctool</h3>
<p>最方便 最推荐的是用Homebrew。如果你的Mac里面没有安装Homebrew我觉得是你的损失。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>brew <span class="operator"><span class="keyword">update</span>
brew install xctool</span>
</pre></td></tr></table></figure>

<h3 id="使用xctool来跑OCUnit测试">使用xctool来跑OCUnit测试</h3>
<p>关于如何使用xctool，你去看官方文档肯定要比我结束好的多。 我就是过来跑测试的例子给你看而已。</p>
<h4 id="测试一">测试一</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>xctool <span class="attribute">-project</span> HelloOCUnit<span class="built_in">.</span>xcodeproj <span class="attribute">-scheme</span> HelloOCUnit  test
</pre></td></tr></table></figure>

<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58zjmagi8j20eh0li0wx.jpg" alt=""></p>
<h4 id="测试二">测试二</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>xctool <span class="attribute">-project</span> HelloAfterAddOCUnit<span class="built_in">.</span>xcodeproj <span class="attribute">-scheme</span> HelloAfterAddOCUnit  test

xctool <span class="attribute">-project</span> HelloAfterAddOCUnit<span class="built_in">.</span>xcodeproj <span class="attribute">-scheme</span> HelloAfterAddOCUnitUnitTest  test
</pre></td></tr></table></figure>

<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58zk5dk34j20h70li43i.jpg" alt=""></p>
<p><a href="http://d.pr/f/EUCR" target="_blank">项目一下载</a></p>
<p><a href="http://d.pr/f/LPaY" target="_blank">项目二下载</a></p>
<h2 id="总结">总结</h2>
<p>以上就是OCUnit的使用建议。建议OCunit+xctool。来进行你的单元测试构建。更多信息请阅读相关资料。我这里只是写了入门而已。接下来的测试之路就靠你了。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(22) CoreData (四) 监听NSFetchedResultsController]]></title>
    <link href="http://iiiyu.com/2013/04/29/learning-ios-notes-twenty-two/"/>
    <id>http://iiiyu.com/2013/04/29/learning-ios-notes-twenty-two/</id>
    <published>2013-04-29T04:03:11.000Z</published>
    <updated>2014-02-17T04:20:13.000Z</updated>
    <content type="html"><![CDATA[<h1 id="CoreData_(四)">CoreData (四)</h1>
<h2 id="监听NSFetchedResultsController">监听NSFetchedResultsController</h2>
<p>之前说过, NSFetchedResultsController是有两个重要的功能。</p>
<p>第一:NSFetchedResultsController是作用在Core Data上的,通过NSFetchRequest来查询Core Data里面的数据.可以返回按照组分好的数据.这样便于UITableView来显示.</p>
<p>第二:但Model改变的时候NSFetchedResultsController能及时的发出通知.准确的说,应该是当NSManagedObjectContext发生改变的时候,NSFetchedResultsController能知道这些变化,然后发出通知出来.以便UITableview能及时的更新.</p>
<p>上一篇写了第一点. 现在写第二点.</p>
<a id="more"></a>

<h2 id="背景">背景</h2>
<p>如果在数据改变了的时候,我们用UITableView reload. 整个UITableView的数据确实能保持最新的情况. 但是问题是这样做的效率很低. 更希望的情况是,我哪一条数据增加,修改,删除. 就对应着UITableView里面的那一条数据在UI上增加,修改,删除.这样效率会有很大的提升. </p>
<h2 id="直接操作">直接操作</h2>
<p>首先是用Delegate来进行UITableView的改变.</p>
<p>第一个方法,告诉UITableView数据要开始更新了,你UITableView赶紧准备好更新.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)controllerWillChangeContent:(<span class="built_in">NSFetchedResultsController</span> *)controller
{
    [[<span class="keyword">self</span> tableView] beginUpdates];
}
</pre></td></tr></table></figure>

<p>当然有开始就有结束,下面的方法就是告诉UITableView结束更新.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)controllerDidChangeContent:(<span class="built_in">NSFetchedResultsController</span> *)controller
{
    [[<span class="keyword">self</span> tableView] endUpdates];
}
</pre></td></tr></table></figure>

<p>这两个方法一看命名规则就能看出来是一个Delegate.在NSFetchedResultsController将要变换的时候,我们开启UITableView的编辑,然后在NSFetchedResultsController已经改变结束的时候结束UITableView的编辑.思维上自然而然,有始有终.</p>
<p>接下来我们要在begin和end之间对tableview做出改变.</p>
<p>改变section的方法.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)controller:(<span class="built_in">NSFetchedResultsController</span> *)controller
  didChangeSection:(<span class="keyword">id</span> &lt;NSFetchedResultsSectionInfo&gt;)sectionInfo
           atIndex:(NSUInteger)sectionIndex
     forChangeType:(<span class="built_in">NSFetchedResultsChangeType</span>)type
{
    NSIndexSet *indexSet = [NSIndexSet indexSetWithIndex:sectionIndex];
    <span class="keyword">switch</span>(type) {
        <span class="keyword">case</span> NSFetchedResultsChangeInsert:
        {
            [[<span class="keyword">self</span> tableView] insertSections:indexSet
                            withRowAnimation:UITableViewRowAnimationFade];
            <span class="keyword">break</span>;
        }
        <span class="keyword">case</span> NSFetchedResultsChangeDelete:
        {
            [[<span class="keyword">self</span> tableView] deleteSections:indexSet
                            withRowAnimation:UITableViewRowAnimationFade];
            <span class="keyword">break</span>;
            
        }
    }
}
</pre></td></tr></table></figure>

<p>这个方法是在section改变的时候调用.改变类型支持两种NSFetchedResultsChangeInsert和NSFetchedResultsChangeDelete..这样我们能操作UITableView里面section变化了.</p>
<p>接下来的方法是改变cell内容的.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)controller:(<span class="built_in">NSFetchedResultsController</span> *)controller didChangeObject:(<span class="keyword">id</span>)anObject
       atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
     forChangeType:(<span class="built_in">NSFetchedResultsChangeType</span>)type
      newIndexPath:(<span class="built_in">NSIndexPath</span> *)newIndexPath
{
    <span class="built_in">NSArray</span> *newArray = [<span class="built_in">NSArray</span> arrayWithObject:newIndexPath]; <span class="built_in">NSArray</span> *oldArray = [<span class="built_in">NSArray</span> arrayWithObject:indexPath]; <span class="keyword">switch</span>(type) {
        <span class="keyword">case</span> NSFetchedResultsChangeInsert:
            [[<span class="keyword">self</span> tableView] insertRowsAtIndexPaths:newArray
                                    withRowAnimation:UITableViewRowAnimationFade];
            <span class="keyword">break</span>;
        <span class="keyword">case</span> NSFetchedResultsChangeDelete:
            [[<span class="keyword">self</span> tableView] deleteRowsAtIndexPaths:oldArray
                                    withRowAnimation:UITableViewRowAnimationFade];
            <span class="keyword">break</span>;
        <span class="keyword">case</span> NSFetchedResultsChangeUpdate: {
            <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>;
            NSManagedObject *object = <span class="literal">nil</span>;
            cell = [[<span class="keyword">self</span> tableView] cellForRowAtIndexPath:indexPath];
            object = [[<span class="keyword">self</span> fetchedResultsController] objectAtIndexPath:indexPath]; [[cell textLabel] setText:[object valueForKey:@<span class="string">"name"</span>]];
            <span class="keyword">break</span>;
        }
        <span class="keyword">case</span> NSFetchedResultsChangeMove:
            
            [[<span class="keyword">self</span> tableView] deleteRowsAtIndexPaths:oldArray
                                    withRowAnimation:UITableViewRowAnimationFade];
            [[<span class="keyword">self</span> tableView] insertRowsAtIndexPaths:newArray
                                    withRowAnimation:UITableViewRowAnimationFade];
        <span class="keyword">break</span>; }
}
</pre></td></tr></table></figure>

<p>在这个方法里面我们可以增删改Cell的.并且可以有动画.</p>
<h2 id="NSFetchedResultsController的原理">NSFetchedResultsController的原理</h2>
<p>上面我们已经可以无痛的使用NSFetchedResultsController了。而且各种数据都可以自动更新，但是它是一个什么原理呢？</p>
<p>NSFetchedResultsController的核心其实是作为一个观察者去监听NSManagedObjectContext的通知。当NSManagedObjectContext发生改变的时候NSFetchedResultsController就知道了变化。所以，我们初始化一个NSFetchedResultsController的时候，也就监听了对应的NSManagedObjectContext的通知。具体的是三个通知。</p>
<p><em>NSManagedObjectContextObjectsDidChangeNotification</em></p>
<p><em>NSManagedObjectContextWillSaveNotification</em></p>
<p><em>NSManagedObjectContextDidSaveNotification</em></p>
<p>其实看名字都可以猜测一些他们的具体发出通知的时机。</p>
<h4 id="NSManagedObjectContextObjectsDidChangeNotification">NSManagedObjectContextObjectsDidChangeNotification</h4>
<p>当任何一个Object中的任何属性有改变的时候，会发出此通知。然后NSFetchedResultsController会去用设置好的NSFetchRequest查处结果进行参数传递。当这些改变发送的时候，我们就只用在 -controller: didChangeObject: atIndexPath: forChangeType: newIndexPath:判断改变类型是 NSFetchedResultsChangeUpdate或者 NSFetchedResultsChangeMove就可以做相应的数据到UI的变更操作了。</p>
<h4 id="NSManagedObjectContextWillSaveNotification">NSManagedObjectContextWillSaveNotification</h4>
<p>这个通知是在删除Object的情况下。 这时候可能删除的是section。用-controller: didChangeSection: atIndex: forChangeType:。 如果只是一个Object的删除。就用-controller: didChangeObject: atIndexPath: forChangeType: newIndexPath:。 类型都是NSFetchedResultsChangeDelete.</p>
<h4 id="NSManagedObjectContextDidSaveNotification">NSManagedObjectContextDidSaveNotification</h4>
<p>这个通知对应的delegate方法就是-controller: didChangeSection: atIndex: forChangeType: 和 -controller: didChangeObject: atIndexPath: forChangeType: newIndexPath:。 </p>
<p>了解了NSFetchedResultsController的原理。事实上自己就可以写NSFetchedResultsController了。</p>
<p>事实上，这篇blog写的确实很糟糕。 而且看日期已经写了20多天了。这样的拖沓让我很不开心。 所以我决定快速的结束这篇blog。 以后就算写的糟糕也不应该拖沓的。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(21) CoreData (三) NSFetchedResultsController]]></title>
    <link href="http://iiiyu.com/2013/04/17/learning-ios-notes-twenty-one/"/>
    <id>http://iiiyu.com/2013/04/17/learning-ios-notes-twenty-one/</id>
    <published>2013-04-17T07:06:24.000Z</published>
    <updated>2014-02-17T04:20:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="CoreData_(三)">CoreData (三)</h1>
<h2 id="NSFetchedResultsController">NSFetchedResultsController</h2>
<h3 id="什么是NSFetchedResultsController">什么是NSFetchedResultsController</h3>
<p>NSFetchedResultsController是一个让人爱恨交加的一个类。如果使用得当，NSFetchedResultsController能帮组减少很多代码。如果使用不当，整个App就随时崩溃。</p>
<p>NSFetchedResultsController我觉得最初的设计应该是为了配合UITableView来使用的。因为UITableView在iOS的应用App中出场次数实在是太高了.而且UITableView是重要的数据展示View,所以需要频繁的向Model去请求数据,但是根据MVC来说,V不应该直接跟M联系的.这样就在Core Data下面出现了一个C—NSFetchedResultsController来把V和M协调起来. NSFetchedResultsController就是这个C. </p>
<p>NSFetchedResultsController是有两个重要的功能。</p>
<p>第一:NSFetchedResultsController是作用在Core Data上的,通过NSFetchRequest来查询Core Data里面的数据.可以返回按照组分好的数据.这样便于UITableView来显示.</p>
<p>第二:但Modle改变的时候NSFetchedResultsController能及时的发出通知.准确的说,应该是当NSManagedObjectContext发生改变的时候,NSFetchedResultsController能知道这些变化,然后发出通知出来.以便UITableview能及时的更新.</p>
<a id="more"></a>


<h2 id="实现一个NSFetchedResultsController作为Data_source的UITableView">实现一个NSFetchedResultsController作为Data source的UITableView</h2>
<h3 id="创建一个最小带Core_Data的工程">创建一个最小带Core Data的工程</h3>
<p><img src="http://ww3.sinaimg.cn/large/a74ecc4cjw1e3tlc32lbhj20k80dndhr.jpg" alt=""></p>
<p>选择Master-Detail Application</p>
<p><img src="http://ww4.sinaimg.cn/large/a74eed94jw1e3tle5fxqnj20k80dn0uf.jpg" alt=""></p>
<p>整理一下显示层级和结构使其看起来顺眼一些</p>
<p><img src="http://ww2.sinaimg.cn/large/a74e55b4jw1e3tlnesq81j20750dut9e.jpg" alt=""></p>
<h3 id="确立目标">确立目标</h3>
<p>打开看以后 发现建立的工程是已经使用了NSFetchedResultsController<br>我们的目标是改写这个项目支持UITableView分组显示</p>
<h4 id="首先修改Data_Model">首先修改Data Model</h4>
<p>增加一个字段用来分组. 我们增加一个同样的Date用来记录此时的分钟数量.</p>
<p><img src="http://ww4.sinaimg.cn/large/bfadf3bejw1e3tn8pouqgj.jpg" alt=""></p>
<h3 id="初始化一个NSFetchedResultsController">初始化一个NSFetchedResultsController</h3>
<p>这里假设你看过我的Core Data笔记1,2.默认你已经做好了Core Data stack的全部工作.然后再开始NSFetchedResultsController的初始化.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre>- (<span class="built_in">NSFetchedResultsController</span> *)fetchedResultsController
{
    <span class="keyword">if</span> (_fetchedResultsController != <span class="literal">nil</span>) {
        <span class="keyword">return</span> _fetchedResultsController;
    }

    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
    <span class="comment">// Edit the entity name as appropriate.</span>
    NSEntityDescription *entity = [NSEntityDescription entityForName:@<span class="string">"Event"</span> inManagedObjectContext:<span class="keyword">self</span><span class="variable">.managedObjectContext</span>];
    [fetchRequest setEntity:entity];

    <span class="comment">// Set the batch size to a suitable number.</span>
    [fetchRequest setFetchBatchSize:<span class="number">20</span>];

    <span class="comment">// Edit the sort key as appropriate.</span>
    NSSortDescriptor    *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@<span class="string">"timeStamp"</span> ascending:<span class="literal">NO</span>];
    <span class="built_in">NSArray</span>             *sortDescriptors = @[sortDescriptor];

    [fetchRequest setSortDescriptors:sortDescriptors];

    <span class="comment">// Edit the section name key path and cache name if appropriate.</span>
    <span class="comment">// nil for section name key path means "no sections".</span>
    <span class="built_in">NSFetchedResultsController</span> *aFetchedResultsController = [[<span class="built_in">NSFetchedResultsController</span> alloc] initWithFetchRequest:fetchRequest managedObjectContext:<span class="keyword">self</span><span class="variable">.managedObjectContext</span> sectionNameKeyPath:@<span class="string">"sectionMinute"</span> cacheName:@<span class="string">"Master"</span>];
    aFetchedResultsController<span class="variable">.delegate</span> = <span class="keyword">self</span>;
    <span class="keyword">self</span><span class="variable">.fetchedResultsController</span> = aFetchedResultsController;

    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;

    <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> performFetch:&error]) {
        <span class="comment">// Replace this implementation with code to handle the error appropriately.</span>
        <span class="comment">// abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.</span>
        <span class="built_in">NSLog</span>(@<span class="string">"Unresolved error %@, %@"</span>, error, [error userInfo]);
        abort();
    }

    <span class="keyword">return</span> _fetchedResultsController;
}
</pre></td></tr></table></figure>

<p>这里是工程里面的NSFetchedResultsController的set方法.可以看出,第一我们创建一个NSFetchRequest查询.然后在用这个NSFetchRequest去创建一个NSFetchedResultsController.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">NSFetchedResultsController</span> *aFetchedResultsController = [[<span class="built_in">NSFetchedResultsController</span> alloc] initWithFetchRequest:fetchRequest managedObjectContext:<span class="keyword">self</span><span class="variable">.managedObjectContext</span> sectionNameKeyPath:@<span class="string">"sectionMinute"</span> cacheName:@<span class="string">"Master"</span>];
</pre></td></tr></table></figure>

<p>第一个参数就是NSFetchRequest.</p>
<p>第二个参数是要指定在哪个context里面进行查询</p>
<p>第三个参数是根据什么key来分组.sectionNameKeyPath本来是nil是不分组,我改为我们需要分组的key值”sectionMinute”.</p>
<p>第四个参数  <a href="http://developer.apple.com/library/ios/#documentation/CoreData/Reference/NSFetchedResultsController_Class/Reference/Reference.html" target="_blank">官方解释是这里</a>点到The Cache的地方. 我的理解是cache只保留很少的一部分数据在磁盘上面,如果使用了Cache,在重建UITableView的时候, 就优先查询cache里面的数据.然后要在-performFetch:执行的时候才会去刷新新的数据.这样有助于UITableView的流畅性.</p>
<p>然后我加入Sections的方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>- (<span class="built_in">NSString</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView titleForHeaderInSection:(<span class="built_in">NSInteger</span>)section
{
    <span class="built_in">NSArray</span> *sections = [[<span class="keyword">self</span> fetchedResultsController] sections]; <span class="keyword">id</span> &lt;NSFetchedResultsSectionInfo&gt; sectionInfo = <span class="literal">nil</span>;
    sectionInfo = [sections objectAtIndex:section];
    
    <span class="keyword">return</span> [sectionInfo name];
}
</pre></td></tr></table></figure>

<p>接着我添加</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="label">https:</span>//github<span class="preprocessor">.com</span>/erica/NSDate-Extensions<span class="preprocessor">.git</span>
</pre></td></tr></table></figure>

<p>这个NSDate库进来.自己按照他的写法,写一个能获得当前时间秒数为0的方法.用来分组.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>- (<span class="built_in">NSDate</span> *) dateAtStartOfMinutes
{
    NSDateComponents *components = [CURRENT_CALENDAR components:DATE_COMPONENTS fromDate:<span class="keyword">self</span>];
	[components setSecond:<span class="number">0</span>];
	<span class="keyword">return</span> [CURRENT_CALENDAR dateFromComponents:components];
}
</pre></td></tr></table></figure>

<p>然后改写insert方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)insertNewObject:(<span class="keyword">id</span>)sender
{
    NSManagedObjectContext *context = [<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> managedObjectContext];
    NSEntityDescription *entity = [[<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> fetchRequest] entity];
    NSManagedObject *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context];
    
    <span class="comment">// If appropriate, configure the new managed object.</span>
    <span class="comment">// Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.</span>
    [newManagedObject setValue:[<span class="built_in">NSDate</span> date] forKey:@<span class="string">"timeStamp"</span>];
    [newManagedObject setValue:[[<span class="built_in">NSDate</span> date] dateAtStartOfMinutes]  forKey:@<span class="string">"sectionMinute"</span>];
    
    <span class="comment">// Save the context.</span>
    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
    <span class="keyword">if</span> (![context save:&error]) {
         <span class="comment">// Replace this implementation with code to handle the error appropriately.</span>
         <span class="comment">// abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. </span>
        <span class="built_in">NSLog</span>(@<span class="string">"Unresolved error %@, %@"</span>, error, [error userInfo]);
        abort();
    }
}
</pre></td></tr></table></figure>

<p>其实就是加入了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>[newManagedObject <span class="keyword">set</span>Value:[[NSDate date] dateAtStartOfMinutes]  <span class="keyword">for</span>Key:@<span class="string">"sectionMinute"</span>];
</pre></td></tr></table></figure>

<p>这句.</p>
<p>这样,简单的使用NSFetchedResultsController来显示分组的UITableView就搞定了.<br>当然因为建立的工程模板原因.很大一部分都是xCode搞定的.</p>
<h3 id="被遗忘的地方">被遗忘的地方</h3>
<p>Sections数量,决定了有多少组</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView
{
    <span class="keyword">return</span> [[<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> sections] count];
}
</pre></td></tr></table></figure>

<p>如果在初始化NSFetchedResultsController的时候sectionNameKeyPath为nil.这里应该会返回1.(就算没有数据也会返回1)</p>
<p>Row数量,决定每一组分别有多少行数据.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section
{
    <span class="keyword">id</span> &lt;NSFetchedResultsSectionInfo&gt; sectionInfo = [<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> sections][section];
    <span class="keyword">return</span> [sectionInfo numberOfObjects];
}
</pre></td></tr></table></figure>

<p>我前面说过NSFetchedResultsController就是为了配合UITableView而设计的.所以自然有根据indexPath来取对应的NSManagedObject的方法.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
{
    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:@<span class="string">"Cell"</span> forIndexPath:indexPath];
    [<span class="keyword">self</span> configureCell:cell atIndexPath:indexPath];
    <span class="keyword">return</span> cell;
}

- (<span class="keyword">void</span>)configureCell:(<span class="built_in">UITableViewCell</span> *)cell atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
{
    NSManagedObject *object = [<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> objectAtIndexPath:indexPath];
    cell<span class="variable">.textLabel</span><span class="variable">.text</span> = [[object valueForKey:@<span class="string">"timeStamp"</span>] description];
}
</pre></td></tr></table></figure>

<h3 id="show">show</h3>
<p><img src="http://ww3.sinaimg.cn/large/a74ecc4cjw1e3tydp5hsqj208w0geabq.jpg" alt=""></p>
<h2 id="总结">总结</h2>
<p>写Blog实在是太累了. NSFetchedResultsController努力一天也才一点点.回去继续写. 下次要写NSFetchedResultsController通知方法.</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(20)]]></title>
    <link href="http://iiiyu.com/2013/04/15/learning-ios-notes-twenty/"/>
    <id>http://iiiyu.com/2013/04/15/learning-ios-notes-twenty/</id>
    <published>2013-04-15T06:02:11.000Z</published>
    <updated>2014-02-17T04:20:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="UITableView简单解析">UITableView简单解析</h1>
<h2 id="序">序</h2>
<p>UITableView是在iOS开发中，展示大量内容的首选。我个人认为的原有有一下几点：</p>
<ol>
<li>UITableView的展现形式是为移动设备专门设计过的。有较好的人机交互体验。</li>
<li>从技术角度来说UITableView具有重用和延迟加载等特性。如果使用恰当。可以获得一个App流畅的用户体验。</li>
</ol>
<p>这样，使得UITableView在iOS App中随处可见。</p>
<p>原生应用</p>
<p><img src="http://ww4.sinaimg.cn/large/a74ecc4cjw1e3q5jk1wrtj.jpg" alt=""></p>
<p>一些有名的App.图片信息较老</p>
<p><img src="http://ww4.sinaimg.cn/large/a74eed94jw1e3q5kl91luj.jpg" alt=""></p>
<p>包括游戏</p>
<p><img src="http://ww1.sinaimg.cn/large/a74e55b4jw1e3q5lb59vwj.jpg" alt=""></p>
<p>这些都说明UITableView在一个App中其实是一个很常用的控件。我应该好好的学习它。</p>
<a id="more"></a>


<h2 id="关于数据的思考">关于数据的思考</h2>
<h3 id="没有UITableView的时候我是这样想的">没有UITableView的时候我是这样想的</h3>
<p>首先思考为什么会有UITableView这样的控件。我们做一个App的时候，就会有大量的数据需要显示。比如weibo的每一个状态。比如一个新闻App的很多条新闻。这些数据都会有一个特点就是他们的组织形式一样，只是内容变化。有时候我们可能会根据一些条件进行分组。使得看来了是分组的。例如 联系人里面会按照首字母来进行分组一样。我们还可能会点击数据以便查看更详细的内容。</p>
<p>通过上面的简单描述，如果来自己实现一个类似UITableView的结构。需要得到最核心的：</p>
<ol>
<li>需要得到一共多少条数据</li>
<li>数据的具体内容是什么</li>
</ol>
<p>如果我们数据需要更加仔细的描述展示：</p>
<ol>
<li>全部的数据一共有多少组</li>
<li>每一组有多少个数据</li>
<li>每一条数据的具体内容是什么</li>
</ol>
<h3 id="UITableView是怎么做的">UITableView是怎么做的</h3>
<p>在UITableView中。最重要的就是data source中的两个方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="pp">- <span class="params">(<span class="variable">NSInteger</span>)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView numberOfRowsInSection:<span class="params">(<span class="variable">NSInteger</span>)</span>section;

- <span class="params">(<span class="variable">UITableViewCell</span> *)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView cellForRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>indexPath;</span>
</pre></td></tr></table></figure>

<p>什么是data source。字面意思就是很明白，数据的来源。一般情况下我们会设置拥有UITableView的这个UIViewController为他的data source。因为根据MVC来说。UITableView是View，UIViewController是Controller。View需要的数据，应该是Controller去跟Model协调然后获得，以后由Controller去给View来进行显示。View永远的不去直接跟Model联系。这样当UITableView初始化的时候。他就会去问他的data source。我需要显示多少行数据啊。每一行的数据都是什么内容啊。这时候UIViewController应该已经从Model拿到了数据。然后通过- (NSInteger)tableView:(UITableView <em>)tableView numberOfRowsInSection:(NSInteger)section;告诉UITableview，恩你的这一组要显示n条数据。又用- (UITableViewCell </em>)tableView:(UITableView <em>)tableView cellForRowAtIndexPath:(NSIndexPath </em>)indexPath函数告诉UITableView说，第几组第几条数据的具体内容是什么。</p>
<p>UITableView还有一个比较犀利的地方就是如果你的数据有10000条。它肯定不是把10000条都加载进来。而是只加载需要显示的条目数据。这样设计，使得UITableView的流畅程度大大提高。值得注意的是，如果Cell里面的数据是从网络 or Core Data等其他地方读取的。我们应该把读取动作写成异步的。不阻塞主线程。取到数据以后在回答主线程去刷新UI。</p>
<p>UITableView从创建到显示的调用顺序如下图</p>
<p><img src="http://ww4.sinaimg.cn/large/a74ecc4cjw1e3sfatxy0gj.jpg" alt=""></p>
<ul>
<li>(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView这个函数是最先调用，但是它默认返回1.所以并不是必须的。如果你的UITableView分了好几组，这个就是用来返回组的数量的。</li>
</ul>
<p>这样完成了设置UITableView的data source设置。在完成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="pp">- <span class="params">(<span class="variable">NSInteger</span>)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView numberOfRowsInSection:<span class="params">(<span class="variable">NSInteger</span>)</span>section;

- <span class="params">(<span class="variable">UITableViewCell</span> *)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView cellForRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>indexPath;</span>
</pre></td></tr></table></figure>

<p>这两个函数。我们就可以得到一个能显示的UITableView了。</p>
<p>现在是是仅仅解释了UITableView的数据是怎么来的，然后怎么对应到UITableView上面。</p>
<h2 id="UITableViewCell">UITableViewCell</h2>
<p>UITableViewCell具体的每一条数据展示的具体View。首先在UITableView里面有这样一个特点，每一个Cell的大概样子都长的差不多，只是里面具体的内容稍有变化。这样在UI里面我们应该是重用相同的部分，改变不同的部分。这样才能提高效率。因为在UiTableView这个视图里面，用户习惯性快速的滚动，视图和数据内容都会快速的变化，如果效率问题处理不好，很容易有卡顿的现象。造成用户体验的降低。</p>
<p>如果使用默认的UITableViewCell风格，有以下四种</p>
<p>UITableViewCellStyleDefault</p>
<p><img src="http://ww2.sinaimg.cn/large/a74eed94jw1e3sha1cl2oj.jpg" alt=""></p>
<p>UITableViewCellStyleSubtile</p>
<p><img src="http://ww4.sinaimg.cn/large/a74e55b4jw1e3shcdevpbj.jpg" alt=""></p>
<p>UITableViewCellStyleValue1</p>
<p><img src="http://ww1.sinaimg.cn/large/bfadf3bejw1e3shcssq55j.jpg" alt=""></p>
<p>UITableViewCellStyleValue2</p>
<p><img src="http://ww4.sinaimg.cn/large/a74ecc4cjw1e3shdbgbrgj.jpg" alt=""></p>
<p>当然如果是需要自定义Cell也是很简单。 用xib拖一个，完全可以GUI的方式来创建，很是方便。</p>
<p>(Google一个栗子吧，写不动了)</p>
<p>插一句，Cell的重用是需要下面这样的实现方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
{
    <span class="keyword">static</span> <span class="built_in">NSString</span> *Cell = @<span class="string">"MyCell"</span>;
    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:Cell];
    <span class="keyword">if</span> (!cell) {
        cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:Cell];
    }
    <span class="keyword">return</span> cell;
}
</pre></td></tr></table></figure>

<p>重要的是UITableView的dequeueReusableCellWithIdentifier方法。</p>
<p>dequeueReusableCellWithIdentifier去一个队列里面需找有没有相同ID的的Cell。如果有就提出来重用。可以重用的部分。如果没有就跳进if里面去创建。所以我们在if里面创建的时候，不会改变的内容都可以在里面创建，这样就只用创建一次。需要改变的内容我们就放到if后面去写。 这样我们就能完成高效的UITableView。当然，理论上来说，你可以不用这样的机制，而去直接每次创建一个Cell。不过这是非常浪费资源的一个做法，直接不提倡。</p>
<h2 id="UITableView_Delegate">UITableView Delegate</h2>
<p>当然，在写UITableView肯定想控制的更多。才能完成设计师们辛辛苦苦画出来的稿。这样我们可以去看看Data source里面剩下的函数和Delegate。</p>
<p>当然就说一点</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">//选中Cell响应事件</span>
- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
{
    <span class="comment">//选中后的反显颜色即刻消失</span>
    [tableView deselectRowAtIndexPath:indexPath animated:<span class="literal">YES</span>];
}
</pre></td></tr></table></figure>

<p>这个是选中Cell时候会的出发点。如果要点击以后做什么事情 就在这里做了。 </p>
<p><a href="http://www.devdiv.com/home.php?mod=space&amp;uid=39974&amp;do=blog&amp;id=2573" target="_blank">找了篇目测还ok的中文blog可以先看看了解</a></p>
<h2 id="数据刷新">数据刷新</h2>
<p>如果我们的modle更新了。相应的要体现到UITableView上面。简单的我们可以reload整个TableView。这样做很方便，而且数据上没有问题。唯一的问题就是，reload整个TableView的效率太低了。而且，往往我们只是少数的Cell内容变化。所以没有必要去reload整个TableView。而是那条数据变化去刷新对应的Cell就好了。这样做效率提高很多。</p>
<p>具体涉及到的几个函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="pp">- <span class="params">(void)</span>beginUpdates;
- <span class="params">(void)</span>endUpdates;
 
- <span class="params">(void)</span>insertSections:<span class="params">(<span class="variable">NSIndexSet</span> *)</span>sections withRowAnimation:<span class="params">(<span class="variable">UITableViewRowAnimation</span>)</span>animation;
- <span class="params">(void)</span>deleteSections:<span class="params">(<span class="variable">NSIndexSet</span> *)</span>sections withRowAnimation:<span class="params">(<span class="variable">UITableViewRowAnimation</span>)</span>animation;
- <span class="params">(void)</span>reloadSections:<span class="params">(<span class="variable">NSIndexSet</span> *)</span>sections withRowAnimation:<span class="params">(<span class="variable">UITableViewRowAnimation</span>)</span>animation;
 
- <span class="params">(void)</span>insertRowsAtIndexPaths:<span class="params">(<span class="variable">NSArray</span> *)</span>indexPaths withRowAnimation: <span class="params">(<span class="variable">UITableViewRowAnimation</span>)</span>animation;
- <span class="params">(void)</span>deleteRowsAtIndexPaths:<span class="params">(<span class="variable">NSArray</span> *)</span>indexPaths withRowAnimation: <span class="params">(<span class="variable">UITableViewRowAnimation</span>)</span>animation;
- <span class="params">(void)</span>reloadRowsAtIndexPaths:<span class="params">(<span class="variable">NSArray</span> *)</span>indexPaths withRowAnimation:<span class="params">(<span class="variable">UITableViewRowAnimation</span>)</span>animation;</span>
</pre></td></tr></table></figure>

<p><a href="http://www.cnblogs.com/smileEvday/archive/2012/06/28/tableView.html" target="_blank">这里有实例代码可以参考</a></p>
<p><a href="http://developer.apple.com/library/ios/#documentation/UserExperience/Conceptual/TableView_iPhone/ManageInsertDeleteRow/ManageInsertDeleteRow.html#//apple_ref/doc/uid/TP40007451-CH10-SW1" target="_blank">官方教程</a></p>
<p>里面写了如何优化UITableView：</p>
<p><a href="http://www.keakon.net/2011/08/03/优化UITableView性能" target="_blank">又找了一篇blog写的很不错的样子，优化UITableView性能</a></p>
<h2 id="后记">后记</h2>
<p>总结就是UITableView是一个高度设计的控件。它具有重用，分组，异步加载数据等方面需要我们注意。</p>
<p>其实这里插进来写UITableView是为了写NSFetchedResultsController。因为NSFetchedResultsController就是为UITableview量身打造的Core Data的类。 </p>
<p>所以，先说明以下UITableView，然后再写NSFetchedResultsController。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(19)]]></title>
    <link href="http://iiiyu.com/2013/04/01/learning-ios-notes-nineteen/"/>
    <id>http://iiiyu.com/2013/04/01/learning-ios-notes-nineteen/</id>
    <published>2013-04-01T03:28:20.000Z</published>
    <updated>2014-02-17T04:21:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Core_Data_(二)">Core Data (二)</h1>
<h1 id="序">序</h1>
<p><a href="http://iiiyu.com/2013/03/29/learning-ios-notes-eighteen/">上次</a>只是说了三个Core Data栈基本类。这次准备介绍一下常用的类。</p>
<h2 id="NSManagedObject">NSManagedObject</h2>
<p><img src="http://ww1.sinaimg.cn/large/bfadf3bejw1e39yrt56ifj.jpg" alt=""></p>
<p>Core Data是一次底层数据封装成面向对象的技术。最直接的表现就是在SQLite里面的一条记录在Core Data里面的表现是一个NSManagedObject对象。因此我们的增删改查都是基于操作对象的。恩这里多说一句，NSManagedObject是相对NSManagedObjectContext里面是唯一的。而真实的应用情况可能是NSManagedObjectContext会有多个。而NSManagedObjectContext线程不是安全的，所以可能有你多个NSManagedObjectContext里面各自有指向同一条数据的不同的NSManagedObject。这个情况需要你的程序设计和逻辑上去解决。暂时不讨论。</p>
<a id="more"></a>

<h3 id="使用NSManagedObject所经历的三种方法">使用NSManagedObject所经历的三种方法</h3>
<p>对于NSManagedObject来说一般有以下几种使用方法：</p>
<p>第一种就是我直接使用NSManagedObject来访问我的数据，因为Cocoa特有的KVC机制，使得NSManagedObject可以用KVC的方法去访问属性内容。这样的好处是你不用在NSManagedObject上去写特别的代码，就可以使用。一般入门例子都是这样写的。</p>
<p>第二种是老头视频里面教过的。在点击Data Model选择Entity以后，在xCode的菜单里面有这样一个选项：</p>
<p><img src="http://ww4.sinaimg.cn/large/bfadf3bejw1e39z74y7j8j.jpg" alt=""></p>
<p>next都按完了以后，会生成选择了的Entity对应的一个NSManagedObject子类。这样的话我们就可以用生成的类来进行增删改查。这样的话看起来代码里面也会变得清晰一些。我们也不必去写KVC的方法去访问修改属性。可以直接就访问修改。在我看来还是好处多多的。为了OO的原则，我们可能会对不同的Entity类去写一些只是公开接口的方法。但是这样生成的NSManagedObject子类是不好修改的。因此我们会去建立一个category类。来进行扩写自己的方法。这样项目里面就会出现一票category感觉不是很好的样子。</p>
<p>第三种方法是我现在在使用的方法。<br>就是使用Mogenerator.</p>
<p>Mogenerator已经写过一篇blog了。<a href="http://iiiyu.com/2013/02/22/learning-ios-notes-fifteen/">详细查看Mogenerator的初级使用</a><br>好处是生成一次以后，再次生成并会在工程里面重复引用。而且机制上可以直接在生成的类里面进行方法的扩写。不用使用category类。这样整个工程就看起来高级素雅很多。</p>
<h3 id="NSManagedObject其他注意事项">NSManagedObject其他注意事项</h3>
<p>NSManagedObject就是我们拿来操作数据的基本单位。因此对应，增加一条数据是在NSManagedObjectContext新建一个NSManagedObject。查找数据是查找NSManagedObject。修改是修改NSManagedObject类的属性。删除是从NSManagedObjectContext里面删除NSManagedObject类。最后我们保存NSManagedObjectContext，然后一直向上传递到磁盘上面去。才是持久化的修改。</p>
<h2 id="NSFetchRequest">NSFetchRequest</h2>
<p>NSFetchRequest是一个查询的动作类。我们使用它来在NSManagedObjectContext里面查询相应的NSManagedObject。</p>
<p>一般使用的顺序是先生成NSFetchRequest。指定要查询的NSManagedObjectContext和Entity的名字。然后设置NSPredicate进行过滤。NSSortDescriptor来进行排序。最后用想要查询的NSManagedObjectContext执行NSFetchRequest。就可以得到返回结果了。</p>
<h2 id="NSPredicate">NSPredicate</h2>
<p>NSPredicate的作用不仅仅局限于Core Data里面。其他时候也有用到的地方。而在Core Data里面使用简单的说就是作为一个过滤条件。过滤掉我们不想查找的数据。就相当于SQL语句WHERE后面的那些条件。</p>
<h2 id="NSSortDescriptor">NSSortDescriptor</h2>
<p>查找到的数据是杂乱无章的。而我们往往希望是具有一定顺序的返回结果。NSSortDescriptor就是用来指定排序的属性和方式的。把NSSortDescriptor生成设置好然后给NSFetchRequest设置。这样我们的结果就可以是按照我们希望的顺序返回回来。以便我们操作。</p>
<h2 id="实例代码">实例代码</h2>
<p>新建NSManagedObject</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>NSManagedObject *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] <span class="keyword">in</span>ManagedObjectContext:context];
[newManagedObject <span class="keyword">set</span>Value:[NSDate date] <span class="keyword">for</span>Key:@<span class="string">"timeStamp"</span>];
</pre></td></tr></table></figure>

<p>删除NSManagedObject</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">[context deleteObject:managedObject]</span><span class="comment">;</span>
</pre></td></tr></table></figure>

<p>初始化NSPredicate</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="constant">NSUInteger</span>  numberOfServings = <span class="number">10</span>;
<span class="constant">NSPredicate</span> *predicate = <span class="keyword">nil</span>;
predicate = [<span class="constant">NSPredicate</span> <span class="symbol">predicateWithFormat:</span>@<span class="string">"serves &gt; %i"</span>, numberOfServings];
</pre></td></tr></table></figure>

<p>初始化NSSortDescriptor</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>NSSortDescriptor *sort = [[NSSortDescriptor alloc] initWithKey:<span class="string">@"name"</span> <span class="keyword">ascending</span>:YES];
</pre></td></tr></table></figure>

<p>初始化NSFetchRequest</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>NSManagedObjectContext *moc = [self managedObjectContext]; NSFetchRequest *request = <span class="string">[[NSFetchRequest alloc] init]; [request setEntity:[NSEntityDescription entityForName:@"Recipe"
                                                                                                                                                            inManagedObjectContext:moc]]</span>;
</pre></td></tr></table></figure>

<p>带有NSPredicate的初始化NSFetchRequest</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>NSUInteger              numberOfServings = <span class="number">10</span>;
NSManagedObjectContext  *moc = [self managedObjectContext]; NSFetchRequest *request = <span class="string">[[NSFetchRequest alloc] init]; [request setEntity:[NSEntityDescription    entityForName:@"Recipe"
                                                                                                                                                                inManagedObjectContext:moc]]</span>;
NSPredicate *predicate = <span class="keyword">nil</span>;
predicate = [NSPredicate predicateWithFormat:@<span class="string">"serves &gt; %i"</span>, numberOfServings]; [request setPredicate:predicate];
</pre></td></tr></table></figure>

<p>带有NSSortDescriptor的初始化NSFetchRequest</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>NSFetchRequest *fetchRequest = <span class="keyword">nil</span>;
fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@<span class="string">"Recipe"</span>];
NSSortDescriptor *sort = <span class="string">[[NSSortDescriptor alloc] initWithKey:@"name" ascending:YES];
[fetchRequest setSortDescriptors:[NSArray arrayWithObject:sort]]</span>;
</pre></td></tr></table></figure>

]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(18)]]></title>
    <link href="http://iiiyu.com/2013/03/29/learning-ios-notes-eighteen/"/>
    <id>http://iiiyu.com/2013/03/29/learning-ios-notes-eighteen/</id>
    <published>2013-03-28T16:04:37.000Z</published>
    <updated>2014-02-17T04:21:15.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Core_Data_(一)">Core Data (一)</h1>
<h2 id="序">序</h2>
<p>恩，用Core Data也有一段时间了。大大小小的坑也都坑过了。重来没有认真的记录一次。这次需要好好的理一理Core Data。就当一次绝好的机会记录下来。也为了自己加深认识。</p>
<h2 id="为什么要用Core_Data">为什么要用Core Data</h2>
<p>CoreData的学习是需要一定成本的。以至于我认识的人很少在用，大家要不就是用一个FMDB。或者做的App是一个已有的Web的延伸，数据直接用Web端的Api取回来就好了。</p>
<p>我们要用Core Data的理由有以下几点：</p>
<ol>
<li>Core Data是对底层存储的一次封装。封装了以后就变成ORM的框架。这样就变成操作对象。Core Data自己去进行数据的保存。</li>
<li>使用Core Data而不是FMDB，让整个程序架构更加的面向对象。</li>
<li>Core Data仅仅使用了Objective-C和Core Foundation，你不必去加入一些第三方的库。</li>
<li>Core Data是Apple的原生技术。每年的WWDC都能看到新特性的加入和讲授。</li>
<li>Core Data支持iCloud。而使用iCloud的App。Apple推荐的可能性增加。</li>
<li>有了iCloud为以后Apple的全平台数据共享打下基础</li>
</ol>
<p>所以，没有理由拒绝使用Core Data做为你App的持久化。Core Data应该是一个跟Apple混的第一选择。</p>
<a id="more"></a>


<h2 id="存储原理">存储原理</h2>
<h3 id="NSManagedObjectModel">NSManagedObjectModel</h3>
<h4 id="认识">认识</h4>
<p>我个人是把NSManagedObjectModel看做为一个core data的schema。生成这个类的来源是xCode中的Data Model</p>
<p><img src="http://ww3.sinaimg.cn/large/bfadf3bejw1e36lv4nn89j.jpg" alt=""></p>
<p>点击之后会生成一个.xcdatamodeld的文件夹里面的数据具体是是用xml来存储的。<br>但是你在xCode里面看这个.xcdatamodeld文件夹是认为一个文件。然后可以用xCode来进行图形化的编辑。</p>
<p>如这样</p>
<p><img src="http://ww1.sinaimg.cn/large/bfadf3bejw1e36m76n6k3j.jpg" alt=""></p>
<p>当然还有另外一种表格的方式来编辑Data Model</p>
<p><img src="http://ww3.sinaimg.cn/large/bfadf3bejw1e36mhk7obgj.jpg" alt=""></p>
<p>我们编辑这个的这个文件，理论上来说只是一个资源文件。相当于数据库的schema。我们的数据库长什么样子，就是你来设计的。然后在程序中通过NSURL找到这个资源文件的位置。就可以初始化成为NSManagedObjectModel。</p>
<h4 id="代码加载Data_Model">代码加载Data Model</h4>
<p>当我们设计好我们的Data Model以后。可以用以下代码，把Data Model加载到NSManagedObjectModel里面去。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)initializeCoreDataStack
{
    <span class="built_in">NSURL</span> *modelURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:@<span class="string">"PPRecipes"</span> withExtension:@<span class="string">"momd"</span>];
    ZAssert(modelURL, @<span class="string">"Failed to find model URL"</span>);
    NSManagedObjectModel *mom = <span class="literal">nil</span>;
    mom = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL]; ZAssert(mom, @<span class="string">"Failed to initialize model"</span>);
}
</pre></td></tr></table></figure>

<p>这样我们就从main bundle里面把data model加载到NSManagedObjectModel这个类里面去了。</p>
<h3 id="NSPersistentStoreCoordinator">NSPersistentStoreCoordinator</h3>
<p>NSPersistentStoreCoordinator是整个Core Data的核心。因为承担着全部数据的持久化，加载数据，缓存数据的工作。可以看做Core Data的心脏。</p>
<p>值得我们开心的事情是，虽然NSPersistentStoreCoordinator很重要，但是我们在写程序的时候其实只用初始化和设置一些很简单的参数就可以使用了。在我们App的整个生命周期里面其实并不会很频繁的使用到它。</p>
<h4 id="初始化NSPersistentStoreCoordinator">初始化NSPersistentStoreCoordinator</h4>
<p>初始化NSPersistentStoreCoordinator分为两个步骤</p>
<ol>
<li>用已经初始化好的NSManagedObjectModel去初始化它</li>
<li>选择NSPersistentStore为存储的方式</li>
</ol>
<h5 id="NSPersistentStore">NSPersistentStore</h5>
<p>理论上来说NSPersistentStoreCoordinator的数据不一定要存到硬盘上，它可以存到内存里，可以存到网络上。不过都肯定是对应着不同的应用场景。所以我们一般情况还是把它存储到磁盘上。 NSPersistentStore就是用来描述我们要把数据存到哪里的类。NSPersistentStore还可以指定存储数据的文件的文件类型。</p>
<p>目前知道的NSPersistentStore支持三种类型：</p>
<ol>
<li>SQLite</li>
<li>二进制</li>
<li>XML</li>
</ol>
<p>我就只使用SQLite。理论上来说，NSPersistentStore不管选择什么样的存储文件。你后面进行Core Data的操作都是一样的。并不需要修改你的逻辑代码。这就是Core Data把底层封装了一次的好处。(书上说iOS上不建议使用XML)</p>
<p>有一点需要注意的是NSPersistentStoreCoordinator可以加入不止一个的NSPersistentStore。这个在某些特定场景还是很有用的，以后如果能写到在写把。</p>
<h5 id="代码加载NSPersistentStoreCoordinator">代码加载NSPersistentStoreCoordinator</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>    <span class="built_in">dispatch_queue_t</span> queue = <span class="literal">NULL</span>;
    queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);
    <span class="built_in">dispatch_async</span>(queue, ^{
        <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];
        <span class="built_in">NSArray</span> *directoryArray = [fileManager URLsForDirectory:NSDocumentDirectory
                                                      inDomains:NSUserDomainMask];
        <span class="built_in">NSURL</span> *storeURL = <span class="literal">nil</span>;
        storeURL = [directoryArray lastObject];
        storeURL = [storeURL URLByAppendingPathComponent:@<span class="string">"PPRecipes.sqlite"</span>];
        <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
        NSPersistentStore *store = <span class="literal">nil</span>;
        store = [psc addPersistentStoreWithType:NSSQLiteStoreType
                               configuration   :<span class="literal">nil</span>
                               URL             :storeURL
                               options         :<span class="literal">nil</span>
                               error           :&error];
        <span class="keyword">if</span> (!store) {
            ALog(@<span class="string">"Error adding persistent store to coordinator %@\n%@"</span>,
                 [error localizedDescription], [error userInfo]);
        }
    });
</pre></td></tr></table></figure>

<p>由于这个过程是一个比较耗费资源的过程。所以我们应该把它放到后台线程里面去做。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];
        <span class="built_in">NSArray</span> *directoryArray = [fileManager URLsForDirectory:NSDocumentDirectory
                                                      inDomains:NSUserDomainMask];
</pre></td></tr></table></figure>

<p>Apple中不管是OS X还是iOS能上架的App，都是沙箱机制。这个可以自己Goolge看相关的资料。这样的话每一个App都有自己的文件系统。这两句也比较常使用。就是可以获得自己沙箱中的Document文件夹路经。参数的信息直接查文档把。</p>
<p>接下来很重要的一句是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>store = [psc <span class="symbol">addPersistentStoreWithType:</span><span class="constant">NSSQLiteStoreType</span>
    					configuration   <span class="symbol">:nil</span>
    					<span class="constant">URL</span>             <span class="symbol">:storeURL</span>
    					options         <span class="symbol">:nil</span>
   						error           <span class="symbol">:&error</span>];
</pre></td></tr></table></figure>

<p>此函数的第一个参数是指定NSPersistentStore的存储类型，我们之前说过的三种类型之一。NSSQLiteStoreType就代表这SQLite文件类型。</p>
<p>第二个参数比较高级。我还没有用到过。文档上写的是设置为nil的时候是把NSPersistentStoreCoordinator作为默认的配置，如果是其他参数可能是把NSPersistentStoreCoordinator设置为其他的用途。</p>
<p>第三个参数就是我们要存储文件的位置。刚刚我们不是获得的沙箱里面的Document文件夹路经了么。然后我们把文件名加入拼为了一个文件的完整路经传入。</p>
<p>第四个参数类型是一个字典，我们可以传入不同的参数来指定这个NSPersistentStore的类型。比如在本地比如在iCloud。比较高级先为nil。</p>
<p>最后一个参数，为error，传入一个error指针。如果NSPersistentStore初始化失败我们可以获得相应信息。</p>
<h3 id="NSManagedObjectContext">NSManagedObjectContext</h3>
<p>NSManagedObjectContext是我们很经常使用到的一个类。对于为什么要有这个类我个人理解是这样的，在我有限的数据库知识中记得，IO操作是很费时的，因此数据库一般情况是把一系列的操作缓存到了一个内存区域，等待合适的实际在去写入真实的磁盘中。这样大大的提高效率。如果你插入一条数据，然后修改数据，最后删除掉这条数据。如果是每次都执行Commit的话是操作三次IO，如果我们把这三条合并在一起commit的话。是任何事情都不必做。这样能有效的提高整个系统的效率。我认为NSManagedObjectContext的作用在于跟持久化直接做了这层缓存。我们使用Core Data。</p>
<p>还有一点需要注意的是NSManagedObjectContext并不是线程安全的。</p>
<p>关于NSManagedObjectContext的线程安全和高级解释，这里有两篇blog写的超好。</p>
<p>可以一看</p>
<p><a href="http://www.cocoanetics.com/2012/07/multi-context-coredata/" target="_blank">Multi-Context CoreData</a></p>
<p><a href="http://www.cocoanetics.com/2013/02/zarra-on-locking/" target="_blank">Zarra on Locking</a></p>
<p>初级应用的话只用记住一个就ok了NSManagedObjectContext是有一个NSManagedObjectContextConcurrencyType的属性。如果我们是UI操作（主线程操作）我们应该把它设置为NSMainQueueConcurrencyType类型的。</p>
<h4 id="代码加载NSManagedObjectContext">代码加载NSManagedObjectContext</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>NSManagedObjectContext                  *moc = nil;
NSManagedObjectContextConcurrencyType   ccType = NSMainQueueConcurrencyType;
moc = [[NSManagedObjectContext alloc] initWithConcurrencyType:ccType];
[moc <span class="keyword">set</span>PersistentStoreCoordinator:psc];
[self <span class="keyword">set</span>ManagedObjectContext:moc];
</pre></td></tr></table></figure>

<h3 id="总结">总结</h3>
<p><img src="http://ww2.sinaimg.cn/large/a7480316jw1e39dc0y8o2j.jpg" alt=""></p>
<p>至此，三个Core Data的核心类就已经简单说完了一次。他们的关系在上面的图片中表示的很清楚的样子。</p>
<p>NSPersistentStoreCoordinator从NSManagedObjectModel得到模型然后选择NSPersistentStore作为持久化目的地。然后NSManagedObjectContext在作为NSPersistentStoreCoordinator的一个缓存区给我们操作。</p>
<p>当然我这篇blog和接下来准备写的Core Data的可能不会是有完整代码和具体实例的文章。可能只是我对Core Data使用上的一些感悟和梳理。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
</feed>
