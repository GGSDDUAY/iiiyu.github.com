<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[萧宸宇]]></title>
  <subtitle><![CDATA[如果不能成为拯救世界的神，那就堕落到征服世界的魔吧。]]></subtitle>
  <link href="http://iiiyu.com/atom.xml" rel="self"/>
  <link href="http://iiiyu.com"/>
  <updated>2013-09-15T16:03:12.762Z</updated>
  <id>http://iiiyu.com/</id>
  <author>
    <name><![CDATA[萧宸宇]]></name>
    <email><![CDATA[chenyuxiao@sumi-sumi.com]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(28) ReactiveCocoa 迎接下一个更加美好的世界]]></title>
    <link href="http://iiiyu.com/2013/09/11/learning-ios-notes-twenty-eight/"/>
    <id>http://iiiyu.com/2013/09/11/learning-ios-notes-twenty-eight/</id>
    <published>2013-09-11T12:45:13.000Z</published>
    <updated>2013-09-15T15:53:14.000Z</updated>
    <content type="html"><![CDATA[<h2>扯淡</h2>
<p>习惯了，每次再写技术的东西的时候总要唠叨几句。本来唠叨的东西我应该会写成另外的blog。不过每次给自己下了一个底线要少少的写这些唠叨的话语。原因一是觉得我爱唠叨的话语可能会导致blog被墙。原因之二我不希望我变成一个IT评论家。</p>
<p>对了,我发现我还是挺爱挖坑的。目前有两坑没有填完。一个是Core Data系列。一个是iCloud系列。两个系列我都只写了一个Hello World级别并没有再深入的继续写。恩，要抓紧了。其实ReactiveCocoa这个我觉得也可以作为一个系列来写。不过想了想我这种Hello World的水平。也写不出这么多来。就暂时写一篇好了。</p>
<a id="more"></a>

<h2>什么是ReactiveCocoa</h2>
<p>如果你有看Github的Trending Objective-C榜单，那你肯定是见过ReactiveCocoa了。如果你在weibo上关注唐巧、onevcat等国内一线知名开发者。那也应该听说过ReactiveCocoa了。</p>
<p>ReactiveCocoa更加被Mattt Thompson大神称为开启一个新Objective-C纪元。</p>
<p>当然也有人声称ReactiveCocoa是Cocoa的未来。<a href="http://spin.atomicobject.com/2013/04/28/reactivecocoa/" target="_blank">ReactiveCocoa: The Future of Cocoa Programming</a></p>
<p>我自己粗犷把现在的Objective-C分为两个阶段。</p>
<p>第一个阶段就是我学Cocoa开发之前的阶段：就是把Objective-C做出来的那群NeXT的大神，确定面向对象思想，确定消息机制，确定各种模式最后变成了Apple的主力开发语言。到后面OS X的各种库。iOS的各种库。</p>
<p>第二个阶段就是我学Cocoa开发之后的阶段：开始clang发力，配合Objective-C的快速进化：ARC，block，现代Objective-C语法。使其Objective-C不断获得现代语言类如Ruby, Python的优秀特性。</p>
<p>现在，说的最多的就是ReactiveCocoa将会把Objective-C带到下一个里程碑中。</p>
<p>ReactiveCocoa是一个基于Functional Reactive Programming编程思想的Objective-C实现开源的第三方库。最初的作者是Github的大神（Josh Abernathy &amp; Justin Spahr-Summers）。应该是再开发Github For Mac时候的附属产物。当然，我们必需得明白有时候附属产物要比真主牛逼的多了去了。比如万艾可，再比如青霉素，再再比如老干妈。</p>
<p>等等 什么是Functional Reactive Programming</p>
<h3>Functional Reactive Programming</h3>
<p><a href="http://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank">wiki解释</a></p>
<h4>Reactive Programming</h4>
<p><a href="http://zh.wikipedia.org/wiki/响应式编程" target="_blank">wiki 响应式编程</a></p>
<h4>Functional programming</h4>
<p><a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank">wiki Functional programming</a></p>
<p>恩 简单来说 </p>
<pre><code><span class="title">Functional</span> Reactive Programming = Functional programming + Reactive Programming</code></pre>
<p>(PS:特么太偷懒了还是解释一下)</p>
<p>简单以</p>
<p>a = b + c</p>
<p>为例</p>
<p>通常情况下在执行a = b + c的值的时候b和c当时是什么值。a就是当时的b+c。然后后来不管b和c怎么变化，a都不会改变。</p>
<p>但是在Execl中设置a格子=b格子+c格子的值。a的值就会随着b和c值的改变而改变。然后我还可以搞的高级一点f = a + d。 f格子的值也会随着b、c、d的值而改变。这就是使用Functional Reactive Programming以后会发生的情况。</p>
<p>Reactive的特性使得可以随时响应变化。Functional的特性使得他们可以串起来。</p>
<h3>来自微软实验室的编程思想</h3>
<p>在<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/README.md#more-info" target="_blank">ReactiveCocoa的readme</a>我们看到ReactiveCocoa是基于.NET的Reactive Extensions(Rx)来的。啧啧身为一个脑残果粉不解释的我。也必须承认微软其实曾经一度集聚这世界上一大批大牛。这批大牛在闲着玩的时候做出来的玩具也指不定哪天就拯救世界了。</p>
<h4>Rx</h4>
<p>所以我也找了点Rx的资料来看看</p>
<p>中文里面比较全面的是这个<br><a href="http://www.cnblogs.com/yangecnu/archive/2012/11/03/Introducting_ReactiveExtensions.html" target="_blank">Reactive Extensions入门</a></p>
<p>里面有一堆链接和一个视频。c#实在看不懂，就只看了15分钟左右。不过那看上去蛮帅的哥们一开始说他在编程中遇到的问题。恰巧是我最近遇到的问题：就是我有两个在非主线程的异步操作。而我有可能需要等两个异步操作都完成的时候进行下一步操作。这种情况我一直没有找到比较优美的解决方法。直到遇见ReactiveCocoa，仿佛看见了希望。</p>
<h4>Model-View-ViewModel</h4>
<p><a href="http://en.wikipedia.org/wiki/Model_View_ViewModel" target="_blank">洋文wiki</a></p>
<p><a href="http://baike.baidu.com/view/3507915.htm" target="_blank">中文wiki</a></p>
<p>FRP倾向于技术理论上的方法论。MVVM则是程序模式的方法论。就好比FRP给了一把解牛的刀。MVVM就是如何解牛的方法论。</p>
<p>相对来说MVVM通常跟MVC拿来比较。在我看来，没有绝对的好和坏。找个适合的就好了。再说我对两个东西的了解不够深入。</p>
<p><a href="http://cocoasamurai.blogspot.com/2013/03/basic-mvvm-with-reactivecocoa.html" target="_blank">Basic MVVM with ReactiveCocoa</a></p>
<p>这篇blog应该就写的蛮清楚了。</p>
<p>这是github上iOS的 MVVM例子<a href="https://github.com/Machx/MVVM-IOS-Example" target="_blank">MVVM-IOS-Example</a></p>
<p>大家可以感受一下。</p>
<h2>ReactiveCocoa的基本使用方法</h2>
<p>(终于写到正主了,泪流满面)</p>
<p>这里借用Limboy的<a href="http://blog.leezhong.com/ios/2013/06/19/frp-reactivecocoa.html" target="_blank">blog</a>中的一段话作为开场解释。(因为我想了好久都没有想出超过他的比喻方法)</p>
<pre><code><span class="tag">ReactiveCocoa</span>是<span class="tag">github</span>去年开源的一个项目，是在<span class="tag">iOS</span>平台上对<span class="tag">FRP</span>的实现。<span class="tag">FRP</span>的核心是信号，信号在<span class="tag">ReactiveCocoa</span>(以下简称<span class="tag">RAC</span>)中是通过<span class="tag">RACSignal</span>来表示的，信号是数据流，可以被绑定和传递。
可以把信号想象成水龙头，只不过里面不是水，而是玻璃球(<span class="tag">value</span>)，直径跟水管的内径一样，这样就能保证玻璃球是依次排列，不会出现并排的情况(数据都是线性处理的，不会出现并发情况)。水龙头的开关默认是关的，除非有了接收方(<span class="tag">subscriber</span>)，才会打开。这样只要有新的玻璃球进来，就会自动传送给接收方。可以在水龙头上加一个过滤嘴(<span class="tag">filter</span>)，不符合的不让通过，也可以加一个改动装置，把球改变成符合自己的需求(<span class="tag">map</span>)。也可以把多个水龙头合并成一个新的水龙头(<span class="tag">combineLatest</span><span class="pseudo">:reduce</span><span class="pseudo">:)</span>，这样只要其中的一个水龙头有玻璃球出来，这个新合并的水龙头就会得到这个球。</code></pre>
<h3>替代KVO</h3>
<p>官方例子：官方的例子貌似用了比较老的函数。 我改完以后看见<a href="http://www.jdon.com/45581" target="_blank">什么是函数响应式编程(Functional Reactive Programming:FRP)</a>他也是这么改的。说明一下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>@<span class="keyword">property</span> (<span class="keyword">strong</span>) <span class="built_in">NSString</span> *username;


[RACAble(<span class="keyword">self</span>, username) subscribeNext:^(<span class="built_in">NSString</span> *newName) {
    <span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, newName);
}];
</pre></td></tr></table></figure>

<p>在这句代码以后，只要你的username有变化。都可以打印出来。实现了KVO的功能却减少了无数的代码。体现了绑定和响应。</p>
<p>高级一个点的官方例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="string">[[RACAble(self, username)
  filter:^(NSString *newName) {
      return [newName hasPrefix:@"j"];
  }]
 subscribeNext:^(NSString *newName) {
     NSLog(@"%@", newName);
 }];
</pre></td></tr></table></figure>

<p>第一个例子是简单的所有变化都会响应到。但是可能我只想响应部分情况。这时候就用filter来过滤。filter的block返回YES的情况就是需要触发的情况。其他就补返回。所以这代码以后。 username以j开头的才能打印出来。</p>
<h3>流的实现</h3>
<p>以下是<a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/" target="_blank">Getting Started with ReactiveCocoa</a>的例子和图片</p>
<p>如何以最少的代码实现一个时钟应用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>RAC(self.textField.text) = <span class="string">[[[RACSignal interval:1] startWith:[NSDate date]]</span> map:^id(NSDate *value) {
    NSDateComponents *dateComponents = <span class="string">[[NSCalendar currentCalendar] components:NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value];
    
    return [NSString stringWithFormat:@"02%ld:%02ld:%02ld",(long)dateComponents.hour, dateComponents.minute, (long)dateComponents.second];
}];
</pre></td></tr></table></figure>

<p>实现的逻辑顺序是这样的。设置一个间隔为一秒。从现在开始调用的函数。并把当前实际传入。 这个函数返回一个NSString。 然后把这个NSString和界面上的textField绑定在了一起。从而实现了我认为我见过最简单时钟程序。表现了流和绑定响应。</p>
<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/chaining.png" alt="原blog中对上述代码的流的形容图"></p>
<h3>组合</h3>
<p>几乎每个ReactiveCocoa的Demo里面都会出现的例子。</p>
<p>(继续盗图图)</p>
<p><img src="http://blog.leezhong.com/image/FRP_register_demo.png" alt=""></p>
<p>这个是用的leezhong的图。 应该是从<a href="https://speakerdeck.com/andrewsardone/reactivecocoa-at-mobidevday-2013" target="_blank">这个演讲PPT里面来的，点过去还有视频哦</a></p>
<p>就是说在必需验证每个所填写的数值符合标准。Button才能点击。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>RAC(<span class="keyword">self</span><span class="variable">.submitButton</span><span class="variable">.enabled</span>) = [RACSignal combineLatest:@[<span class="keyword">self</span><span class="variable">.usernameField</span><span class="variable">.rac_textSignal</span>, <span class="keyword">self</span><span class="variable">.passwordField</span><span class="variable">.rac_textSignal</span>] reduce:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *userName, <span class="built_in">NSString</span> *password) {
    <span class="keyword">return</span> @(userName<span class="variable">.length</span> &gt;= <span class="number">6</span> && password<span class="variable">.length</span> &gt;= <span class="number">6</span>);
}];
</pre></td></tr></table></figure>

<p>简单的解释就是把usernameField和passwordField的信号绑定在了一起做reduce处理以后。返回一个BOOL值去跟self.submitButton.enabled进行绑定。</p>
<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/combining.png" alt=""></p>
<p>囧。再次发现和leezhong借用的代码和图都是一样的。</p>
<h3>异步和网络</h3>
<p>(丢个链接 等心情好了 在补。。。)</p>
<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa#when-to-use-reactivecocoa" target="_blank">when-to-use-reactivecocoa</a></p>
<h2>总结</h2>
<p>其实我对ReactiveCocoa了解还是在hello world阶段。 很多东西都理解的很粗糙。上面这一大陀blog。很多地方写的肯定不好。欢迎指出。其实很多时候觉得确实中文原创的技术文章十分少。很大一部分都是翻译的。国外的技术文章也确实写的牛写的好。但是总觉得自己应该写点自己思考的东西。</p>
<p>对于ReactiveCocoa来说，我认为它确实是一个好东西。正如leezhong所说<br>    RAC统一了对KVO、UI Event、Network request、Async work的处理，因为它们本质上都是值的变化(Values over time)。</p>
<p>其实App上90%的操作不就只有这些么。所以我会一直对ReactiveCocoa投入时间去学习和使用。顺便说一句。阿里Mac Lab出品的Xiami for Mac。是我见过国内最好的Mac App之一。他们也用了ReactiveCocoa。然后你可以想象对他们做出那些响应交互ReactiveCocoa为他们提供了强有力的输出。</p>
<h2>参考资料</h2>
<h3>FRP</h3>
<p><a href="http://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank">wiki Functional reactive programming</a></p>
<p><a href="http://blog.zhaojie.me/2009/09/functional-reactive-programming-for-csharp.html" target="_blank">趣味编程：Functional Reactive Programming</a></p>
<p><a href="http://www.haskell.org/haskellwiki/Functional_Reactive_Programming" target="_blank">haskell Functional Reactive Programming</a></p>
<p><a href="http://zh.wikipedia.org/wiki/响应式编程" target="_blank">wiki 响应式编程</a></p>
<p><a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank">wiki Functional programming</a></p>
<p><a href="http://www.infoq.com/cn/articles/functional-reactive-programming" target="_blank">函数式反应型编程(FRP) —— 实时互动应用开发的新思路</a></p>
<p><a href="http://www.jdon.com/45581" target="_blank">什么是函数响应式编程(Functional Reactive Programming:FRP)</a></p>
<p><a href="http://www.cnblogs.com/yangecnu/archive/2012/11/03/Introducting_ReactiveExtensions.html" target="_blank">Reactive Extensions入门</a></p>
<h3>ReactiveCocoa</h3>
<p><a href="http://blog.leezhong.com/ios/2013/06/19/frp-reactivecocoa.html" target="_blank">ReactiveCocoa与Functional Reactive Programming</a></p>
<p><a href="https://speakerdeck.com/joshaber/better-code-for-a-better-world" target="_blank">Better Code for a Better World by Josh Abernathy</a></p>
<p><a href="http://nshipster.com/reactivecocoa/" target="_blank">nshipster Reactive​Cocoa</a></p>
<p><a href="http://spin.atomicobject.com/2013/04/28/reactivecocoa/" target="_blank">ReactiveCocoa: The Future of Cocoa Programming</a></p>
<p><a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/" target="_blank">Getting Started with ReactiveCocoa</a></p>
<p><a href="http://www.teehanlax.com/blog/reactivecocoa/" target="_blank">Functional Reactive Programming on iOS with ReactiveCocoa</a></p>
<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/BasicOperators.md" target="_blank">Basic Operators</a></p>
<p><a href="http://cocoasamurai.blogspot.com/2013/03/basic-mvvm-with-reactivecocoa.html" target="_blank">Basic MVVM with ReactiveCocoa<br>MVC - One Pattern to Rule them all</a></p>
<p><a href="http://twocentstudios.com/blog/2013/04/03/the-making-of-vinylogue/#design" target="_blank">How I Wrote Vinylogue for iOS With ReactiveCocoa</a></p>
<p><a href="https://github.com/RoCry/rocry.github.com/wiki/Project_ReactiveCocoa" target="_blank">来自好友RoCry的推荐</a></p>
<p><a href="https://speakerdeck.com/andrewsardone/reactivecocoa-at-mobidevday-2013" target="_blank">ReactiveCocoa at MobiDevDay 2013</a></p>
<p><a href="https://vimeo.com/65637501" target="_blank">ReactiveCocoa at MobiDevDay 2013视频</a></p>
<p><a href="http://blog.maybeapps.com/#fn:p42894317939-5" target="_blank">Input and Output</a></p>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(27) iCloud(三) key-Value Stroe]]></title>
    <link href="http://iiiyu.com/2013/09/02/learning-ios-notes-twenty-seven/"/>
    <id>http://iiiyu.com/2013/09/02/learning-ios-notes-twenty-seven/</id>
    <published>2013-09-02T14:21:13.000Z</published>
    <updated>2013-09-02T15:37:22.000Z</updated>
    <content type="html"><![CDATA[<h2>什么是NSUserDefaults</h2>
<p>NSUserDefaults的持久化本体是一个<a href="http://zh.wikipedia.org/zh/Plist" target="_blank">plist</a>.内存单例是一个操作类似NSDictionary的类。 而NSUserDefaults的出现我想是因为在每一个程序当中。我们都会设定一些选项。比如桌面壁纸、声音大小、提醒日期等，我们希望就算App关闭以后。我们再次打开的时候还在的东西。但是它并不适合存储App中关键的内容和用户自己产生的大量数据。 大量数据应该用更加合理的方式去做持久化(Document or Core Data).</p>
<a id="more"></a>

<h3>NSUserDefaults简单代码讲解</h3>
<p>使用NSUserDefaults其实巨简单。 </p>
<p>大概步骤如下:</p>
<ol>
<li>首先通过一个单例获得持久化plist的内存映射。</li>
<li>然后就可以用这个单例的实例类进行读写操作。</li>
<li>读当然没啥问题，但是写了的话这时候只是操作了在内存里面的这个单例实例。需要做持久化的动作。为什么这个动作要自己来做呢。我想是持久化都是进行IO操作。而IO操作其实很多时候就是性能的瓶颈所在。我们可能很短的时间内一次性操作很多次NSUserDefaults。这样就只用在结束的时候保存一次。IO操作就很少。反之如果每次写NSUserDefaults的时候都去做持久化。那刚刚的情况就会在很短的时间内操作多次IO。这是应该避免的。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="comment">// 首先把数据从plist里面读到内存里面的单例来</span>
NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];

<span class="comment">// 进行增加or修改操作</span>
[standardDefaults setObject:<span class="string">@"a123456789"</span> forKey:<span class="string">@"userID"</span>];
[standardDefaults setInteger:<span class="number">24</span> forKey:<span class="string">@"age"</span>];
[standardDefaults setBool:YES forKey:<span class="string">@"isLogin"</span>];

<span class="comment">// 删除操作</span>
[standardDefaults removeObjectForKey:<span class="string">@"debts"</span>];

<span class="comment">// 从内存里面写入plist进行持久化</span>
[standardDefaults synchronize];

<span class="comment">// 读取操作</span>
NSString *userID = [standardDefaults stringForKey:<span class="string">@"userID"</span>];
BOOL isLogin = [standardDefaults boolForKey:<span class="string">@"isLogin"</span>];
</pre></td></tr></table></figure>

<p>当然还有现代一点的写法。下面两种都是一个效果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// 常见方法</span>
NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];
<span class="keyword">if</span> ([standardDefaults stringForKey:<span class="string">@"favoriteColor"</span>] == nil) {
[standardDefaults setObject:<span class="string">@"Green"</span> forKey:<span class="string">@"favoriteColor"</span>];
[standardDefaults synchronize];
}

<span class="comment">// 现代高端上档次方法</span>
NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];
[standardDefaults registerDefaults:@{<span class="string">@"favoriteColor"</span>: <span class="string">@"Green"</span>}];
[standardDefaults synchronize];
</pre></td></tr></table></figure>

<h2>iCloud的Key-Value</h2>
<p>简单的，可以把iCloud的key-value当作一个在云端的NSUserDefaults。</p>
<p>我的用法是，App的Setting最终设置决定的还是NSUserDefaults。iCloud的Key-Value作为数据源来对NSUserDefaults进行修改。这样的优点在于，就算iCloud关闭或者iCloud的数据没有同步回来。你的App依然可以正常的工作和运行。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">NSUserDefaults</span> *standardDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];
</pre></td></tr></table></figure>

<p>对应</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>NSUbiquitousKeyValueStore* store = [NSUbiquitousKeyValueStore defaultStore]<span class="comment">;</span>
</pre></td></tr></table></figure>

<p>其他操作跟NSUserDefaults一样一样的。</p>
<p>只有一个值得注意的是NSUbiquitousKeyValueStore需要去监听<br>NSUbiquitousKeyValueStoreDidChangeExternallyNotification事件。就可以知道NSUbiquitousKeyValueStore是否已经同步更新完成。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>NSUbiquitousKeyValueStore* store = [NSUbiquitousKeyValueStore defaultStore];
<span class="string">[[NSNotificationCenter defaultCenter] addObserver:self
          selector:@selector(updateKVStoreItems:)
          name:NSUbiquitousKeyValueStoreDidChangeExternallyNotification
          object:store];
[store synchronize];
</pre></td></tr></table></figure>

<p>然后实现updateKVStoreItems:方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>- (void)updateKVStoreItems:(NSNotification*)notification {
   // Get <span class="keyword">the</span> <span class="type">list</span> <span class="keyword">of</span> keys <span class="keyword">that</span> changed.
   NSDictionary* userInfo = [notification userInfo];
   NSNumber* reasonForChange = [userInfo objectForKey:NSUbiquitousKeyValueStoreChangeReasonKey];
   NSInteger reason = -<span class="number">1</span>;
 
   // If a reason could <span class="keyword">not</span> be determined, do <span class="keyword">not</span> update anything.
   <span class="keyword">if</span> (!reasonForChange)
<span class="command">      return</span>;
 
   // Update only <span class="keyword">for</span> changes <span class="keyword">from</span> <span class="keyword">the</span> server.
   reason = [reasonForChange integerValue];
   <span class="keyword">if</span> ((reason == NSUbiquitousKeyValueStoreServerChange) ||
         (reason == NSUbiquitousKeyValueStoreInitialSyncChange)) {
      // If something <span class="keyword">is</span> changing externally, <span class="keyword">get</span> <span class="keyword">the</span> changes
      // <span class="keyword">and</span> update <span class="keyword">the</span> corresponding keys locally.
      NSArray* changedKeys = [userInfo objectForKey:NSUbiquitousKeyValueStoreChangedKeysKey];
      NSUbiquitousKeyValueStore* store = [NSUbiquitousKeyValueStore defaultStore];
      NSUserDefaults* userDefaults = [NSUserDefaults standardUserDefaults];
 
      // This loop assumes you are using <span class="keyword">the</span> same key names <span class="keyword">in</span> both
      // <span class="keyword">the</span> user defaults database <span class="keyword">and</span> <span class="keyword">the</span> iCloud key-value store
      <span class="keyword">for</span> (NSString* key <span class="keyword">in</span> changedKeys) {
         <span class="property">id</span> value = [store objectForKey:key];
         [userDefaults setObject:value forKey:key];
      }
   }
}
</pre></td></tr></table></figure>

<p>超级简单吧。</p>
<h2>第三方库推荐</h2>
<p>当然有大神写的第三方库。并且实现了NSUserDefaults白名单功能。因为可能你存在NSUserDefaults里面的东西不想要也不需要全部同步到NSUbiquitousKeyValueStore上去把。</p>
<p>对了忘记说一点NSUbiquitousKeyValueStore可是有大小和条目限制的。你不要把他当作无穷无尽的东西来用。具体限制是最大空间1 MB。 最多1024个key。记住不要拿来当作主要数据存储哦。</p>
<p>MK大神应该还是如雷贯耳的把。 不知道么。 MKNetworkKit是他写的。还不知道么。<br><a href="http://www.amazon.com/gp/product/1118449959/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1118449959&amp;linkCode=as2&amp;tag=blogmugunthku-20" target="_blank">iOS 6 Programming Pushing the Limits: Advanced Application Development for Apple iPhone, iPad and iPod Touch</a> 可是他写的哦。我和我的小伙伴都从MK大神的书里面学到很多不错的东西</p>
<p><a href="https://github.com/MugunthKumar/MKiCloudSync" target="_blank">MKiCloudSync</a></p>
<p><a href="https://github.com/Daij-Djan/DDiCloudSync" target="_blank">DDiCloudSync</a></p>
<p><a href="https://github.com/futuretap/FTiCloudSync" target="_blank">FTiCloudSync</a></p>
<h2>总结</h2>
<p>参考资料：</p>
<p><a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/UserDefaults/Introduction/Introduction.html" target="_blank">Preferences and Settings Programming Guide</a></p>
<p><a href="http://gibuloto.com/blog/nsuserdefaults/" target="_blank">NSUserDefaults (plist) 筆記</a></p>
<p><a href="http://www.doubleencore.com/2013/03/back-to-basics-forgotten-nsuserdefaults/" target="_blank">Back to Basics: Forgotten NSUserDefaults</a></p>
<p><a href="http://www.techotopia.com/index.php/Synchronizing_iPhone_iOS_5_Key-Value_Data_using_iCloud" target="_blank">Synchronizing iPhone iOS 5 Key-Value Data using iCloud</a></p>
<p><a href="http://useyourloaf.com/blog/2011/10/24/sync-preference-data-with-icloud.html" target="_blank">Sync Preference Data With iCloud</a></p>
<p><a href="http://www.raywenderlich.com/6015/beginning-icloud-in-ios-5-tutorial-part-1" target="_blank">Beginning iCloud in iOS 5 Tutorial Part 1</a></p>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(26) iCloud(二) 准备工作]]></title>
    <link href="http://iiiyu.com/2013/08/26/learning-ios-notes-twenty-six/"/>
    <id>http://iiiyu.com/2013/08/26/learning-ios-notes-twenty-six/</id>
    <published>2013-08-26T14:43:11.000Z</published>
    <updated>2013-09-03T02:42:45.000Z</updated>
    <content type="html"><![CDATA[<h2>开发支持iCloud的上半部分前期准备</h2>
<ul>
<li><p>需要申请一个开发者的帐号。理论上iOS和Mac OSX的都OK。考虑到我只有iOS的情况下，我的文章里面的例子默认只是iOS的。</p>
</li>
<li><p>你需要一台iOS设备，并且iOS版本必须大于等于5.最好大于等于6. 最最好大于等于7。</p>
</li>
<li><p>Xcode不用说至少是MAS里面最新的</p>
</li>
<li><p>然后去建立App Bundle ID的页面去把iCloud支持打开。</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e88hq7q78aj20sa0g2tav.jpg" alt="1"></p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e88hqn9gdej20s60h2wgz.jpg" alt="2"></p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e88hqn9gdej20s60h2wgz.jpg" alt="3"></p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e88hts5dkpj20k70en75m.jpg" alt="4"></p>
<ul>
<li>bundle id需要生成带你测试设备的证书</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e88htyxylrj20rw0egmzm.jpg" alt="5"></p>
<p>(PS:截图太累了 换成文章描述)</p>
<p>这样才能算iCloud的前期工作做完了一半。</p>
<p><strong>以下涉及到NDA内容请自行屏蔽</strong><br><a id="more"></a></p>
<ul>
<li>据说Xcode5里面支持直接开启iCloud支持，推送服务支持等。不用去登录网页了。</li>
</ul>
<ul>
<li>据说Xcode5支持iCloud调试了不需要真机了。可是特么只是支持iCloud Key-Value。Document和Core Data还是需要你一台强力的真机。</li>
</ul>
<p>(详细和剩下的大家自行脑补)</p>
<h2>开发支持iCloud的下半部分前期准备</h2>
<ul>
<li>建立一个跟上部分bundle id一样的工程项目</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e88iciw7yaj212w0qfn0a.jpg" alt="6"></p>
<ul>
<li><p>然后在工程里面把entitlements勾上以后。</p>
</li>
<li><p>支持key-value stroe把勾选上</p>
</li>
<li><p>支持Document和Core Data要添加ubiquity containers</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e88id4vlv3j20jc0a63z9.jpg" alt="7"></p>
<p>到这里，总算是把准备工作弄好了。每一个支持iCloud的App。都必须经过上面的步骤。不可跳过直接去写代码。切记切记。</p>
<h2>开发iCloud基本思维</h2>
<ol>
<li>iCloud是网络远端的数据存储服务。最终目的是确保所有设备上的所有数据一致性。 </li>
<li>使用iCloud的机制不是纯网络服务。简单的说就是在没有网络的情况下。你的App应该是可以畅通无阻的运行，并且没有缺失功能。iCloud存储的是数据的源头，App里面应该会有对应的缓存确保这样的机制。所以有多少台设备，就有多少份缓存的数据。</li>
<li>缓存数据的份数多了，为了保持数据的一致性。需要同步机制来保持更新，这时候不可避免的会产生数据冲突。就需要解决冲突。</li>
</ol>
<p>所以，只要是使用了iCloud。不论那种形式。我们都必须面对下面的几种情况并且需要对这些情况进行响应的处理：</p>
<ol>
<li>何时开启iCloud同步服务</li>
<li>在App内部关闭了iCloud以后，App的应对措施。</li>
<li>在App外部关闭了iCloud以后，App的应对措施。</li>
<li>开启iCloud以后，iCloud数据和本地数据之间的处理。</li>
<li>开启iCloud以后，正在同步数据时，UI的应对措施。</li>
<li>使用iCloud以后，当数据完成更新的时候。UI的应对措施。</li>
<li>iCloud数据冲突时候App的处理。</li>
</ol>
<p>以上是临时能回忆起来的一些需要处理的情况。真实情况可能要复杂的多。</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[深夜吐槽多看]]></title>
    <link href="http://iiiyu.com/2013/08/22/tu-cao-duo-kan/"/>
    <id>http://iiiyu.com/2013/08/22/tu-cao-duo-kan/</id>
    <published>2013-08-21T17:48:34.000Z</published>
    <updated>2013-08-21T18:01:54.000Z</updated>
    <content type="html"><![CDATA[<h2>深夜吐槽多看</h2>
<p>好吧，作为一个喜欢看书的人和觉得多看做的确实好的普通用户。我把我个人的想法完整的表达一下。</p>
<a id="more"></a>

<h2>前提</h2>
<p>首先，在国内阅读App上对我来说。多看目前已经遥遥领先。其实记得当初在iOS上引爆中文阅读的是唐茶从&lt;失控&gt;到&lt;史蒂夫·乔布斯传&gt;。让人觉得电子中文阅读还可以这么美。而多看是从Kindle起来，所以说做阅读的时间不比唐茶短。真正的混战是在字节社、多看(更新了一个版本)、豆瓣阅读上。三个App我都在对比，都在用。KK的全部书籍我都是在字节社买的。当时字节社的书更新较快。多看出于一个跟随者的角色当中。一般是字节社上了多看才上。两个都想做成中文电子书的最大平台，那时候机会看起来势均力敌甚至字节社还要有一些优势。其实那时候我喜欢的豆瓣阅读的风格。豆瓣阅读的设计平淡如茶。不像字节社的大红和多看的大黄。可惜豆瓣貌似没有想往阅读方向上大力发展。至于现在，半年都不更新一次的豆瓣阅读已经很少打开了。简单点说后来是字节社被下架很长时间。书目的种类和网上书店被多看给超越。多看也在一直努力。App做的越来越好,UI交互的重新设计，PDF的重排达到逆天的级别(我想这跟Kindle的技术积累密不可分)。至于我现在想买书的首选是多看。这段主要是表达我确实是喜欢多看阅读的。</p>
<p>其次，说一下我不喜欢的。 我不喜欢小米。跟我不喜欢隔壁大胸的妹子理由一样。 不喜欢就不喜欢呗，跟她胸大不大没关系。虽然现在多看和小米是好基友。看意图也是多看要成为小米整个体系重要的一部分。问题是我特么的不喜欢小米，没有小米手机。我就是一个普普通通的多看用户。我想用多看，而不是想用小米的一部分。然后这里就能说到帐号迁移了。我根本不想迁移去变成小米帐号。为此我还特意去多看的官网上面去看了Q&amp;A.得到的结论就是迁移是必需的。必需就是没有选择的余地。我真心觉得这个迁移很恶心，至少恶心到我觉得如果我能找到一个替代的App。我宁愿去用其他的App。结果目前还真没有能替代多看的。悲从心中来啊。虽然说迁移给了5米币啥的。但是感觉上就是把人领出去卖了，然后在卖的路上买了颗糖给吃的感觉。</p>
<h2>发现Bug</h2>
<p>相当相当的不爽。但是这些恶心的事情，都没有能阻止我想用多看看书的欲望。当我发现多看居然在搞活动。100以下卖多少送多少。想想每月买书支出应该也有个两三百。所以相当于5折了。心想还不错。暂时不想迁移这个事情来恶心自己了。结果特么在开始前的半小时我发现，特么只能是Android用户才有优惠顿时崩溃了。感觉不会在爱了，赶紧在微波上@多看的运营妹子问怎么办。然后回复我叫我借一台Android在上面购买。我方圆几百公里就特么认识一台Android。赶紧过去献媚的叫人家借我用用。 当我小心翼翼的捧这高端大气上档次的米1笨手笨脚的登录多看的时候。觉得能剩点钱还是值得的。当我点开多看准备把冯唐的书全部收掉的时候。发现都是下载。没有购买。赶紧问问手机的高富帅。人家说刚刚买了这几本！！！！多看你是闹那样。登出了这种私人用户信息都不清空。思考了一下。征求了高富帅的意见，我把多看App删除了。然后用高富帅的3G网络畅快的重新下载了一个多看App。然后又小心翼翼的捧这高端大气上档次的米1笨手笨脚的登录多看。结果特么结果还是一样的啊。人家购买过的。我没有购买的登录进去是下载，不是购买。简单点说就是大Bug啊。用户信息都特么乱穿掉了。这时候我只能手里握着100块。以45度仰望天空。默默的在微波上留言吐槽一下。</p>
<h2>回应反馈</h2>
<p>接下来是回应一下 happia 这位应该是多看员工。</p>
<p>happia的回复我整理一下大概内容如下：</p>
<p>我：为什么只有Android做活动？</p>
<p>happia：这次之所以指定了平台，是米币中心出于安全考虑，只允许在手机上进行。其实iOS平台和Kindle平台都不支持用米币买书，这个限制只是不允许在网页上参与。</p>
<p>我：为什么会有用户信息在登出的情况下还会混乱的bug？</p>
<p>happia：1、因为这次是米币第一次做公开的优惠活动，所以会谨慎很多，涉及到大规模交易的事情都要很小心，弄不好最后银行结算会出大问题。现在还在积累电子支付经验的阶段。2、这本书如果已经下载了，那就不会再显示购买按钮，而是显示阅读。你在书架上看看有没有这本书？</p>
<p>对于绝大多数情况，这样是最好的选择</p>
<p>简单的说，一个手机上在多看阅读上上用多个账户的情况很少，而且既然书架上已经有了，又要去换个账号买一次的情况更少。既然书架上已经有了，一般人都会直接打开，而不会再去买一次。这个情况已经属于特例中的特例了。</p>
<p>下面是回复吐槽：</p>
<p>至今没有搞懂你们策划为什么不允许在网页上参与。解释为支付安全考虑。毫无说服力，就算说策划的只想做Android就不做其他我都能接受。因为根本无法理解Android上支付能比网页支付安全。更何况可以是在你Android上购买了然后跳转到支付宝去网页上支付。还是说只要对普通用户解释为安全问题比较好解释？</p>
<p>米币。呵呵都往虚拟货币搞。 想的倒是很美好。这也是为什么我不想迁移的原因。</p>
<p>然后是bug的解释。我在微波上回复了一句：神逻辑。现在来解释一下什么意思.我工作以后渐渐的受到影响还是蛮尊重版权。现在电脑上可以自豪的说是全正版。反正买不起的就不用了呗。因为既然我喜欢的软件我希望作者在把他做的更好。对于书也是一样，我喜爱的文字，喜欢的思想。我都愿意付出一点。让作者能够收获一些。继续写出好看的文字，重要的智慧。让他知道自己的付出是有收获的。扯远了。 拉回来。</p>
<p>所以，当我用我的帐号去登录多看的时候。这时候的信息应该是我的。就算之前的帐号有下载过书籍作为缓存。但是我的帐号里面没有这本书，这本书是不应该显示在书架上的。然后我也可以购买啥的。这个对于我来说才是正常逻辑。也符合目前看起来的版权问题。</p>
<p>关于电子书的版权的情况现在我自己也很纠结。实体书，我买了。我可以随便借给任何人看。没有任何问题。但是电子书呢？公然的丢到网络上必然是不行的。但是我周围的人呢。可以借给他们看么。我也不知道答案。所以，现在我周围都是一本书说好看。然后大家就一起买。一个是电子书总体来说还是相对较便宜。一个是大家版权意思都在逐渐提高了。</p>
<p>最后扯回来这个bug。大可有一个帐号买了所有的书。然后进行分享。然后大家也只是偶然登录了一下这个有所有书的帐号。然后下载了全部的书。然后登录回来了自己的帐号。那这个时候，我看的书是正版？盗版？</p>
<h2>总结吐槽</h2>
<p>哎。没忍住。一下吐槽这么多。</p>
<p>最后的吐槽： 进来多看上的书是越来越多了。但是质量下降的厉害。比如那本&lt;改变未来的九大算法&gt; 翻译如同丢到google翻译 然后就拿出来卖。很是失望，希望能有退款通道。对这种没有节操的书进行退款处理</p>
<p>还有就是为啥自己导入的PDF观看的时间没有进入阅历中啊！！！！！</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/just-talk/" term="just-talk"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(25) iCloud(一) 概览]]></title>
    <link href="http://iiiyu.com/2013/08/19/learning-ios-notes-twenty-five/"/>
    <id>http://iiiyu.com/2013/08/19/learning-ios-notes-twenty-five/</id>
    <published>2013-08-19T14:29:37.000Z</published>
    <updated>2013-08-19T15:58:00.000Z</updated>
    <content type="html"><![CDATA[<h2>什么是iCloud</h2>
<p>iCloud是苹果公司提供的云服务的总称。每一个拥有Apple ID的用户都拥有5G大小的空间使用权。用户可以使用iCloud的空间来进行数据的备份，联系人备份，照片备份，应用备份等。好处就是当你有多台设备或者是换新的设备的时候。可以有无差别的体验。</p>
<p>对于开发者来说，iCloud相当于提供了一种官方形式的云端存储形式。帮助你的App实现所谓理想的状态。不论用户在什么设备打开App。 里面的数据，设置，形状，大小。都跟他上次打开的一模一样。这样你的App会给你的用户非一般的体验。</p>
<h2>开发慎用iCloud</h2>
<p>上一段说了iCloud的优点，其实是接近意淫中的理想状态。我以近一年的血泪史告诫，初级开发者，应该避免使用iCloud。中高级开发者视项目规划内容酌情使用。如果能有其他方案替代iCloud，建议优先使用其他方案。</p>
<p>初级开发者: iCloud的三种存储方式 Key-Value， Documents， Core Data都是在之前已有的框架上进行扩展的高级接口。换言之，你应该先具备了这三种技术的基本知识再开始考虑学习iCloud。 iCloud + Key-Value对应的基础是NSUserDefaults。 iCloud + Documents对应的基础是使用文档进行数据存储(NSFileManager,NSFileCoordinator,NSFileWrapper,NSCoding等一系列持久化数据存储到文件的问题). iCloud + Core Data的对应基础就是Core Data。本来是强烈建议如果没有这些基础的人不要直接来学习iCloud的。但是谁都是一步一步走过来的，如果要用到iCloud的某一种方式。建议先把基础的持久化方式原理弄懂了，在看iCloud的部分。不然学习门槛的过高，会使得进度无法按时推进。</p>
<p>中高级开发者：如果是已经用过Key-Value，Documents，Core Data的。应该会很快能明白iCloud的原理。 而进行开发。但是值得注意的是，iCloud的使用和调试会非常的消耗时间和精力。并且和你的当前网络状态息息相关。然后会出现各种诡异的情况。这个时候你都需要淡定很超级的耐心。去找到这些坑，然后慢慢的积累经验去绕过这些坑。（在这里先挖坑，后面在慢慢写我的一些使用经验）</p>
<a id="more"></a>

<h1>为什么要用iCloud</h1>
<p>既然iCloud这么多坑。为什么还要使用iCloud进行开发呢？这个问题最近半年的每周的某些时候我都会这样的问自己。 </p>
<p>个人觉得最重要的是:</p>
<p><strong>在需要数据统一的服务里面，几乎所有的第三方服务和自己搭建服务器为了识别唯一的用户。都需要进行一次注册流程。这是不可避免的。但是把注册用户的流程接入App里面。对我来说不能第一次打开就畅快的使用App是难以忍受的。iCloud由于是基于Apple ID的，相当于一个正常的用户来说是必备的。所以，使用iCloud技术可以避免注册用户流程。和App登入功能。即开即用的体验会大大提高。</strong></p>
<p>(注意，在这里我说的是几乎所有的第三方服务不包括Dropbox。Dropbox<a href="https://www.dropbox.com/developers/datastore" target="_blank">新的Datastore API</a>和本身Dropbox的普及率感觉会比注册要好一些。继续挖坑以后填)</p>
<p>其他的原因我觉得不是很重要但是还是列出来：</p>
<ol>
<li>iCloud是Apple的服务。好歹是市值4000亿刀的公司。理论上来说比小公司靠谱一些把。</li>
<li>iCloud是Apple自家的服务。App里面如果使用到了iCloud服务。理论上来说会被官方推荐的机率大了一些</li>
<li>如果以后做Apple全平台(iOS,Mac)自然对接起来应该方便一些。(感觉这个是YY)</li>
</ol>
<h2>除了iCloud还能用啥</h2>
<h3>Dropbox</h3>
<p>第一个顺位的自然是<a href="https://www.dropbox.com/developers" target="_blank">Dropbox</a>.</p>
<p>Dropbox不仅仅是一个无处不在的U盘。它还可以变成你App的数据存储端。而且新的Datastore API也显示着Dropbox会大力的发展成为App的数据端的决心。</p>
<h3>Parse</h3>
<p><a href="https://www.parse.com" target="_blank">Parse</a>的顺位也相当高。 原因在于，Parse的服务不仅仅有Data。还具备推送、社交分享等一系列高端大气上档次的功能。而且它的SDK覆盖了所有主流平台(iOS OSX Android JS WP8 W8 .NET)。更加重要的是，它在一定数据和请求量上是免费的。如果你的用户做到超过它的免费额度。我觉得这个时候你也就能轻松负担起它的付费版了。顺便说一句Parse应该是被Facebook收了。所以，应该对他们充满信心。</p>
<h3>avoscloud</h3>
<p>推荐<a href="https://cn.avoscloud.com" target="_blank">avoscloud</a>的理由很简单。这是好基友Summer参与开发的。 作为好基友肯定要鼎力推荐一下。 AVOS看起来是国际高端大气上档次的大厂。但是这个cloud，应该是完全由在天朝的团队开发的(个人猜想). 为什么要推荐？起码人家的文档是中文的，阅读起来没障碍。 有问题了，还可以直接去weibo吐槽也不当心人家看不懂好吧。</p>
<h3>helios</h3>
<p>当然如果你喜欢自己搞定一切。那你还是可以自己搭建自己的服务器的。如果你需要一个类似的参考<a href="http://helios.io" target="_blank">Mattt大神的helios</a>你不应该错过。如果你写iOS or Mac OS X开发超过三月，还不知道Mattt大神。那你应该恶补一下圈子里面的知识了。Mattt大神就是主导AFNetworking的那个啊。 不说围绕着AFNetworking衍生出来的庞大类库。 当一个<a href="http://nshipster.com" target="_blank">NSHipster</a>就造福一方啊。</p>
<h2>总结 &amp;&amp; 瞎扯蛋</h2>
<p>好久好久没有更新Blog。鄙视一下自己懒的不成样子了。其实好几次想写点扯淡的东西。但是总觉得技术Blog就应该有个技术Blog的样子。不要总是在扯淡。扯着扯着就变成IT评论家的感觉。今天黑这个，明天黑那个的。不好，应该自己踏踏实实的静心学习。最近就是因为心太乱了，导致各种问题。不过期待能把这个iCloud的系列坑给填好。也能算给自己学习了一年iCloud的使用做出一个总结不至于白弄了一年。</p>
<p>最后嫌弃我写的太慢的同学。那就给一个入口地址：从<a href="http://developer.apple.com/library/Mac/documentation/General/Conceptual/iCloudDesignGuide/Chapters/Introduction.html#//apple_ref/doc/uid/TP40012094-CH1-SW1" target="_blank">这里</a>加油把</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(24) 关于使用xCode的Tab来提高开发效率]]></title>
    <link href="http://iiiyu.com/2013/06/03/learning-ios-notes-twenty-fort/"/>
    <id>http://iiiyu.com/2013/06/03/learning-ios-notes-twenty-fort/</id>
    <published>2013-06-03T08:32:08.000Z</published>
    <updated>2013-06-03T09:19:40.000Z</updated>
    <content type="html"><![CDATA[<h1>前言</h1>
<p>通过Google分析来看blog的访问统计。发现评价阅读时间也就一分钟不到。但是之前都习惯性写长篇大论。这次换一种方式来写blog。尽量写短一些的小一些的题目。使得更新数量上去。</p>
<p>这次我来说说怎么设置Tab来提高在xCode的工作效率。</p>
<h1>我是如何使用Tab来提高效率的</h1>
<h2>xCode的Tab是什么</h2>
<p>诺，就是这一个东西。 </p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e5b26nmyqij20oq00v0sp.jpg" alt=""></p>
<p>使用过各种浏览器的你一定不会陌生。对在xCode里面我们也可以开出多个页面。而且每一个页面的状态是单独保存的。</p>
<a id="more"></a>

<h2>如何提高效率</h2>
<p>因为在实际的代码编写过程中，我们可能需要来回的查找和阅读代码。会很自然的在多个文件中跳转编辑。这时候单个编辑页面明显拖累了速度。所以我们需要多个页面来回切换就会很爽。</p>
<p>如上图所示。我习惯性长开着这几个Tab。</p>
<h2>UI</h2>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e5b1quy5pij207409wt99.jpg" alt=""></p>
<p>如图所示，我们可以在圈起来的地方设置关键词过滤显示的文件<br>这样我的名为UI的Tab就只会显示storyboard。这样改UI点击起来会很方便</p>
<h2>Data</h2>
<p>同理可得这个表情用来显示data model的。</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e5b1uqa7yhj207w094mxd.jpg" alt=""></p>
<h2>VC</h2>
<p>显示ViewController的</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e5b1v4lkuyj207x0933z6.jpg" alt=""></p>
<h2>Debug</h2>
<p>Debug这个Tab有些特殊。并不是我手动创建的。而且我配置了编译行为出来的。<br>这样每次Run的时候都会跳到这个名为Debug的Tab里面。这样做的原因是，我改了一个地方的代码。运行以后可能在其他地方挂掉了（或者在其他地方打了断点）。然后跟着进去看了看。然后想回到之前改代码的地方就会很麻烦。</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e5b1ws3qu9j20ku0f8mzu.jpg" alt=""></p>
<p>这样设置了以后，就没有上述烦恼了。</p>
<h1>顺便说一句</h1>
<p>希望这些对你有所帮助。</p>
<p>顺便说一句：Tab直接的切换可以使用快捷键 Command + Shift + ([, ]) 其实这个快捷键适用于绝大部分有Tab的App。 都可以完成切换功能</p>
<p>再顺便说一句： xCode本身内存消耗很大，开Tab。感觉很是消耗内存。如果内存吃紧的话。应该去升级内存了。不然开多个Tab只会降低工作效率并不会提高。</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(23) iOS进行单元测试OCUnit+xctool]]></title>
    <link href="http://iiiyu.com/2013/05/23/learning-ios-notes-twenty-three/"/>
    <id>http://iiiyu.com/2013/05/23/learning-ios-notes-twenty-three/</id>
    <published>2013-05-23T06:51:31.000Z</published>
    <updated>2013-06-01T14:28:11.000Z</updated>
    <content type="html"><![CDATA[<h1>iOS进行单元测试OCUnit+xctool</h1>
<h2>单元测试</h2>
<h3>什么是单元测试</h3>
<p><a href="http://zh.wikipedia.org/wiki/单元测试" target="_blank">wiki解释</a></p>
<p>简单说来就是为你的方法多专门写一个测试函数。以保证你的方法在不停的修改开发中。保持正确。如果出错，第一时间让你知道，这样从最小单位开始监控来保证软件的质量。</p>
<h3>我为什么要单元测试</h3>
<p>其实要开始写单元测试的原因是，由于我的原因格志的存储逻辑一直有问题。 一个是代码写的比较搓，一个是修改存储的逻辑的话。影响面比较大。可能修复了一个bug而引入了未知的多个bug。为了Sumi早日达到国际化大厂的标准。决定上单元测试于格志。其实最根本的目的还是想要项目变的更加可靠。</p>
<h3>单元测试的一般方法</h3>
<p>关于测试的书，一搜就一大把。都有高深的理论和方法来指导怎么写单元测试的方法。我觉得嘛不用搞了这么复杂。 无非就3种时候会去想写测试：</p>
<ol>
<li>代码完成以后</li>
<li>开始写代码之前</li>
<li>修复了一个bug以后</li>
</ol>
<p>第一种是完成了代码，恩我要测试一下我写的这些方法可靠不可靠。那这时候可以写测试。</p>
<p>第二种一个著名的方法论TDD。主要思想就是在写代码之前，就全部设计好借口。函数名字什么的。然后在写能通过测试的函数。</p>
<p>第三种就是发现了bug，我修复了这个bug。为了确保修复是成功的。那就写个测试吧。</p>
<p>我觉得啊，着三种都没有什么好或差。能写测试的少年都是好少年。何必这么在意什么时候去写呢。</p>
<p>一个完整的测试类组成像下图</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e58jl2toiej20fh0a1aam.jpg" alt=""></p>
<p>在一开始可能测试方法里面需要一些上下文环境。这些可以在Setup里面去完成。然后才可是执行自己写的测试方法。 然后测试结束以后，可能产生了一些垃圾数据文件什么的。这时候你可以在TearDown方法里面把他们处理掉。</p>
<p>以上大部分都是我自己的粗浅理解，如果你需要更多关于单元测试请阅读更加系统专业的书籍。</p>
<a id="more"></a>


<h2>OCUnit</h2>
<p>OCUnit是xCode里面自己带的单元测试框架。不必安装第三方的其他库就可以使用。最简单的就是创建项目的时候你把单元测试的那个勾点上。xCode就会自动的为你加入一个单元测试的target。快捷键Command + U。就可以运行测试。最喜欢这样方便又好用的东西了。当然运行OCUnit的测试输出的内容实在惨不忍睹。</p>
<h3>创建一个OCUnit的Unit Test</h3>
<h4>新项目使用OCUnit</h4>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58kyt9nyhj20k80dnabp.jpg" alt=""></p>
<p>选上Unit Test</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58kzfmxkij20ei0c93zt.jpg" alt=""></p>
<p>会自动的建立一个Target</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58l0l72wvj20uf0b4q51.jpg" alt=""></p>
<p>自动的为你添加好需要的类库</p>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e58l164wjkj20al0d7dh0.jpg" alt=""></p>
<p>为你添加一个Unit Test的类</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e58l1uogchj20an03cq39.jpg" alt=""></p>
<p>看一眼Scheme 只有一个。</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58l315fwmj20jg0d70ua.jpg" alt=""></p>
<p>看看Scheme里面是怎么写的。</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58l4n4ozrj209c04vdg1.jpg" alt=""></p>
<p>用Command + U运行一下测试看看结果。这是没有通过的。因为自动生成的模板就是不通过的。具体一会儿分析代码。</p>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e58l6bue5gj20zc070mze.jpg" alt=""></p>
<p>看看终端的输出。渣一般的难看。根本无法高识别度的分清。</p>
<h4>已经存在的项目使用OCUnit</h4>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58t46ki0fj20770cgdgd.jpg" alt=""></p>
<p>这是一个一开始没有选择过Unit Test的项目</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58t52kpxhj20ce0jg0tn.jpg" alt=""></p>
<p>点击增加Target</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e58t5vnb0bj20k80dndhf.jpg" alt=""></p>
<p>选择Unit testing Bundle</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58t6jsonij20k80dnmys.jpg" alt=""></p>
<p>为我们的测试bundle取一个名字</p>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e58t75sbt3j20bq03h3yu.jpg" alt=""></p>
<p>我们可以看到Scehme多出来了一个。这时候如果选择的是App的Scehme。Command + U。是没有运行测试的。要选择我们新建立的Test Scehme。再按Command + U.就运行了测试了。</p>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e58t96mpj1j20jg0d775q.jpg" alt=""></p>
<p>如何为App的Scehme添加Test。使得不用切换Scehme，就可以运行Unit Test。</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58thyodnkj20b40cswet.jpg" alt=""></p>
<p>然后选择你建立的Unit Test bundle。 打完收工。</p>
<h3>OCUnit使用的宏</h3>
<p>STAssertEqualObjects(a1, a2, description, …)</p>
<p>STAssertEquals(a1, a2, description, …)</p>
<p>STAssertEqualsWithAccuracy(a1, a2, accuracy,description, …)</p>
<p>STFail(description, …)</p>
<p>STAssertNil(a1, description, …)</p>
<p>STAssertNotNil(a1, description, …)</p>
<p>STAssertTrue(expr, description, …)</p>
<p>STAssertTrueNoThrow(expr, description, …)</p>
<p>STAssertFalse(expr, description, …)</p>
<p>STAssertFalseNoThrow(expr, description, …)</p>
<p>STAssertThrows(expr, description, …)</p>
<p>STAssertThrowsSpecific(expr, specificException, description, …)</p>
<p>STAssertThrowsSpecificNamed(expr, specificException, aName, description, …)</p>
<p>STAssertNoThrow(expr, description, …)</p>
<p>STAssertNoThrowSpecific(expr, specificException, description, …)</p>
<p>STAssertNoThrowSpecificNamed(expr, specificException, aName, description, …)</p>
<h3>比较经常使用的宏</h3>
<p>STAssertTrue(expr, description, …)</p>
<p>STAssertFalse(expr, description, …)</p>
<p>STAssertNil(a1, description, …)</p>
<p>STAssertNotNil(a1, description, …)</p>
<p>STAssertEqualObjects(a1, a2, description, …)</p>
<p>STAssertEquals(a1, a2, description, …)</p>
<p>STFail(description, …)</p>
<p>STAssertThrows(expr, description, …)</p>
<h3>写了几个测试方法的例子</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre>- (void)testOne {
	NSString <span class="variable">*string1</span> = <span class="variable">@"</span>test<span class="string">";
	NSString <span class="variable">*string2</span> = <span class="variable">@"</span>test"</span>;
	STAssertThrows([string1 isEqualToString:string2], <span class="variable">@"</span>FAILURE<span class="string">");
}

- (void)testTwo
{
    int i = 0;
    int j = 1;
    STAssertTrue(i &lt; j, <span class="variable">@"</span> i: <span class="variable">%d</span>, j: <span class="variable">%d</span>"</span>, i,j);
}

- (void)testThree
{
    
    NSString <span class="variable">*oneStr</span> = <span class="variable">@"</span>hello<span class="string">";
    NSString <span class="variable">*twoStr</span> = <span class="variable">@"</span>world"</span>;    STAssertFalse([oneStr isEqualToString:twoStr], <span class="variable">@"</span>oneStr:<span class="variable">%@</span>, twoStr:<span class="variable">%@</span><span class="string">", oneStr, twoStr);
}

- (void)testFour
{
    NSArray <span class="variable">*array</span> = nil;
    STAssertNil(array, <span class="variable">@"</span>array:<span class="variable">%@</span>"</span>, array);
}


- (void)testFive
{
    NSDictionary <span class="variable">*dict</span> = @{<span class="variable">@"</span>hello<span class="string">": <span class="variable">@"</span>word"</span>};
    STAssertNotNil(dict, <span class="variable">@"</span>dict:<span class="variable">%@</span><span class="string">", dict);
}

- (void)testSix
{
    NSNumber <span class="variable">*oneNum</span> = <span class="variable">@100</span>;
    NSNumber <span class="variable">*twoNum</span> = <span class="variable">@200</span>;
    STAssertEqualObjects(oneNum, twoNum, <span class="variable">@"</span>oneNum:<span class="variable">%@</span> twoNum:<span class="variable">%@</span>"</span>,oneNum, twoNum);
}

- (void)testSeven
{
    NSArray <span class="variable">*oneArray</span> = <span class="variable">@[</span><span class="variable">@11</span>, <span class="variable">@22</span>, <span class="variable">@33</span>];
    NSArray <span class="variable">*twoArray</span> = [oneArray copy];
    STAssertEqualObjects(oneArray, twoArray, <span class="variable">@"</span>oneArray:<span class="variable">%@</span>, twoArray:<span class="variable">%@</span><span class="string">", oneArray, twoArray);
}


- (void)testEight
{
    NSUInteger uint_1 = 4;
	NSUInteger uint_2 = 4;
	STAssertEquals(uint_1, uint_2, <span class="variable">@"</span>FAILURE"</span>);
}    
    - (void)testExample
{
    STFail(<span class="variable">@"</span>Unit tests are <span class="keyword">not</span> implemented yet in HelloAfterAddOCUnitUnitTest<span class="string">");
}
</pre></td></tr></table></figure>

<p>一会儿用xctool跑个华丽丽的出来看。</p>
<h2>xctool</h2>
<h3>xctool是什么</h3>
<p>xctool是Facebook开源的一个命令行工具，用来替代苹果的xcodebuild工具。</p>
<p><a href="https://github.com/facebook/xctool" target="_blank">github</a></p>
<p>官方演示</p>
<p><img src="https://fpotter_public.s3.amazonaws.com/xctool-uicatalog.gif" alt=""></p>
<p>你可以用它来Build你的App。跑Tests。而且它跑Test输出是华丽丽的彩色。比xCode自带的不知好看多少倍。OCUnit本来被吐槽无数，遇上了xctool以后就逆袭了啊。</p>
<p>世界上最最牛的SNS出品，肯定不会坑爹啊。</p>
<h3>安装xctool</h3>
<p>最方便 最推荐的是用Homebrew。如果你的Mac里面没有安装Homebrew我觉得是你的损失。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="title">brew</span> update
<span class="title">brew</span> install xctool
</pre></td></tr></table></figure>

<h3>使用xctool来跑OCUnit测试</h3>
<p>关于如何使用xctool，你去看官方文档肯定要比我结束好的多。 我就是过来跑测试的例子给你看而已。</p>
<h4>测试一</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="comment">xctool</span> <span class="literal">-</span><span class="comment">project</span> <span class="comment">HelloOCUnit</span>.<span class="comment">xcodeproj</span> <span class="literal">-</span><span class="comment">scheme</span> <span class="comment">HelloOCUnit</span>  <span class="comment">test
</pre></td></tr></table></figure>

<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58zjmagi8j20eh0li0wx.jpg" alt=""></p>
<h4>测试二</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">xctool</span> <span class="literal">-</span><span class="comment">project</span> <span class="comment">HelloAfterAddOCUnit</span>.<span class="comment">xcodeproj</span> <span class="literal">-</span><span class="comment">scheme</span> <span class="comment">HelloAfterAddOCUnit</span>  <span class="comment">test</span>

<span class="comment">xctool</span> <span class="literal">-</span><span class="comment">project</span> <span class="comment">HelloAfterAddOCUnit</span>.<span class="comment">xcodeproj</span> <span class="literal">-</span><span class="comment">scheme</span> <span class="comment">HelloAfterAddOCUnitUnitTest</span>  <span class="comment">test
</pre></td></tr></table></figure>

<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58zk5dk34j20h70li43i.jpg" alt=""></p>
<p><a href="http://d.pr/f/EUCR" target="_blank">项目一下载</a></p>
<p><a href="http://d.pr/f/LPaY" target="_blank">项目二下载</a></p>
<h2>总结</h2>
<p>以上就是OCUnit的使用建议。建议OCunit+xctool。来进行你的单元测试构建。更多信息请阅读相关资料。我这里只是写了入门而已。接下来的测试之路就靠你了。</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(22) CoreData (四) 监听NSFetchedResultsController]]></title>
    <link href="http://iiiyu.com/2013/04/29/learning-ios-notes-twenty-two/"/>
    <id>http://iiiyu.com/2013/04/29/learning-ios-notes-twenty-two/</id>
    <published>2013-04-29T04:03:11.000Z</published>
    <updated>2013-06-28T03:14:14.000Z</updated>
    <content type="html"><![CDATA[<h1>CoreData (四)</h1>
<h2>监听NSFetchedResultsController</h2>
<p>之前说过, NSFetchedResultsController是有两个重要的功能。</p>
<p>第一:NSFetchedResultsController是作用在Core Data上的,通过NSFetchRequest来查询Core Data里面的数据.可以返回按照组分好的数据.这样便于UITableView来显示.</p>
<p>第二:但Model改变的时候NSFetchedResultsController能及时的发出通知.准确的说,应该是当NSManagedObjectContext发生改变的时候,NSFetchedResultsController能知道这些变化,然后发出通知出来.以便UITableview能及时的更新.</p>
<p>上一篇写了第一点. 现在写第二点.</p>
<a id="more"></a>

<h2>背景</h2>
<p>如果在数据改变了的时候,我们用UITableView reload. 整个UITableView的数据确实能保持最新的情况. 但是问题是这样做的效率很低. 更希望的情况是,我哪一条数据增加,修改,删除. 就对应着UITableView里面的那一条数据在UI上增加,修改,删除.这样效率会有很大的提升. </p>
<h2>直接操作</h2>
<p>首先是用Delegate来进行UITableView的改变.</p>
<p>第一个方法,告诉UITableView数据要开始更新了,你UITableView赶紧准备好更新.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>- (void)controllerWillChangeContent:(NSFetchedResultsController *)controller{    <span class="string">[[self tableView] beginUpdates];}
</pre></td></tr></table></figure>

<p>当然有开始就有结束,下面的方法就是告诉UITableView结束更新.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>- (void)controllerDidChangeContent:(NSFetchedResultsController *)controller{    <span class="string">[[self tableView] endUpdates];}
</pre></td></tr></table></figure>

<p>这两个方法一看命名规则就能看出来是一个Delegate.在NSFetchedResultsController将要变换的时候,我们开启UITableView的编辑,然后在NSFetchedResultsController已经改变结束的时候结束UITableView的编辑.思维上自然而然,有始有终.</p>
<p>接下来我们要在begin和end之间对tableview做出改变.</p>
<p>改变section的方法.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>- (void)controller:(<span class="type">NSFetchedResultsController</span> *)controller
  didChangeSection:(id &lt;<span class="type">NSFetchedResultsSectionInfo</span>&gt;)sectionInfo
           atIndex:(<span class="type">NSUInteger</span>)sectionIndex
     forChangeType:(<span class="type">NSFetchedResultsChangeType</span>)<span class="typedef"><span class="keyword">type</span></span>
{
    <span class="type">NSIndexSet</span> *indexSet = [<span class="type">NSIndexSet</span> indexSetWithIndex:sectionIndex];
    switch(<span class="typedef"><span class="keyword">type</span>) <span class="container">{
        <span class="title">case</span> <span class="type">NSFetchedResultsChangeInsert</span>:
        {
            [[<span class="title">self</span> <span class="title">tableView</span>] <span class="title">insertSections</span>:<span class="title">indexSet</span>
                            <span class="title">withRowAnimation</span>:<span class="type">UITableViewRowAnimationFade</span>];
            <span class="title">break</span>;
        }</span></span>
        <span class="keyword">case</span> <span class="type">NSFetchedResultsChangeDelete</span>:
        {
            [[self tableView] deleteSections:indexSet
                            withRowAnimation:<span class="type">UITableViewRowAnimationFade</span>];
            break;
            
        }
    }
}
</pre></td></tr></table></figure>

<p>这个方法是在section改变的时候调用.改变类型支持两种NSFetchedResultsChangeInsert和NSFetchedResultsChangeDelete..这样我们能操作UITableView里面section变化了.</p>
<p>接下来的方法是改变cell内容的.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>- (void)controller:(<span class="type">NSFetchedResultsController</span> *)controller didChangeObject:(id)anObject       atIndexPath:(<span class="type">NSIndexPath</span> *)indexPath     forChangeType:(<span class="type">NSFetchedResultsChangeType</span>)<span class="typedef"><span class="keyword">type</span></span>      newIndexPath:(<span class="type">NSIndexPath</span> *)newIndexPath{    <span class="type">NSArray</span> *newArray = [<span class="type">NSArray</span> arrayWithObject:newIndexPath]; <span class="type">NSArray</span> *oldArray = [<span class="type">NSArray</span> arrayWithObject:indexPath]; switch(<span class="typedef"><span class="keyword">type</span>) <span class="container">{        <span class="title">case</span> <span class="type">NSFetchedResultsChangeInsert</span>:            [[<span class="title">self</span> <span class="title">tableView</span>] <span class="title">insertRowsAtIndexPaths</span>:<span class="title">newArray</span>                                    <span class="title">withRowAnimation</span>:<span class="type">UITableViewRowAnimationFade</span>];            <span class="title">break</span>;        <span class="title">case</span> <span class="type">NSFetchedResultsChangeDelete</span>:            [[<span class="title">self</span> <span class="title">tableView</span>] <span class="title">deleteRowsAtIndexPaths</span>:<span class="title">oldArray</span>                                    <span class="title">withRowAnimation</span>:<span class="type">UITableViewRowAnimationFade</span>];            <span class="title">break</span>;        <span class="title">case</span> <span class="type">NSFetchedResultsChangeUpdate</span>: {            <span class="type">UITableViewCell</span> *<span class="title">cell</span> = <span class="title">nil</span>;            <span class="type">NSManagedObject</span> *<span class="title">object</span> = <span class="title">nil</span>;            <span class="title">cell</span> = [[<span class="title">self</span> <span class="title">tableView</span>] <span class="title">cellForRowAtIndexPath</span>:<span class="title">indexPath</span>];            <span class="title">object</span> = [[<span class="title">self</span> <span class="title">fetchedResultsController</span>] <span class="title">objectAtIndexPath</span>:<span class="title">indexPath</span>]; [[<span class="title">cell</span> <span class="title">textLabel</span>] <span class="title">setText</span>:[<span class="title">object</span> <span class="title">valueForKey</span>:@"<span class="title">name</span>"]];            <span class="title">break</span>;        }</span></span>        <span class="keyword">case</span> <span class="type">NSFetchedResultsChangeMove</span>:
                        [[self tableView] deleteRowsAtIndexPaths:oldArray                                    withRowAnimation:<span class="type">UITableViewRowAnimationFade</span>];            [[self tableView] insertRowsAtIndexPaths:newArray                                    withRowAnimation:<span class="type">UITableViewRowAnimationFade</span>];        break; }}
</pre></td></tr></table></figure>

<p>在这个方法里面我们可以增删改Cell的.并且可以有动画.</p>
<h2>NSFetchedResultsController的原理</h2>
<p>上面我们已经可以无痛的使用NSFetchedResultsController了。而且各种数据都可以自动更新，但是它是一个什么原理呢？</p>
<p>NSFetchedResultsController的核心其实是作为一个观察者去监听NSManagedObjectContext的通知。当NSManagedObjectContext发生改变的时候NSFetchedResultsController就知道了变化。所以，我们初始化一个NSFetchedResultsController的时候，也就监听了对应的NSManagedObjectContext的通知。具体的是三个通知。</p>
<p><em>NSManagedObjectContextObjectsDidChangeNotification</em></p>
<p><em>NSManagedObjectContextWillSaveNotification</em></p>
<p><em>NSManagedObjectContextDidSaveNotification</em></p>
<p>其实看名字都可以猜测一些他们的具体发出通知的时机。</p>
<h4>NSManagedObjectContextObjectsDidChangeNotification</h4>
<p>当任何一个Object中的任何属性有改变的时候，会发出此通知。然后NSFetchedResultsController会去用设置好的NSFetchRequest查处结果进行参数传递。当这些改变发送的时候，我们就只用在 -controller: didChangeObject: atIndexPath: forChangeType: newIndexPath:判断改变类型是 NSFetchedResultsChangeUpdate或者 NSFetchedResultsChangeMove就可以做相应的数据到UI的变更操作了。</p>
<h4>NSManagedObjectContextWillSaveNotification</h4>
<p>这个通知是在删除Object的情况下。 这时候可能删除的是section。用-controller: didChangeSection: atIndex: forChangeType:。 如果只是一个Object的删除。就用-controller: didChangeObject: atIndexPath: forChangeType: newIndexPath:。 类型都是NSFetchedResultsChangeDelete.</p>
<h4>NSManagedObjectContextDidSaveNotification</h4>
<p>这个通知对应的delegate方法就是-controller: didChangeSection: atIndex: forChangeType: 和 -controller: didChangeObject: atIndexPath: forChangeType: newIndexPath:。 </p>
<p>了解了NSFetchedResultsController的原理。事实上自己就可以写NSFetchedResultsController了。</p>
<p>事实上，这篇blog写的确实很糟糕。 而且看日期已经写了20多天了。这样的拖沓让我很不开心。 所以我决定快速的结束这篇blog。 以后就算写的糟糕也不应该拖沓的。</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(21) CoreData (三) NSFetchedResultsController]]></title>
    <link href="http://iiiyu.com/2013/04/17/learning-ios-notes-twenty-one/"/>
    <id>http://iiiyu.com/2013/04/17/learning-ios-notes-twenty-one/</id>
    <published>2013-04-17T07:06:24.000Z</published>
    <updated>2013-04-19T02:24:50.000Z</updated>
    <content type="html"><![CDATA[<h1>CoreData (三)</h1>
<h2>NSFetchedResultsController</h2>
<h3>什么是NSFetchedResultsController</h3>
<p>NSFetchedResultsController是一个让人爱恨交加的一个类。如果使用得当，NSFetchedResultsController能帮组减少很多代码。如果使用不当，整个App就随时崩溃。</p>
<p>NSFetchedResultsController我觉得最初的设计应该是为了配合UITableView来使用的。因为UITableView在iOS的应用App中出场次数实在是太高了.而且UITableView是重要的数据展示View,所以需要频繁的向Model去请求数据,但是根据MVC来说,V不应该直接跟M联系的.这样就在Core Data下面出现了一个C—NSFetchedResultsController来把V和M协调起来. NSFetchedResultsController就是这个C. </p>
<p>NSFetchedResultsController是有两个重要的功能。</p>
<p>第一:NSFetchedResultsController是作用在Core Data上的,通过NSFetchRequest来查询Core Data里面的数据.可以返回按照组分好的数据.这样便于UITableView来显示.</p>
<p>第二:但Modle改变的时候NSFetchedResultsController能及时的发出通知.准确的说,应该是当NSManagedObjectContext发生改变的时候,NSFetchedResultsController能知道这些变化,然后发出通知出来.以便UITableview能及时的更新.</p>
<a id="more"></a>


<h2>实现一个NSFetchedResultsController作为Data source的UITableView</h2>
<h3>创建一个最小带Core Data的工程</h3>
<p><img src="http://ww3.sinaimg.cn/large/a74ecc4cjw1e3tlc32lbhj20k80dndhr.jpg" alt=""></p>
<p>选择Master-Detail Application</p>
<p><img src="http://ww4.sinaimg.cn/large/a74eed94jw1e3tle5fxqnj20k80dn0uf.jpg" alt=""></p>
<p>整理一下显示层级和结构使其看起来顺眼一些</p>
<p><img src="http://ww2.sinaimg.cn/large/a74e55b4jw1e3tlnesq81j20750dut9e.jpg" alt=""></p>
<h3>确立目标</h3>
<p>打开看以后 发现建立的工程是已经使用了NSFetchedResultsController<br>我们的目标是改写这个项目支持UITableView分组显示</p>
<h4>首先修改Data Model</h4>
<p>增加一个字段用来分组. 我们增加一个同样的Date用来记录此时的分钟数量.</p>
<p><img src="http://ww4.sinaimg.cn/large/bfadf3bejw1e3tn8pouqgj.jpg" alt=""></p>
<h3>初始化一个NSFetchedResultsController</h3>
<p>这里假设你看过我的Core Data笔记1,2.默认你已经做好了Core Data stack的全部工作.然后再开始NSFetchedResultsController的初始化.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre>- (NSFetchedResultsController *)fetchedResultsController
{
    <span class="keyword">if</span> (_fetchedResultsController != nil) {
<span class="command">        return</span> _fetchedResultsController;
    }

    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
    // Edit <span class="keyword">the</span> entity <span class="property">name</span> <span class="keyword">as</span> appropriate.
    NSEntityDescription *entity = [NSEntityDescription entityForName:@<span class="string">"Event"</span> inManagedObjectContext:self.managedObjectContext];
    [fetchRequest setEntity:entity];

    // Set <span class="keyword">the</span> batch size <span class="keyword">to</span> a suitable <span class="type">number</span>.
    [fetchRequest setFetchBatchSize:<span class="number">20</span>];

    // Edit <span class="keyword">the</span> sort key <span class="keyword">as</span> appropriate.
    NSSortDescriptor    *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@<span class="string">"timeStamp"</span> ascending:NO];
    NSArray             *sortDescriptors = @[sortDescriptor];

    [fetchRequest setSortDescriptors:sortDescriptors];

    // Edit <span class="keyword">the</span> section <span class="property">name</span> key path <span class="keyword">and</span> cache <span class="property">name</span> <span class="keyword">if</span> appropriate.
    // nil <span class="keyword">for</span> section <span class="property">name</span> key path means <span class="string">"no sections"</span>.
    NSFetchedResultsController *aFetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest managedObjectContext:self.managedObjectContext sectionNameKeyPath:@<span class="string">"sectionMinute"</span> cacheName:@<span class="string">"Master"</span>];
    aFetchedResultsController.delegate = self;
    self.fetchedResultsController = aFetchedResultsController;

    NSError *<span class="keyword">error</span> = nil;

    <span class="keyword">if</span> (![self.fetchedResultsController performFetch:&<span class="keyword">error</span>]) {
        // Replace this implementation <span class="keyword">with</span> code <span class="keyword">to</span> handle <span class="keyword">the</span> <span class="keyword">error</span> appropriately.
        // abort() causes <span class="keyword">the</span> <span class="type">application</span> <span class="keyword">to</span> generate a crash <span class="command">log</span> <span class="keyword">and</span> terminate. You should <span class="keyword">not</span> use this function <span class="keyword">in</span> a shipping <span class="type">application</span>, although <span class="keyword">it</span> may be useful during development.
        NSLog(@<span class="string">"Unresolved error %@, %@"</span>, <span class="keyword">error</span>, [<span class="keyword">error</span> userInfo]);
        abort();
    }
<span class="command">
    return</span> _fetchedResultsController;
}
</pre></td></tr></table></figure>

<p>这里是工程里面的NSFetchedResultsController的set方法.可以看出,第一我们创建一个NSFetchRequest查询.然后在用这个NSFetchRequest去创建一个NSFetchedResultsController.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>NSFetchedResultsController *aFetchedResultsController = <span class="string">[[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest managedObjectContext:self.managedObjectContext sectionNameKeyPath:@"sectionMinute" cacheName:@"Master"];
</pre></td></tr></table></figure>

<p>第一个参数就是NSFetchRequest.</p>
<p>第二个参数是要指定在哪个context里面进行查询</p>
<p>第三个参数是根据什么key来分组.sectionNameKeyPath本来是nil是不分组,我改为我们需要分组的key值“sectionMinute”.</p>
<p>第四个参数  <a href="http://developer.apple.com/library/ios/#documentation/CoreData/Reference/NSFetchedResultsController_Class/Reference/Reference.html" target="_blank">官方解释是这里</a>点到The Cache的地方. 我的理解是cache只保留很少的一部分数据在磁盘上面,如果使用了Cache,在重建UITableView的时候, 就优先查询cache里面的数据.然后要在-performFetch:执行的时候才会去刷新新的数据.这样有助于UITableView的流畅性.</p>
<p>然后我加入Sections的方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section
{
    NSArray *sections = <span class="string">[[self fetchedResultsController] sections]; id &lt;NSFetchedResultsSectionInfo&gt; sectionInfo = nil;    sectionInfo = [sections objectAtIndex:section];
    
    return [sectionInfo name];
}
</pre></td></tr></table></figure>

<p>接着我添加</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="label">https:</span>//github<span class="preprocessor">.com</span>/erica/NSDate-Extensions<span class="preprocessor">.git</span>
</pre></td></tr></table></figure>

<p>这个NSDate库进来.自己按照他的写法,写一个能获得当前时间秒数为0的方法.用来分组.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>- (<span class="class">NSDate</span> *) dateAtStartOfMinutes
{
    <span class="class">NSDateComponents</span> *components = [<span class="class">CURRENT_CALENDAR</span> <span class="method">components:</span><span class="class">DATE_COMPONENTS</span> <span class="method">fromDate:</span><span class="keyword">self</span>];
	[components <span class="method">setSecond:</span><span class="number">0</span>];
	return [<span class="class">CURRENT_CALENDAR</span> <span class="method">dateFromComponents:</span>components];
}
</pre></td></tr></table></figure>

<p>然后改写insert方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>- (void)insertNewObject:(<span class="property">id</span>)sender
{
    NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
    NSEntityDescription *entity = [[self.fetchedResultsController fetchRequest] entity];
    NSManagedObject *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity <span class="property">name</span>] inManagedObjectContext:context];
    
    // If appropriate, configure <span class="keyword">the</span> new managed object.
    // Normally you should use accessor methods, <span class="keyword">but</span> using KVC here avoids <span class="keyword">the</span> need <span class="keyword">to</span> add a custom <span class="type">class</span> <span class="keyword">to</span> <span class="keyword">the</span> template.
    [newManagedObject setValue:[NSDate <span class="type">date</span>] forKey:@<span class="string">"timeStamp"</span>];
    [newManagedObject setValue:[[NSDate <span class="type">date</span>] dateAtStartOfMinutes]  forKey:@<span class="string">"sectionMinute"</span>];
    
    // Save <span class="keyword">the</span> context.
    NSError *<span class="keyword">error</span> = nil;
    <span class="keyword">if</span> (![context save:&<span class="keyword">error</span>]) {
         // Replace this implementation <span class="keyword">with</span> code <span class="keyword">to</span> handle <span class="keyword">the</span> <span class="keyword">error</span> appropriately.
         // abort() causes <span class="keyword">the</span> <span class="type">application</span> <span class="keyword">to</span> generate a crash <span class="command">log</span> <span class="keyword">and</span> terminate. You should <span class="keyword">not</span> use this function <span class="keyword">in</span> a shipping <span class="type">application</span>, although <span class="keyword">it</span> may be useful during development. 
        NSLog(@<span class="string">"Unresolved error %@, %@"</span>, <span class="keyword">error</span>, [<span class="keyword">error</span> userInfo]);
        abort();
    }
}
</pre></td></tr></table></figure>

<p>其实就是加入了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>[newManagedObject setValue:<span class="string">[[NSDate date] dateAtStartOfMinutes]  forKey:@"sectionMinute"];
</pre></td></tr></table></figure>

<p>这句.</p>
<p>这样,简单的使用NSFetchedResultsController来显示分组的UITableView就搞定了.<br>当然因为建立的工程模板原因.很大一部分都是xCode搞定的.</p>
<h3>被遗忘的地方</h3>
<p>Sections数量,决定了有多少组</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
    <span class="keyword">return</span> <span class="string">[[self.fetchedResultsController sections] count];
}
</pre></td></tr></table></figure>

<p>如果在初始化NSFetchedResultsController的时候sectionNameKeyPath为nil.这里应该会返回1.(就算没有数据也会返回1)</p>
<p>Row数量,决定每一组分别有多少行数据.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section
{
    <span class="keyword">id</span> &lt;NSFetchedResultsSectionInfo&gt; sectionInfo = [<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> sections][section];
    <span class="keyword">return</span> [sectionInfo numberOfObjects];
}
</pre></td></tr></table></figure>

<p>我前面说过NSFetchedResultsController就是为了配合UITableView而设计的.所以自然有根据indexPath来取对应的NSManagedObject的方法.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
{
    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:@<span class="string">"Cell"</span> forIndexPath:indexPath];
    [<span class="keyword">self</span> configureCell:cell atIndexPath:indexPath];
    <span class="keyword">return</span> cell;
}

- (<span class="keyword">void</span>)configureCell:(<span class="built_in">UITableViewCell</span> *)cell atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
{
    NSManagedObject *object = [<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> objectAtIndexPath:indexPath];
    cell<span class="variable">.textLabel</span><span class="variable">.text</span> = [[object valueForKey:@<span class="string">"timeStamp"</span>] description];
}
</pre></td></tr></table></figure>

<h3>show</h3>
<p><img src="http://ww3.sinaimg.cn/large/a74ecc4cjw1e3tydp5hsqj208w0geabq.jpg" alt=""></p>
<h2>总结</h2>
<p>写Blog实在是太累了. NSFetchedResultsController努力一天也才一点点.回去继续写. 下次要写NSFetchedResultsController通知方法.</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(20)]]></title>
    <link href="http://iiiyu.com/2013/04/15/learning-ios-notes-twenty/"/>
    <id>http://iiiyu.com/2013/04/15/learning-ios-notes-twenty/</id>
    <published>2013-04-15T06:02:11.000Z</published>
    <updated>2013-04-17T06:58:46.000Z</updated>
    <content type="html"><![CDATA[<h1>UITableView简单解析</h1>
<h2>序</h2>
<p>UITableView是在iOS开发中，展示大量内容的首选。我个人认为的原有有一下几点：</p>
<ol>
<li>UITableView的展现形式是为移动设备专门设计过的。有较好的人机交互体验。</li>
<li>从技术角度来说UITableView具有重用和延迟加载等特性。如果使用恰当。可以获得一个App流畅的用户体验。</li>
</ol>
<p>这样，使得UITableView在iOS App中随处可见。</p>
<p>原生应用</p>
<p><img src="http://ww4.sinaimg.cn/large/a74ecc4cjw1e3q5jk1wrtj.jpg" alt=""></p>
<p>一些有名的App.图片信息较老</p>
<p><img src="http://ww4.sinaimg.cn/large/a74eed94jw1e3q5kl91luj.jpg" alt=""></p>
<p>包括游戏</p>
<p><img src="http://ww1.sinaimg.cn/large/a74e55b4jw1e3q5lb59vwj.jpg" alt=""></p>
<p>这些都说明UITableView在一个App中其实是一个很常用的控件。我应该好好的学习它。</p>
<a id="more"></a>


<h2>关于数据的思考</h2>
<h3>没有UITableView的时候我是这样想的</h3>
<p>首先思考为什么会有UITableView这样的控件。我们做一个App的时候，就会有大量的数据需要显示。比如weibo的每一个状态。比如一个新闻App的很多条新闻。这些数据都会有一个特点就是他们的组织形式一样，只是内容变化。有时候我们可能会根据一些条件进行分组。使得看来了是分组的。例如 联系人里面会按照首字母来进行分组一样。我们还可能会点击数据以便查看更详细的内容。</p>
<p>通过上面的简单描述，如果来自己实现一个类似UITableView的结构。需要得到最核心的：</p>
<ol>
<li>需要得到一共多少条数据</li>
<li>数据的具体内容是什么</li>
</ol>
<p>如果我们数据需要更加仔细的描述展示：</p>
<ol>
<li>全部的数据一共有多少组</li>
<li>每一组有多少个数据</li>
<li>每一条数据的具体内容是什么</li>
</ol>
<h3>UITableView是怎么做的</h3>
<p>在UITableView中。最重要的就是data source中的两个方法。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="pp">- <span class="params">(<span class="variable">NSInteger</span>)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView numberOfRowsInSection:<span class="params">(<span class="variable">NSInteger</span>)</span>section;

- <span class="params">(<span class="variable">UITableViewCell</span> *)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView cellForRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>indexPath;
</pre></td></tr></table></figure>

<p>什么是data source。字面意思就是很明白，数据的来源。一般情况下我们会设置拥有UITableView的这个UIViewController为他的data source。因为根据MVC来说。UITableView是View，UIViewController是Controller。View需要的数据，应该是Controller去跟Model协调然后获得，以后由Controller去给View来进行显示。View永远的不去直接跟Model联系。这样当UITableView初始化的时候。他就会去问他的data source。我需要显示多少行数据啊。每一行的数据都是什么内容啊。这时候UIViewController应该已经从Model拿到了数据。然后通过- (NSInteger)tableView:(UITableView <em>)tableView numberOfRowsInSection:(NSInteger)section;告诉UITableview，恩你的这一组要显示n条数据。又用- (UITableViewCell </em>)tableView:(UITableView <em>)tableView cellForRowAtIndexPath:(NSIndexPath </em>)indexPath函数告诉UITableView说，第几组第几条数据的具体内容是什么。</p>
<p>UITableView还有一个比较犀利的地方就是如果你的数据有10000条。它肯定不是把10000条都加载进来。而是只加载需要显示的条目数据。这样设计，使得UITableView的流畅程度大大提高。值得注意的是，如果Cell里面的数据是从网络 or Core Data等其他地方读取的。我们应该把读取动作写成异步的。不阻塞主线程。取到数据以后在回答主线程去刷新UI。</p>
<p>UITableView从创建到显示的调用顺序如下图</p>
<p><img src="http://ww4.sinaimg.cn/large/a74ecc4cjw1e3sfatxy0gj.jpg" alt=""></p>
<ul>
<li>(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView这个函数是最先调用，但是它默认返回1.所以并不是必须的。如果你的UITableView分了好几组，这个就是用来返回组的数量的。</li>
</ul>
<p>这样完成了设置UITableView的data source设置。在完成</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="pp">- <span class="params">(<span class="variable">NSInteger</span>)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView numberOfRowsInSection:<span class="params">(<span class="variable">NSInteger</span>)</span>section;

- <span class="params">(<span class="variable">UITableViewCell</span> *)</span>tableView:<span class="params">(<span class="variable">UITableView</span> *)</span>tableView cellForRowAtIndexPath:<span class="params">(<span class="variable">NSIndexPath</span> *)</span>indexPath;
</pre></td></tr></table></figure>

<p>这两个函数。我们就可以得到一个能显示的UITableView了。</p>
<p>现在是是仅仅解释了UITableView的数据是怎么来的，然后怎么对应到UITableView上面。</p>
<h2>UITableViewCell</h2>
<p>UITableViewCell具体的每一条数据展示的具体View。首先在UITableView里面有这样一个特点，每一个Cell的大概样子都长的差不多，只是里面具体的内容稍有变化。这样在UI里面我们应该是重用相同的部分，改变不同的部分。这样才能提高效率。因为在UiTableView这个视图里面，用户习惯性快速的滚动，视图和数据内容都会快速的变化，如果效率问题处理不好，很容易有卡顿的现象。造成用户体验的降低。</p>
<p>如果使用默认的UITableViewCell风格，有以下四种</p>
<p>UITableViewCellStyleDefault</p>
<p><img src="http://ww2.sinaimg.cn/large/a74eed94jw1e3sha1cl2oj.jpg" alt=""></p>
<p>UITableViewCellStyleSubtile</p>
<p><img src="http://ww4.sinaimg.cn/large/a74e55b4jw1e3shcdevpbj.jpg" alt=""></p>
<p>UITableViewCellStyleValue1</p>
<p><img src="http://ww1.sinaimg.cn/large/bfadf3bejw1e3shcssq55j.jpg" alt=""></p>
<p>UITableViewCellStyleValue2</p>
<p><img src="http://ww4.sinaimg.cn/large/a74ecc4cjw1e3shdbgbrgj.jpg" alt=""></p>
<p>当然如果是需要自定义Cell也是很简单。 用xib拖一个，完全可以GUI的方式来创建，很是方便。</p>
<p>(Google一个栗子吧，写不动了)</p>
<p>插一句，Cell的重用是需要下面这样的实现方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static NSString *Cell = @<span class="string">"MyCell"</span>;
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:Cell];
    <span class="keyword">if</span> (!cell) {
        cell = <span class="string">[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:Cell];
    }
    return cell;
}
</pre></td></tr></table></figure>

<p>重要的是UITableView的dequeueReusableCellWithIdentifier方法。</p>
<p>dequeueReusableCellWithIdentifier去一个队列里面需找有没有相同ID的的Cell。如果有就提出来重用。可以重用的部分。如果没有就跳进if里面去创建。所以我们在if里面创建的时候，不会改变的内容都可以在里面创建，这样就只用创建一次。需要改变的内容我们就放到if后面去写。 这样我们就能完成高效的UITableView。当然，理论上来说，你可以不用这样的机制，而去直接每次创建一个Cell。不过这是非常浪费资源的一个做法，直接不提倡。</p>
<h2>UITableView Delegate</h2>
<p>当然，在写UITableView肯定想控制的更多。才能完成设计师们辛辛苦苦画出来的稿。这样我们可以去看看Data source里面剩下的函数和Delegate。</p>
<p>当然就说一点</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">//选中Cell响应事件</span>
- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
{
    <span class="comment">//选中后的反显颜色即刻消失</span>
    [tableView deselectRowAtIndexPath:indexPath animated:<span class="literal">YES</span>];
}
</pre></td></tr></table></figure>

<p>这个是选中Cell时候会的出发点。如果要点击以后做什么事情 就在这里做了。 </p>
<p><a href="http://www.devdiv.com/home.php?mod=space&amp;uid=39974&amp;do=blog&amp;id=2573" target="_blank">找了篇目测还ok的中文blog可以先看看了解</a></p>
<h2>数据刷新</h2>
<p>如果我们的modle更新了。相应的要体现到UITableView上面。简单的我们可以reload整个TableView。这样做很方便，而且数据上没有问题。唯一的问题就是，reload整个TableView的效率太低了。而且，往往我们只是少数的Cell内容变化。所以没有必要去reload整个TableView。而是那条数据变化去刷新对应的Cell就好了。这样做效率提高很多。</p>
<p>具体涉及到的几个函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="pp">- <span class="params">(void)</span>beginUpdates;
- <span class="params">(void)</span>endUpdates;
 
- <span class="params">(void)</span>insertSections:<span class="params">(<span class="variable">NSIndexSet</span> *)</span>sections withRowAnimation:<span class="params">(<span class="variable">UITableViewRowAnimation</span>)</span>animation;
- <span class="params">(void)</span>deleteSections:<span class="params">(<span class="variable">NSIndexSet</span> *)</span>sections withRowAnimation:<span class="params">(<span class="variable">UITableViewRowAnimation</span>)</span>animation;
- <span class="params">(void)</span>reloadSections:<span class="params">(<span class="variable">NSIndexSet</span> *)</span>sections withRowAnimation:<span class="params">(<span class="variable">UITableViewRowAnimation</span>)</span>animation;
 
- <span class="params">(void)</span>insertRowsAtIndexPaths:<span class="params">(<span class="variable">NSArray</span> *)</span>indexPaths withRowAnimation: <span class="params">(<span class="variable">UITableViewRowAnimation</span>)</span>animation;
- <span class="params">(void)</span>deleteRowsAtIndexPaths:<span class="params">(<span class="variable">NSArray</span> *)</span>indexPaths withRowAnimation: <span class="params">(<span class="variable">UITableViewRowAnimation</span>)</span>animation;
- <span class="params">(void)</span>reloadRowsAtIndexPaths:<span class="params">(<span class="variable">NSArray</span> *)</span>indexPaths withRowAnimation:<span class="params">(<span class="variable">UITableViewRowAnimation</span>)</span>animation;
</pre></td></tr></table></figure>

<p><a href="http://www.cnblogs.com/smileEvday/archive/2012/06/28/tableView.html" target="_blank">这里有实例代码可以参考</a></p>
<p><a href="http://developer.apple.com/library/ios/#documentation/UserExperience/Conceptual/TableView_iPhone/ManageInsertDeleteRow/ManageInsertDeleteRow.html#//apple_ref/doc/uid/TP40007451-CH10-SW1" target="_blank">官方教程</a></p>
<p>里面写了如何优化UITableView：</p>
<p><a href="http://www.keakon.net/2011/08/03/优化UITableView性能" target="_blank">又找了一篇blog写的很不错的样子，优化UITableView性能</a></p>
<h2>后记</h2>
<p>总结就是UITableView是一个高度设计的控件。它具有重用，分组，异步加载数据等方面需要我们注意。</p>
<p>其实这里插进来写UITableView是为了写NSFetchedResultsController。因为NSFetchedResultsController就是为UITableview量身打造的Core Data的类。 </p>
<p>所以，先说明以下UITableView，然后再写NSFetchedResultsController。</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(19)]]></title>
    <link href="http://iiiyu.com/2013/04/01/learning-ios-notes-nineteen/"/>
    <id>http://iiiyu.com/2013/04/01/learning-ios-notes-nineteen/</id>
    <published>2013-04-01T03:28:20.000Z</published>
    <updated>2013-04-01T04:47:23.000Z</updated>
    <content type="html"><![CDATA[<h1>Core Data (二)</h1>
<h1>序</h1>
<p><a href="http://iiiyu.com/2013/03/29/learning-ios-notes-eighteen/">上次</a>只是说了三个Core Data栈基本类。这次准备介绍一下常用的类。</p>
<h2>NSManagedObject</h2>
<p><img src="http://ww1.sinaimg.cn/large/bfadf3bejw1e39yrt56ifj.jpg" alt=""></p>
<p>Core Data是一次底层数据封装成面向对象的技术。最直接的表现就是在SQLite里面的一条记录在Core Data里面的表现是一个NSManagedObject对象。因此我们的增删改查都是基于操作对象的。恩这里多说一句，NSManagedObject是相对NSManagedObjectContext里面是唯一的。而真实的应用情况可能是NSManagedObjectContext会有多个。而NSManagedObjectContext线程不是安全的，所以可能有你多个NSManagedObjectContext里面各自有指向同一条数据的不同的NSManagedObject。这个情况需要你的程序设计和逻辑上去解决。暂时不讨论。</p>
<a id="more"></a>

<h3>使用NSManagedObject所经历的三种方法</h3>
<p>对于NSManagedObject来说一般有以下几种使用方法：</p>
<p>第一种就是我直接使用NSManagedObject来访问我的数据，因为Cocoa特有的KVC机制，使得NSManagedObject可以用KVC的方法去访问属性内容。这样的好处是你不用在NSManagedObject上去写特别的代码，就可以使用。一般入门例子都是这样写的。</p>
<p>第二种是老头视频里面教过的。在点击Data Model选择Entity以后，在xCode的菜单里面有这样一个选项：</p>
<p><img src="http://ww4.sinaimg.cn/large/bfadf3bejw1e39z74y7j8j.jpg" alt=""></p>
<p>next都按完了以后，会生成选择了的Entity对应的一个NSManagedObject子类。这样的话我们就可以用生成的类来进行增删改查。这样的话看起来代码里面也会变得清晰一些。我们也不必去写KVC的方法去访问修改属性。可以直接就访问修改。在我看来还是好处多多的。为了OO的原则，我们可能会对不同的Entity类去写一些只是公开接口的方法。但是这样生成的NSManagedObject子类是不好修改的。因此我们会去建立一个category类。来进行扩写自己的方法。这样项目里面就会出现一票category感觉不是很好的样子。</p>
<p>第三种方法是我现在在使用的方法。<br>就是使用Mogenerator.</p>
<p>Mogenerator已经写过一篇blog了。<a href="http://iiiyu.com/2013/02/22/learning-ios-notes-fifteen/">详细查看Mogenerator的初级使用</a><br>好处是生成一次以后，再次生成并会在工程里面重复引用。而且机制上可以直接在生成的类里面进行方法的扩写。不用使用category类。这样整个工程就看起来高级素雅很多。</p>
<h3>NSManagedObject其他注意事项</h3>
<p>NSManagedObject就是我们拿来操作数据的基本单位。因此对应，增加一条数据是在NSManagedObjectContext新建一个NSManagedObject。查找数据是查找NSManagedObject。修改是修改NSManagedObject类的属性。删除是从NSManagedObjectContext里面删除NSManagedObject类。最后我们保存NSManagedObjectContext，然后一直向上传递到磁盘上面去。才是持久化的修改。</p>
<h2>NSFetchRequest</h2>
<p>NSFetchRequest是一个查询的动作类。我们使用它来在NSManagedObjectContext里面查询相应的NSManagedObject。</p>
<p>一般使用的顺序是先生成NSFetchRequest。指定要查询的NSManagedObjectContext和Entity的名字。然后设置NSPredicate进行过滤。NSSortDescriptor来进行排序。最后用想要查询的NSManagedObjectContext执行NSFetchRequest。就可以得到返回结果了。</p>
<h2>NSPredicate</h2>
<p>NSPredicate的作用不仅仅局限于Core Data里面。其他时候也有用到的地方。而在Core Data里面使用简单的说就是作为一个过滤条件。过滤掉我们不想查找的数据。就相当于SQL语句WHERE后面的那些条件。</p>
<h2>NSSortDescriptor</h2>
<p>查找到的数据是杂乱无章的。而我们往往希望是具有一定顺序的返回结果。NSSortDescriptor就是用来指定排序的属性和方式的。把NSSortDescriptor生成设置好然后给NSFetchRequest设置。这样我们的结果就可以是按照我们希望的顺序返回回来。以便我们操作。</p>
<h2>实例代码</h2>
<p>新建NSManagedObject</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="class">NSManagedObject</span> *newManagedObject = [<span class="class">NSEntityDescription</span> <span class="method">insertNewObjectForEntityForName:</span>[entity name] <span class="method">inManagedObjectContext:</span>context];
[newManagedObject <span class="method">setValue:</span>[<span class="class">NSDate</span> date] <span class="method">forKey:</span>@<span class="comment">"timeStamp"</span>];
</pre></td></tr></table></figure>

<p>删除NSManagedObject</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">[context deleteObject:managedObject]</span><span class="comment">;</span>
</pre></td></tr></table></figure>

<p>初始化NSPredicate</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">NSUInteger</span>  numberOfServings = <span class="number">10</span>;<span class="title">NSPredicate</span> *predicate = nil;<span class="title">predicate</span> = [NSPredicate predicateWithFormat:@<span class="string">"serves &gt; %i"</span>, numberOfServings];
</pre></td></tr></table></figure>

<p>初始化NSSortDescriptor</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>NSSortDescriptor *sort = <span class="string">[[NSSortDescriptor alloc] initWithKey:@"name" ascending:YES];
</pre></td></tr></table></figure>

<p>初始化NSFetchRequest</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>NSManagedObjectContext *moc = [self managedObjectContext]; NSFetchRequest *request = <span class="string">[[NSFetchRequest alloc] init]; [request setEntity:[NSEntityDescription entityForName:@"Recipe"
                                                                                                                                                            inManagedObjectContext:moc]]</span>;
</pre></td></tr></table></figure>

<p>带有NSPredicate的初始化NSFetchRequest</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>NSUInteger              numberOfServings = <span class="number">10</span>;NSManagedObjectContext  *moc = [self managedObjectContext]; NSFetchRequest *request = <span class="string">[[NSFetchRequest alloc] init]; [request setEntity:[NSEntityDescription    entityForName:@"Recipe"                                                                                                                                                                inManagedObjectContext:moc]]</span>;NSPredicate *predicate = <span class="keyword">nil</span>;predicate = [NSPredicate predicateWithFormat:@<span class="string">"serves &gt; %i"</span>, numberOfServings]; [request setPredicate:predicate];
</pre></td></tr></table></figure>

<p>带有NSSortDescriptor的初始化NSFetchRequest</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>NSFetchRequest *fetchRequest = <span class="keyword">nil</span>;
fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@<span class="string">"Recipe"</span>];
NSSortDescriptor *sort = <span class="string">[[NSSortDescriptor alloc] initWithKey:@"name" ascending:YES];
[fetchRequest setSortDescriptors:[NSArray arrayWithObject:sort]]</span>;
</pre></td></tr></table></figure>

]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(18)]]></title>
    <link href="http://iiiyu.com/2013/03/29/learning-ios-notes-eighteen/"/>
    <id>http://iiiyu.com/2013/03/29/learning-ios-notes-eighteen/</id>
    <published>2013-03-28T16:04:37.000Z</published>
    <updated>2013-03-31T15:27:05.000Z</updated>
    <content type="html"><![CDATA[<h1>Core Data (一)</h1>
<h2>序</h2>
<p>恩，用Core Data也有一段时间了。大大小小的坑也都坑过了。重来没有认真的记录一次。这次需要好好的理一理Core Data。就当一次绝好的机会记录下来。也为了自己加深认识。</p>
<h2>为什么要用Core Data</h2>
<p>CoreData的学习是需要一定成本的。以至于我认识的人很少在用，大家要不就是用一个FMDB。或者做的App是一个已有的Web的延伸，数据直接用Web端的Api取回来就好了。</p>
<p>我们要用Core Data的理由有以下几点：</p>
<ol>
<li>Core Data是对底层存储的一次封装。封装了以后就变成ORM的框架。这样就变成操作对象。Core Data自己去进行数据的保存。</li>
<li>使用Core Data而不是FMDB，让整个程序架构更加的面向对象。</li>
<li>Core Data仅仅使用了Objective-C和Core Foundation，你不必去加入一些第三方的库。</li>
<li>Core Data是Apple的原生技术。每年的WWDC都能看到新特性的加入和讲授。</li>
<li>Core Data支持iCloud。而使用iCloud的App。Apple推荐的可能性增加。</li>
<li>有了iCloud为以后Apple的全平台数据共享打下基础</li>
</ol>
<p>所以，没有理由拒绝使用Core Data做为你App的持久化。Core Data应该是一个跟Apple混的第一选择。</p>
<a id="more"></a>


<h2>存储原理</h2>
<h3>NSManagedObjectModel</h3>
<h4>认识</h4>
<p>我个人是把NSManagedObjectModel看做为一个core data的schema。生成这个类的来源是xCode中的Data Model</p>
<p><img src="http://ww3.sinaimg.cn/large/bfadf3bejw1e36lv4nn89j.jpg" alt=""></p>
<p>点击之后会生成一个.xcdatamodeld的文件夹里面的数据具体是是用xml来存储的。<br>但是你在xCode里面看这个.xcdatamodeld文件夹是认为一个文件。然后可以用xCode来进行图形化的编辑。</p>
<p>如这样</p>
<p><img src="http://ww1.sinaimg.cn/large/bfadf3bejw1e36m76n6k3j.jpg" alt=""></p>
<p>当然还有另外一种表格的方式来编辑Data Model</p>
<p><img src="http://ww3.sinaimg.cn/large/bfadf3bejw1e36mhk7obgj.jpg" alt=""></p>
<p>我们编辑这个的这个文件，理论上来说只是一个资源文件。相当于数据库的schema。我们的数据库长什么样子，就是你来设计的。然后在程序中通过NSURL找到这个资源文件的位置。就可以初始化成为NSManagedObjectModel。</p>
<h4>代码加载Data Model</h4>
<p>当我们设计好我们的Data Model以后。可以用以下代码，把Data Model加载到NSManagedObjectModel里面去。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>- (void)initializeCoreDataStack{    NSURL *modelURL = <span class="string">[[NSBundle mainBundle] URLForResource:@"PPRecipes" withExtension:@"momd"];    ZAssert(modelURL, @"Failed to find model URL");    NSManagedObjectModel *mom = nil;    mom = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL]; ZAssert(mom, @"Failed to initialize model");}
</pre></td></tr></table></figure>

<p>这样我们就从main bundle里面把data model加载到NSManagedObjectModel这个类里面去了。</p>
<h3>NSPersistentStoreCoordinator</h3>
<p>NSPersistentStoreCoordinator是整个Core Data的核心。因为承担着全部数据的持久化，加载数据，缓存数据的工作。可以看做Core Data的心脏。</p>
<p>值得我们开心的事情是，虽然NSPersistentStoreCoordinator很重要，但是我们在写程序的时候其实只用初始化和设置一些很简单的参数就可以使用了。在我们App的整个生命周期里面其实并不会很频繁的使用到它。</p>
<h4>初始化NSPersistentStoreCoordinator</h4>
<p>初始化NSPersistentStoreCoordinator分为两个步骤</p>
<ol>
<li>用已经初始化好的NSManagedObjectModel去初始化它</li>
<li>选择NSPersistentStore为存储的方式</li>
</ol>
<h5>NSPersistentStore</h5>
<p>理论上来说NSPersistentStoreCoordinator的数据不一定要存到硬盘上，它可以存到内存里，可以存到网络上。不过都肯定是对应着不同的应用场景。所以我们一般情况还是把它存储到磁盘上。 NSPersistentStore就是用来描述我们要把数据存到哪里的类。NSPersistentStore还可以指定存储数据的文件的文件类型。</p>
<p>目前知道的NSPersistentStore支持三种类型：</p>
<ol>
<li>SQLite</li>
<li>二进制</li>
<li>XML</li>
</ol>
<p>我就只使用SQLite。理论上来说，NSPersistentStore不管选择什么样的存储文件。你后面进行Core Data的操作都是一样的。并不需要修改你的逻辑代码。这就是Core Data把底层封装了一次的好处。(书上说iOS上不建议使用XML)</p>
<p>有一点需要注意的是NSPersistentStoreCoordinator可以加入不止一个的NSPersistentStore。这个在某些特定场景还是很有用的，以后如果能写到在写把。</p>
<h5>代码加载NSPersistentStoreCoordinator</h5>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>    <span class="built_in">dispatch_queue_t</span> queue = <span class="literal">NULL</span>;    queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);    <span class="built_in">dispatch_async</span>(queue, ^{        <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];        <span class="built_in">NSArray</span> *directoryArray = [fileManager URLsForDirectory:NSDocumentDirectory                                                      inDomains:NSUserDomainMask];        <span class="built_in">NSURL</span> *storeURL = <span class="literal">nil</span>;        storeURL = [directoryArray lastObject];        storeURL = [storeURL URLByAppendingPathComponent:@<span class="string">"PPRecipes.sqlite"</span>];        <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;        NSPersistentStore *store = <span class="literal">nil</span>;        store = [psc addPersistentStoreWithType:NSSQLiteStoreType                               configuration   :<span class="literal">nil</span>                               URL             :storeURL                               options         :<span class="literal">nil</span>                               error           :&error];        <span class="keyword">if</span> (!store) {            ALog(@<span class="string">"Error adding persistent store to coordinator %@\n%@"</span>,                 [error localizedDescription], [error userInfo]);        }    });
</pre></td></tr></table></figure>

<p>由于这个过程是一个比较耗费资源的过程。所以我们应该把它放到后台线程里面去做。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">NSFileManager</span> *fileManager = [NSFileManager defaultManager];        <span class="title">NSArray</span> *directoryArray = [fileManager URLsForDirectory:NSDocumentDirectory                                                      inDomains:NSUserDomainMask];
</pre></td></tr></table></figure>

<p>Apple中不管是OS X还是iOS能上架的App，都是沙箱机制。这个可以自己Goolge看相关的资料。这样的话每一个App都有自己的文件系统。这两句也比较常使用。就是可以获得自己沙箱中的Document文件夹路经。参数的信息直接查文档把。</p>
<p>接下来很重要的一句是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>store = [psc <span class="symbol">addPersistentStoreWithType:</span><span class="constant">NSSQLiteStoreType</span>    					configuration   <span class="symbol">:nil</span>    					<span class="constant">URL</span>             <span class="symbol">:storeURL</span>    					options         <span class="symbol">:nil</span>   						error           <span class="symbol">:&error</span>];
</pre></td></tr></table></figure>

<p>此函数的第一个参数是指定NSPersistentStore的存储类型，我们之前说过的三种类型之一。NSSQLiteStoreType就代表这SQLite文件类型。</p>
<p>第二个参数比较高级。我还没有用到过。文档上写的是设置为nil的时候是把NSPersistentStoreCoordinator作为默认的配置，如果是其他参数可能是把NSPersistentStoreCoordinator设置为其他的用途。</p>
<p>第三个参数就是我们要存储文件的位置。刚刚我们不是获得的沙箱里面的Document文件夹路经了么。然后我们把文件名加入拼为了一个文件的完整路经传入。</p>
<p>第四个参数类型是一个字典，我们可以传入不同的参数来指定这个NSPersistentStore的类型。比如在本地比如在iCloud。比较高级先为nil。</p>
<p>最后一个参数，为error，传入一个error指针。如果NSPersistentStore初始化失败我们可以获得相应信息。</p>
<h3>NSManagedObjectContext</h3>
<p>NSManagedObjectContext是我们很经常使用到的一个类。对于为什么要有这个类我个人理解是这样的，在我有限的数据库知识中记得，IO操作是很费时的，因此数据库一般情况是把一系列的操作缓存到了一个内存区域，等待合适的实际在去写入真实的磁盘中。这样大大的提高效率。如果你插入一条数据，然后修改数据，最后删除掉这条数据。如果是每次都执行Commit的话是操作三次IO，如果我们把这三条合并在一起commit的话。是任何事情都不必做。这样能有效的提高整个系统的效率。我认为NSManagedObjectContext的作用在于跟持久化直接做了这层缓存。我们使用Core Data。</p>
<p>还有一点需要注意的是NSManagedObjectContext并不是线程安全的。</p>
<p>关于NSManagedObjectContext的线程安全和高级解释，这里有两篇blog写的超好。</p>
<p>可以一看</p>
<p><a href="http://www.cocoanetics.com/2012/07/multi-context-coredata/" target="_blank">Multi-Context CoreData</a></p>
<p><a href="http://www.cocoanetics.com/2013/02/zarra-on-locking/" target="_blank">Zarra on Locking</a></p>
<p>初级应用的话只用记住一个就ok了NSManagedObjectContext是有一个NSManagedObjectContextConcurrencyType的属性。如果我们是UI操作（主线程操作）我们应该把它设置为NSMainQueueConcurrencyType类型的。</p>
<h4>代码加载NSManagedObjectContext</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>NSManagedObjectContext                  *moc = <span class="keyword">nil</span>;NSManagedObjectContextConcurrencyType   ccType = NSMainQueueConcurrencyType;moc = <span class="string">[[NSManagedObjectContext alloc] initWithConcurrencyType:ccType];[moc setPersistentStoreCoordinator:psc];[self setManagedObjectContext:moc];
</pre></td></tr></table></figure>



<h3>总结</h3>
<p><img src="http://ww2.sinaimg.cn/large/a7480316jw1e39dc0y8o2j.jpg" alt=""></p>
<p>至此，三个Core Data的核心类就已经简单说完了一次。他们的关系在上面的图片中表示的很清楚的样子。</p>
<p>NSPersistentStoreCoordinator从NSManagedObjectModel得到模型然后选择NSPersistentStore作为持久化目的地。然后NSManagedObjectContext在作为NSPersistentStoreCoordinator的一个缓存区给我们操作。</p>
<p>当然我这篇blog和接下来准备写的Core Data的可能不会是有完整代码和具体实例的文章。可能只是我对Core Data使用上的一些感悟和梳理。</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[Mac笔记 (1)]]></title>
    <link href="http://iiiyu.com/2013/03/19/learning-mac-notes-one/"/>
    <id>http://iiiyu.com/2013/03/19/learning-mac-notes-one/</id>
    <published>2013-03-19T15:45:25.000Z</published>
    <updated>2013-03-19T16:45:31.000Z</updated>
    <content type="html"><![CDATA[<h1>ssh远程登录Mac OS X</h1>
<h2>序</h2>
<p>近一年抱了Apple大腿之后，各种表弟、师兄、朋友陆续也开始抱Apple大腿。难免遇到各种问题，这个时候在QQ交流效率低下，简直不可忍受。也不知大腾讯啥时候支持一下QQ for Mac的远程协助。这样有时候也可以帮助一下在家的老爸老妈解决一些PC上的问题。大神们绕道无鄙视。OS X乃纯Unix血统。教科书上都写了*nix系统可以ssh登录过去搞定一切。就想着可以用ssh来解决问题。无奈网络基础确实是挂课的水平曾经尝试过一次没有成功。这次又再次遇到远程协助的问题就好好Google了一次。研究了好一会儿终于搞定，在此记录。</p>
<a id="more"></a>

<h2>参考资料</h2>
<p><a href="http://www.maclife.com/article/howtos/how_enable_ssh_your_mac" target="_blank">How To Enable SSH on Your Mac</a></p>
<h2>开始打怪</h2>
<h3>环境</h3>
<ol>
<li>一台低端D-Link的无线路由用PPoE上网方式</li>
<li>一台低端Macbook pro安装OS X 10.8.3</li>
</ol>
<h3>设置你的Mac在局域网的IP为固定IP</h3>
<p>这一步参考资料上是有的。应该也是必须的。有两种设置方法，一种是参考资料上写的那种在OS X里面设置</p>
<p><img src="http://ww2.sinaimg.cn/large/bfadf3bejw1e2vjoar7hbj.jpg" alt="图1"></p>
<p><img src="http://ww4.sinaimg.cn/large/a74ecc4cjw1e2vjoji35vj.jpg" alt="图2"></p>
<p><img src="http://ww3.sinaimg.cn/large/a74e55b4jw1e2vjoswx7lj.jpg" alt="图3"></p>
<p>我的是直接在路由里面设置的。不同路由不一样，请自行处理</p>
<h3>在路由里面设置转发端口和规则</h3>
<p>在参考资料里面用的是Airport。给我找了一晚上设置界面没有找到。网络知识匮乏的后果阿。后来仔细阅读了一下觉得应该在自己的路由里面设置的。尝试了一下果然如此。</p>
<p>原图</p>
<p><img src="http://www.maclife.com/files/u12635/ssh_router_setting_0.png" alt="原图"></p>
<p>我设置的真相</p>
<p><img src="http://ww1.sinaimg.cn/large/a74eed94jw1e2vk1nmz9wj.jpg" alt="设置的真相"></p>
<p>注意的一点是IP地址填写的是你刚刚设置自己的固定IP地址。端口两个都是22，因为ssh用的是22端口。</p>
<h3>OS X上打开SSH Share</h3>
<p>其实很简单</p>
<p><img src="http://ww3.sinaimg.cn/large/bfadf3bejw1e2vk4y5jocj.jpg" alt="设置1"></p>
<p><img src="http://ww4.sinaimg.cn/large/a74ecc4cjw1e2vk5i19dcj.jpg" alt="设置2"></p>
<h3>打完收工</h3>
<p>测试， 我连上我的vps 然后在vps上连接我的mac</p>
<p><img src="http://ww1.sinaimg.cn/large/a74e55b4jw1e2vkau1lsxj.jpg" alt="测试"></p>
<h2>总结</h2>
<p>基础差害死人阿，通过这些小事情。证明了我还有很多需要学习的地方。</p>
<p>厦门，晚安。睡觉，又过12点了。</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/Mac/" term="Mac"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(17)]]></title>
    <link href="http://iiiyu.com/2013/03/11/learning-ios-notes-seventeen/"/>
    <id>http://iiiyu.com/2013/03/11/learning-ios-notes-seventeen/</id>
    <published>2013-03-11T15:18:49.000Z</published>
    <updated>2013-03-11T16:20:33.000Z</updated>
    <content type="html"><![CDATA[<h1>iOS读写文件</h1>
<h2>序</h2>
<p>由于iOS App的机制和限定，我们在App里面的权限就仅限于App内部。这个打包好的内部称为沙箱。沙箱有利有弊。我觉得这个世界上没有绝对的好坏。虽然沙箱的作用限制了一些功能的实现。但是也确保了iPhone的安全机制。对于普通用户来说我觉得的利大于弊的。(MAS上架的软件也接受这一约束)</p>
<h2>第一步 路径</h2>
<p>不管是读文件还是写文件我们都要需要知道文件的位置。这个位置在iOS里面就是沙箱的Document文件夹的位置。关于沙箱里面各个文件夹的功能和作用。Apple的某文档里面写的很清楚建议Google以后详细查看（懒得去找来贴了）。获取代码如下：</p>
<figure class="highlight lang-objc"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="title">NSArray</span>  *paths              = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
<span class="title">NSString</span> *documentsDirectory = [paths objectAtIndex:<span class="number">0</span>];
</pre></td></tr></table></figure>

<p>NSDocumentDirectoryz这个参数你点过去可以找到一堆类似的定义比如常用的NSLibraryDirectory，NSApplicationDirectory。这样就可以直接获取到对应的文件夹路径。其他的你照抄就好。想知道意思就点过去看呗。其实看变量名也可以猜测一二。</p>
<figure class="highlight lang-objc"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>NSString <span class="variable">*filePath</span> = [documentsDirectory stringByAppendingString:<span class="variable">@"</span>/hello.txt<span class="string">"];
</pre></td></tr></table></figure>

<p>然后我们加上我们文件名字构成一个完整的路径。注意文件名字前有一个/。</p>
<p>这样我们就获得一个文件路径了。</p>
<a id="more"></a>

<h2>第二步 检查文件是否存在</h2>
<p>我们有了文件的路径以后，想读取。是可以。但是要是文件不存在，我们硬来就读取不到任何东西。所以，一般的做法是在读取之前去检查一下这个路径的文件是否存在。如果不存在我们就可以作出相应的处理动作。</p>
<figure class="highlight lang-objc"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];
<span class="comment">//检查文件是否存在</span>
<span class="keyword">if</span>([fileManager fileExistsAtPath:filePath]) {
	<span class="comment">// 做存在的事情</span>
}<span class="keyword">else</span>{
	<span class="comment">// 做不存在的事情</span>
}
</pre></td></tr></table></figure>

<h2>第三步 读取文件</h2>
<p>如果文件存在我们就可以读出文件内容。常用以下几种</p>
<figure class="highlight lang-objc"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="comment">//读取为二进制</span>
NSData *myData = [NSData dataWithContentsOfFile:filePath];
<span class="keyword">if</span>(myData) {
    <span class="comment">// do something useful</span>
}
<span class="comment">//读取为String</span>
<span class="built_in">NSString</span> *myString = [[<span class="built_in">NSString</span> alloc] initWithContentsOfFile:filePath encoding:NSStringEncodingConversionAllowLossy error:<span class="literal">nil</span>];
<span class="keyword">if</span>(myString) {
	<span class="comment">// do something useful</span>
}
<span class="comment">//如果是一个Plist，可以读取为字典</span>
<span class="built_in">NSDictionary</span> *myDictionary = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithContentsOfFile:filePath];
<span class="keyword">if</span>(myDictionary) {
	<span class="comment">// do something useful</span>
}
</pre></td></tr></table></figure>

<h2>第四步 写入文件</h2>
<p>如果我们有内容要存入文件。常用一下几种</p>
<figure class="highlight lang-objc"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>//写入二进制内容
[myData <span class="method">writeToFile:</span>filePath <span class="method">atomically:</span><span class="class">YES</span>];
//写入<span class="class">String</span>
[myString <span class="method">writeToFile:</span>filePath <span class="method">atomically:</span><span class="class">YES</span> <span class="method">encoding:</span><span class="class">NSStringEncodingConversionAllowLossy</span> <span class="method">error:</span><span class="keyword">nil</span>];
//写入<span class="class">Plist</span>
[myDictionary <span class="method">writeToFile:</span>filePath <span class="method">atomically:</span><span class="class">YES</span>];
</pre></td></tr></table></figure>

<p>值得注意的是参数中YES的意思为如果为YES则保证文件的写入原子性,就是说会先创建一个临时文件,成功了就改名为正式的文件。如果为NO,直接写入目标文件目录里.writeToFile:atomically:的这个方法都为覆盖。如果想要是追加的效果。建议先读出原文件内容然后在后面加入新内容。最后一起写入。这样就覆盖了老的文件。</p>
<h2>总结</h2>
<p>之前一直想写的blog想深入一些。以至于不敢动手开始写。总觉得还没有准备好。自己也懂的不够透彻。这样不知不觉欠了几十篇blog了。在todo list里面都要变成谍中谍了。最近关注了几个微信公众帐号。见到人家天天画时间去更新。比我优秀的人比我更加努力。惭愧的很。所以现在就拿着简单的内容写起来。</p>
<pre><code>故不积 跬步，无以至千里；不积小流，无以成江海。</code></pre>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(16)]]></title>
    <link href="http://iiiyu.com/2013/03/01/learning-ios-notes-sixteen/"/>
    <id>http://iiiyu.com/2013/03/01/learning-ios-notes-sixteen/</id>
    <published>2013-02-28T18:38:47.000Z</published>
    <updated>2013-04-22T09:35:13.000Z</updated>
    <content type="html"><![CDATA[<h1>配置自己的CocoaPods库</h1>
<h2>序</h2>
<p>默认安装的cocoapods确实很好用，可是毕竟自己会写一些库和修改一些第三方库来用。所幸cocoapods确实是一个神器。他可以定义自己的库来用。<br>如何安装Cocoapods，<a href="http://iiiyu.com/2013/03/01/learning-ios-notes-sixteen/">请参考这篇</a></p>
<a id="more"></a>

<h2>从头来设置</h2>
<h3>应用场景</h3>
<p>我的boss写了一个基于MagicalRecord的CoreData的iCloud设置的类。也许我们以后要用到的机会毕竟多。单独拿出来成为一个库。现在用cocoapods来做成一个静态库。 我们这个库基于外部的MagicalRecord和SVProgressHUD.这两个库是用git submodule的方法来管理的</p>
<h4>第一步把代码托管到一个支持git的服务器</h4>
<p>我选择了<a href="https://bitbucket.org" target="_blank">bitbucket</a>.因为没钱买github。</p>
<h4>第二步删除git submodule</h4>
<p>git submodule虽然也可以实现第三方库的管理，但是相对于cocoapods来说太麻烦了。删除就不是想cocoapods这样在Podfile里面删除配置就好的。</p>
<p><strong>先删掉目录</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">$git</span> <span class="comment">rm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">cached</span> <span class="comment">Vendor/MagicalRecord</span> 
<span class="comment">$git</span> <span class="comment">rm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">cached</span> <span class="comment">Vendor/SVProgressHUD</span>
<span class="comment">$rm</span> <span class="literal">-</span><span class="comment">rf</span> <span class="comment">Vendor
</pre></td></tr></table></figure>

<p><strong>删掉.gitmodules</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$rm</span> .gitmodules
</pre></td></tr></table></figure>

<p><strong>修改.git/config</strong></p>
<p>把MagicalRecord和SVProgressHUD的条目删除</p>
<p><strong>最后commit一下</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">$</span> <span class="comment">git</span> <span class="comment">add</span> <span class="string">.</span>
<span class="comment">$</span> <span class="comment">git</span> <span class="comment">commit</span> <span class="literal">-</span><span class="comment">m</span> <span class="comment">"Remove</span> <span class="comment">a</span> <span class="comment">submodule"
</pre></td></tr></table></figure>

<h4>第三步为原来的项目添加cocoapods支持</h4>
<p><strong>先把项目里面引用submodule的地方删除</strong></p>
<p><strong>添加Podfile到项目目录里面</strong></p>
<p>内容为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>platform :ios,  '<span class="number">6.0</span>'
pod <span class="attribute">'MagicalRecord</span>', :git =&gt; <span class="attribute">'https</span>://github.com/iiiyu/MagicalRecord.git', :tag =&gt; <span class="attribute">'sumiGridDiary2</span><span class="number">.1</span>'
pod <span class="attribute">'SVProgressHUD</span>'
</pre></td></tr></table></figure>

<p>解释一下：<br>第一行后面是限制模拟器版本为6.0以上。<br>第二行因为MagicalRecord我们改了几行代码，因此用我们自己的版本。指定git地址。和tag标签。除了tag还可以指定branch和commit。格式一样<br>第三行用官方的最新版本</p>
<p><strong>安装Pod</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$pod</span> install
</pre></td></tr></table></figure>

<p>我的安装结束以后提示</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>[!] The target `SIStore [Debug - Release]' overrides <span class="keyword">the</span> `HEADER_SEARCH_PATHS' build setting defined <span class="keyword">in</span> `Pods/Pods.xcconfig'.
    - Use <span class="keyword">the</span> `$(inherited)' flag, <span class="keyword">or</span>
    - Remove <span class="keyword">the</span> build settings <span class="keyword">from</span> <span class="keyword">the</span> target.
</pre></td></tr></table></figure>

<p>按照提示修改项目的Build Settings就ok了。</p>
<p><strong>进入项目中把之前是包入“”的第三方头文件地方改为&lt;&gt;</strong></p>
<p><strong>添加.gitignore</strong></p>
<p>.gitignore内容为</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">*</span>.<span class="comment">xcodeproj/*</span>
<span class="comment">!*</span>.<span class="comment">xcodeproj/project</span>.<span class="comment">pbxproj</span>
<span class="comment">build</span>
<span class="string">.</span><span class="comment">DS_Store</span>
<span class="string">.</span><span class="comment">_*</span>
<span class="string">.</span><span class="comment">svn</span>
<span class="comment">*</span>.<span class="comment">xcworkspace</span>
<span class="comment">Pods</span>
<span class="comment">Podfile</span>.<span class="comment">lock
</pre></td></tr></table></figure>

<p>打完收工。</p>
<p>这样就之前的库就可以跑在cocoapods的配置下了</p>
<h4>第四步创建自己的Podspec文件</h4>
<p>初始化一个Podspec文件</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$pod spec <span class="operator"><span class="keyword">create</span> SIStore
</pre></td></tr></table></figure>

<p>SIStore.podspec内容如下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
</pre></td><td class="code"><pre><span class="preprocessor">#</span>
<span class="preprocessor"># Be sure to run `pod spec lint SIStore.podspec' to ensure this is a</span>
<span class="preprocessor"># valid spec.</span>
<span class="preprocessor">#</span>
<span class="preprocessor"># Remove all comments before submitting the spec. Optional attributes are commented.</span>
<span class="preprocessor">#</span>
<span class="preprocessor"># For details see: https://github.com/CocoaPods/CocoaPods/wiki/The-podspec-format</span>
<span class="preprocessor">#</span>
Pod::Spec.<span class="keyword">new</span> <span class="keyword">do</span> |s|
  s.name         = <span class="string">"SIStore"</span>
  s.version      = <span class="string">"0.0.1"</span>
  s.summary      = <span class="string">"A short description of SIStore."</span>
  <span class="preprocessor"># s.description  = &lt;&lt;-DESC</span>
  <span class="preprocessor">#                   An optional longer description of SIStore</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor">#                   * Markdown format.</span>
  <span class="preprocessor">#                   * Don't worry about the indent, we strip it!</span>
  <span class="preprocessor">#                  DESC</span>
  s.homepage     = <span class="string">"http://EXAMPLE/SIStore"</span>

  <span class="preprocessor"># Specify the license type. CocoaPods detects automatically the license file <span class="keyword">if</span> it is named</span>
  <span class="preprocessor"># `LICEN{C,S}E*.*', however <span class="keyword">if</span> the name is different, specify it.</span>
  s.license      = <span class="string">'MIT (example)'</span>
  <span class="preprocessor"># s.license      = { :type =&gt; 'MIT (example)', :file =&gt; 'FILE_LICENSE' }</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># Only <span class="keyword">if</span> no dedicated file is available include the full text of the license.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># s.license      = {</span>
  <span class="preprocessor">#   :type =&gt; 'MIT (example)',</span>
  <span class="preprocessor">#   :text =&gt; &lt;&lt;-LICENSE</span>
  <span class="preprocessor">#             Copyright (C) &lt;year&gt; &lt;copyright holders&gt;</span>

  <span class="preprocessor">#             All rights reserved.</span>

  <span class="preprocessor">#             Redistribution and use in source and binary forms, with or without</span>
  <span class="preprocessor">#             ...</span>
  <span class="preprocessor">#   LICENSE</span>
  <span class="preprocessor"># }</span>

  <span class="preprocessor"># Specify the authors of the library, with email addresses. You can often find</span>
  <span class="preprocessor"># the email addresses of the authors by using the SCM log. E.g. $ git log</span>
  <span class="preprocessor">#</span>
  s.author       = { <span class="string">"Xiao ChenYu"</span> =&gt; <span class="string">"apple.iiiyu@gmail.com"</span> }
  <span class="preprocessor"># s.authors      = { "Xiao ChenYu" =&gt; "apple.iiiyu@gmail.com", "other author" =&gt; "and email address" }</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># If absolutely no email addresses are available, then you can use this form instead.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># s.author       = 'Xiao ChenYu', 'other author'</span>

  <span class="preprocessor"># Specify the location from where the source should be retrieved.</span>
  <span class="preprocessor">#</span>
  s.source       = { :git =&gt; <span class="string">"http://EXAMPLE/SIStore.git"</span>, :tag =&gt; <span class="string">"0.0.1"</span> }
  <span class="preprocessor"># s.source       = { :svn =&gt; 'http://EXAMPLE/SIStore/tags/1.0.0' }</span>
  <span class="preprocessor"># s.source       = { :hg  =&gt; 'http://EXAMPLE/SIStore', :revision =&gt; '1.0.0' }</span>

  <span class="preprocessor"># If this Pod runs only on iOS or OS X, then specify the platform and</span>
  <span class="preprocessor"># the deployment target.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># s.platform     = :ios, '5.0'</span>
  <span class="preprocessor"># s.platform     = :ios</span>

  <span class="preprocessor"># ――― MULTI-PLATFORM VALUES ――――――――――――――――――――――――――――――――――――――――――――――――― #</span>

  <span class="preprocessor"># If this Pod runs on both platforms, then specify the deployment</span>
  <span class="preprocessor"># targets.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># s.ios.deployment_target = '5.0'</span>
  <span class="preprocessor"># s.osx.deployment_target = '10.7'</span>

  <span class="preprocessor"># A list of file patterns which select the source files that should be</span>
  <span class="preprocessor"># added to the Pods project. If the pattern is a directory then the</span>
  <span class="preprocessor"># path will automatically have '*.{h,m,mm,c,cpp}' appended.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># Alternatively, you can use the FileList class for even more control</span>
  <span class="preprocessor"># over the selected files.</span>
  <span class="preprocessor"># (See http://rake.rubyforge.org/classes/Rake/FileList.html.)</span>
  <span class="preprocessor">#</span>
  s.source_files = <span class="string">'Classes'</span>, <span class="string">'Classes/**/*.{h,m}'</span>

  <span class="preprocessor"># A list of file patterns which select the header files that should be</span>
  <span class="preprocessor"># made available to the application. If the pattern is a directory then the</span>
  <span class="preprocessor"># path will automatically have '*.h' appended.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># Also allows the use of the FileList class like `source_files' does.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># If you do not explicitly set the list of public header files,</span>
  <span class="preprocessor"># all headers of source_files will be made public.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># s.public_header_files = 'Classes/**/*.h'</span>

  <span class="preprocessor"># A list of resources included with the Pod. These are copied into the</span>
  <span class="preprocessor"># target bundle with a build phase script.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># Also allows the use of the FileList class like `source_files' does.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># s.resource  = "icon.png"</span>
  <span class="preprocessor"># s.resources = "Resources/*.png"</span>

  <span class="preprocessor"># A list of paths to preserve after installing the Pod.</span>
  <span class="preprocessor"># CocoaPods cleans by default any file that is not used.</span>
  <span class="preprocessor"># Please don't include documentation, example, and test files.</span>
  <span class="preprocessor"># Also allows the use of the FileList class like `source_files' does.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># s.preserve_paths = "FilesToSave", "MoreFilesToSave"</span>

  <span class="preprocessor"># Specify a list of frameworks that the application needs to link</span>
  <span class="preprocessor"># against for this Pod to work.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># s.framework  = 'SomeFramework'</span>
  <span class="preprocessor"># s.frameworks = 'SomeFramework', 'AnotherFramework'</span>

  <span class="preprocessor"># Specify a list of libraries that the application needs to link</span>
  <span class="preprocessor"># against for this Pod to work.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># s.library   = 'iconv'</span>
  <span class="preprocessor"># s.libraries = 'iconv', 'xml2'</span>

  <span class="preprocessor"># If this Pod uses ARC, specify it like so.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># s.requires_arc = true</span>

  <span class="preprocessor"># If you need to specify any other build settings, add them to the</span>
  <span class="preprocessor"># xcconfig hash.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># s.xcconfig = { 'HEADER_SEARCH_PATHS' =&gt; '$(SDKROOT)/usr/include/libxml2' }</span>

  <span class="preprocessor"># Finally, specify any Pods that this Pod depends on.</span>
  <span class="preprocessor">#</span>
  <span class="preprocessor"># s.dependency 'JSONKit', '~&gt; 1.4'</span>
end
</pre></td></tr></table></figure>

<p>注释里面描写的很详细，建议全部看完</p>
<p>去掉注释版本</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>Pod::Spec.<span class="keyword">new</span> <span class="keyword">do</span> |s|
  s.name         = <span class="string">"SIStore"</span>
  s.version      = <span class="string">"0.0.1"</span>
  s.summary      = <span class="string">"A short description of SIStore."</span>
  s.homepage     = <span class="string">"http://EXAMPLE/SIStore"</span>
  s.license      = <span class="string">'MIT (example)'</span>
  s.author       = { <span class="string">"Xiao ChenYu"</span> =&gt; <span class="string">"apple.iiiyu@gmail.com"</span> }
  s.source       = { :git =&gt; <span class="string">"http://EXAMPLE/SIStore.git"</span>, :tag =&gt; <span class="string">"0.0.1"</span> }
  s.source_files = <span class="string">'Classes'</span>, <span class="string">'Classes/**/*.{h,m}'</span>
end
</pre></td></tr></table></figure>

<p>第一行和最后一行保留下来然后不管就好了</p>
<ul>
<li>s.name 声明库的名称</li>
<li>s.version 库的版本</li>
<li>s.summary 一个简短的说明文档</li>
<li>s.homepage 库的首页</li>
<li>s.license 库的协议</li>
<li>s.author 作者</li>
<li>s.source 原代码的地址</li>
<li>s.source_files 原代码的目录</li>
</ul>
<p>我们要认真填写的有s.name、s.version、s.source、s.source_files。我们有依赖其他库所以还要写s.dependency。还有一个bundle还要写s.resourcs。</p>
<p>最终的结果内容如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>Pod::Spec.<span class="keyword">new</span> <span class="keyword">do</span> |s|
  s.name         = <span class="string">"SIStore"</span>
  s.version      = <span class="string">"0.0.2"</span>
  s.summary      = <span class="string">"Sumi Interactive make a new CoreData and iCloud a Third-party library on MagicalRecord."</span>
  s.homepage     = <span class="string">"http://iiiyu.com"</span>
  s.license      = <span class="comment">'MIT'</span>
  s.author       = { <span class="string">"Xiao ChenYu"</span> =&gt; <span class="string">"apple.iiiyu@gmail.com"</span> }
  s.source       = { :git =&gt; <span class="string">"https://iiiyu@bitbucket.org/iiiyu/sistore.git"</span>, :tag =&gt; <span class="string">"0.0.2"</span> }
  s.source_files = <span class="comment">'SIStore/*.{h,m}'</span>
  s.preserve_paths  = <span class="comment">'SIStoreDemo'</span>
  s.resources    = <span class="comment">'SIStore/SIStore.bundle'</span>
  s.framework    = <span class="comment">'CoreData'</span>
  s.dependency <span class="comment">'MagicalRecord', :git =&gt; 'https://github.com/iiiyu/MagicalRecord.git', :tag =&gt; 'sumiGridDiary2.1'</span>
  s.dependency <span class="comment">'SVProgressHUD'</span>
  s.requires_arc = <span class="literal">true</span>
  s.platform     = :ios
<span class="keyword">end</span>
</pre></td></tr></table></figure>

<h2>坑</h2>
<p>cocoapods有缓存。 我一直测试刚刚搞好的自己的库一直不对。 改了2小时。 才反应过来我一直打的标签是同一个，然后cocoapods在本地缓存了一个。只对比了标签以至于我改的东西都没有用。哭。。。。</p>
<h2>参考文章</h2>
<p><a href="http://ishalou.com/blog/2012/10/16/how-to-create-a-cocoapods-spec-file/" target="_blank">如何编写一个CocoaPods的spec文件</a></p>
<p><a href="http://m.blog.csdn.net/blog/totogo2010/8198694" target="_blank">CocoaPods一个Objective-C第三方库的管理利器</a></p>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记 (15)]]></title>
    <link href="http://iiiyu.com/2013/02/22/learning-ios-notes-fifteen/"/>
    <id>http://iiiyu.com/2013/02/22/learning-ios-notes-fifteen/</id>
    <published>2013-02-22T10:31:10.000Z</published>
    <updated>2013-02-25T09:46:00.000Z</updated>
    <content type="html"><![CDATA[<h1>Mogenerator的初级使用</h1>
<h2>什么是Mogenerator</h2>
<p>最近在用Core Data来进行开发。Core Data其实封装的很好了。把存储底层都屏蔽了（sqlite，xml，内存）。不管是用那种方式存储下来。用Core Data都是在操作对象了。但是Core Data一套东西下来，单是学习就学习的泪流满面。天资有限，只能找一些看上去更简单的第三方类库来使用。</p>
<p>github上找了很久，最后在使用的是<a href="https://github.com/magicalpanda/MagicalRecord" target="_blank">MagicalRecord</a>。不为其他，只是用起来很爽。特别是目前升级到了2.1版本以后，保存的方法名字不那么逆天了。更是好用多了。</p>
<p>而<a href="http://rentzsch.github.com/mogenerator/" target="_blank">Mogenerator</a>是什么东西呢。</p>
<p>它漂亮的主页上是这样写的：</p>
<p>mogenerator为你定义了的Core Data生成默认的数据类。与xCode不一样的是(xCode一个Entity只生成一个NSManagedObject的子类)，mogenerator会为每一个Entity生成两个类。一个为机器准备，一个为人类准备。为机器准备的类一直去匹配data model。为人类准备的类就给你轻松愉快的去修改和保存。</p>
<a id="more"></a>

<h2>为什么需要Mogenerator</h2>
<h2>安装Mogenerator</h2>
<p>Mogenerator其实是一个命令行的工具，因此也就可以轻松愉快的用<a href="http://mxcl.github.com/homebrew" target="_blank">homebrew</a>去安装。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>brew install mogenerator
</pre></td></tr></table></figure>

<p>升级</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ brew <span class="operator"><span class="keyword">update</span> && brew upgrade mogenerator
</pre></td></tr></table></figure>

<h2>在项目里面添加Mogenerator</h2>
<p>按照<a href="http://raptureinvenice.com/getting-started-with-mogenerator/" target="_blank">这篇</a>的教程我添加了脚本以后运行不成功</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="title">cd</span> testMogenerator
<span class="title">mogenerator</span> -m myDataBase.xcdatamodeld/myDataBase.xcdatamodel/
</pre></td></tr></table></figure>

<p>提示:</p>
<pre><code>/Volumes/Data/iYu/<span class="keyword">Library</span>/Developer/Xcode/DerivedData/testMogenerator-adwdmrbsvjjxqtawmqvnhfdhubts/Build/Intermediates/testMogenerator.build/Debug-iphonesimulator/Mogenerator.build/Script-<span class="number">5</span>B80B84A16D9EC8F00E8E3A3.sh: line <span class="number">3</span>: mogenerator: command <span class="keyword">not</span> found Command /bin/sh failed <span class="keyword">with</span> <span class="keyword">exit</span> code <span class="number">127</span></code></pre>
<p>自己打命令测试Mogenerator是成功的</p>
<p><img src="http://ww2.sinaimg.cn/large/a74ecc4cjw1e24hzzauvbj.jpg" alt="测试Mogenerator"></p>
<p>xCode使用的是/bin/sh,我怀疑是用homebrew安装的以后的Path跟xCode的/bin/sh/执行的</p>
<p>思考以后在命令之前之前导入mogenerator的路径。 由于我是用homebrew按照的自然在homebrew的路径下面</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="title">cd</span> testMogenerator
<span class="title">export</span> <span class="type">PATH</span>=<span class="string">"/usr/local/Cellar/mogenerator/1.27/bin:$PATH"</span>
<span class="title">mogenerator</span> -m myDataBase.xcdatamodeld/myDataBase.xcdatamodel/
</pre></td></tr></table></figure>

<p>这次mogenerator是找到了，但是xcadatamodeld又没有找到。看到</p>
<pre><code>mogenerator: <span class="keyword">error</span> loading <span class="type">file</span> <span class="keyword">at</span> myDataBase.xcdatamodeld/myDataBase.xcdatamodel/: no such <span class="type">file</span> exists Command /bin/sh failed <span class="keyword">with</span> <span class="keyword">exit</span> code <span class="number">66</span></code></pre>
<p>pwd出来路径观察以后把cd去掉</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">export</span> PATH=<span class="string">"/usr/local/Cellar/mogenerator/1.27/bin:$PATH"</span>
mogenerator -m myDataBase<span class="variable">.xcdatamodeld</span>/myDataBase<span class="variable">.xcdatamodel</span>/
</pre></td></tr></table></figure>

<p>这次就对了</p>
<h2>使用Mogenerator</h2>
<p>我创建了一个叫testMogenerator的工程并且在工程的data model名字叫myDataBase 如图：</p>
<p><img src="http://ww2.sinaimg.cn/large/a74ecc4cjw1e25ps57szwj.jpg" alt=""></p>
<p>mogenerator安装以后是这样的</p>
<p><img src="http://ww4.sinaimg.cn/large/a74e55b4jw1e25pnfghgpj.jpg" alt=""></p>
<p>然后安command+B 运行一下这个target。</p>
<p>运行以后生成的文件在这里</p>
<p><img src="http://ww4.sinaimg.cn/large/a74ecc4cjw1e25pk5ribkj.jpg" alt=""></p>
<p>PS: 第一次生成的文件位置不对。所以脚本又改了一下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">cd</span> <span class="comment">testMogenerator</span>
<span class="comment">export</span> <span class="comment">PATH="/usr/local/Cellar/mogenerator/1</span>.<span class="comment">27/bin:$PATH"</span>
<span class="comment">mogenerator</span> <span class="literal">-</span><span class="comment">m</span> <span class="string">.</span><span class="string">.</span><span class="comment">/myDataBase</span>.<span class="comment">xcdatamodeld/myDataBase</span>.<span class="comment">xcdatamodel/
</pre></td></tr></table></figure>

<p>每一个Entity生成了两个类 一个Entity的名字的类， 一个下划线Entity的名字的类。_XXXX.*这个类不要去修改，修改XXXX这个类就好了。</p>
<p>如果是一个新的entity，需要你自己加入自己的工程里面工程，如果Entity已经加入现在只是更新了Entity的话。就不用加入工程了。</p>
<p><img src="http://ww3.sinaimg.cn/large/a74eed94jw1e25q0ub23qj.jpg" alt=""></p>
<p>最后编译的时候还是不对 脚本继续改 囧</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="comment">cd</span> <span class="comment">testMogenerator</span>
<span class="comment">export</span> <span class="comment">PATH="/usr/local/Cellar/mogenerator/1</span>.<span class="comment">27/bin:$PATH"</span>
<span class="comment">mogenerator</span> <span class="literal">-</span><span class="comment">m</span> <span class="string">.</span><span class="string">.</span><span class="comment">/myDataBase</span>.<span class="comment">xcdatamodeld/myDataBase</span>.<span class="comment">xcdatamodel/</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">template</span>-<span class="comment">var</span> <span class="comment">arc=YES
</pre></td></tr></table></figure>

<h2>总结</h2>
<p>断断续续折腾了两天。大概明白了mogenerator怎么一个事情。但是好用好还有带研究。这篇blog先发吧。不然又难产了。</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[2013 一月读书笔记]]></title>
    <link href="http://iiiyu.com/2013/02/02/january-reading-noteb/"/>
    <id>http://iiiyu.com/2013/02/02/january-reading-noteb/</id>
    <published>2013-02-01T18:42:01.000Z</published>
    <updated>2013-02-03T10:03:05.000Z</updated>
    <content type="html"><![CDATA[<h1>2013 一月读书笔记</h1>
<p>2013的一月嗖一下就过去了，都还没有反应过来，在过几天就回家过年了果然时间入流水阿。</p>
<p>看看之前的blog，上一篇也是唯一的一篇读书笔记刚刚好是2012的。随带检讨一下自己的懒惰。</p>
<p>之前用的Octopress，不知为什么我手贱update了一下就各种错误。搞了两天也不明白问题在哪里。 那会还有写点东西的冲动。给我急的阿。后来想起在<a href="http://lucifr.com" target="_blank">@Lucifr</a>blog里面见过一个类似的框架，跟过去看了看。原来是之前见过的台湾小朋友写的Octopress主题Slash的作者<a href="http://zespia.tw" target="_blank">@tommy351</a>新项目<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>。果然自古英雄出少年阿。感谢<a href="http://zespia.tw" target="_blank">@tommy351</a>的<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>。</p>
<p>现在我的blog生产静态html的框架用的是<a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> 强烈推荐。</p>
<p>一月我以极快的速度翻完了三本书。 「打造Facebook」 「看见」 「全世界人民都知道」</p>
<a id="more"></a>

<h2>打造Facebook</h2>
<p>这本书我购入多看电子版。起初我看这本书很多人在推荐。就想入了一本。点到书的内容介绍里面一看。各种李开复、薛蛮子联袂推荐。顿时拉入黑名单中。结果微博上几个靠谱的人还在推荐。曹哥也说已经看了一半感觉还好的情况下。就入了电子版。(PS:貌似那会儿在特价)</p>
<p>通篇读下来就是个人打工体会。 干货确实有。但是也无法重现Facebook不是么</p>
<p>推荐指数 3星</p>
<h2>看见</h2>
<p>CCTV里面我待见的主持人不多(ps:已经多少年没有看过CCTV的人了，浑氮。你能待见谁)。女主持更不多了。 印象中就两一个是柴静，另外一个连名字都不知道就记得带一个眼睛播报过天气预报笑容甜美的妹子。看过柴静节目里面的内容都忘记差不多了，记忆里面就知道她坐着一个问题一个问题问对面的人。虽然感觉上咄咄逼人的样子，可是反而感觉是一个有自己独立思考和智慧的人。这样的人我看着顺眼。本来预售的时候就想买了，但是我想买电子版。还在微博上问了多看官方帐号。然后他们的副总说这本书有难度，才去亚马逊上下单。（PS：昨天躺在床上翻多看发现有「看见」的试读版本了。这是什么情况）</p>
<p>「看见」的封面我觉得很好，柴静微笑的坐在一群朴实的天朝公民中，笑容清澈见底，旁边有老人和孩子。这书名根据内容看下来也感觉很好。因为都是柴静的亲眼所见。从这本书里面，我隐约看见某腐朽的帝国主义的某电视剧<a href="http://movie.douban.com/subject/6142597/" target="_blank">「The Newsroom」</a>的样子。让我感慨出来CCTV也是有一群有良知的人儿阿。这本书其实算柴静的一个小自传 or 十年的工作史。如果我给起名字的话——「给黑心矿老板CCTV打工的血泪史」。希望寄托一个开心的名字能冲淡一些书中的悲伤。</p>
<p>看见是一本好书因为里面写了人性和理性。 </p>
<p>推荐指数 5星</p>
<h2>全世界人民都知道</h2>
<p>本来应该跟看见一起买的，结果下单的时候忘记了。后来为了凑够免邮费。又搞了一本韩寒的什么书。(什么书还真忘记了。没看的欲望) 本来我以为今年看过最好的中文非技术书应该是「看见」了。「全世界人民都知道」带给我的比「看见」更多。很早认识李承鹏是写足球的。后来多少看过一些他的事，微博什么。实在觉得是一个好人。一直到这本书发售的各种事情。都暗示着这人肯定很靠谱。那书应该也不差。而且有这么欢乐的发售会。肯定会买一本过来看看。</p>
<p>里面写了他为什么要转变的原因。里面写的事情，我都有过想法。但是他写的更加直白深刻，却又那么容易看懂。我只用了几个小时就全部扫完。有种酣畅淋漓的感觉。</p>
<p>推荐指数 5+星</p>
<h2>总结</h2>
<p>我看来 三本书都是写人。</p>
<p>「打造Facebook」说做互联网，最重要的是人。只有一流的人才能做出一流的产品出来。所以Facebook只找最好的人。</p>
<p>「看见」说的是个人。以柴静的眼，人性的眼去看待这个世界。</p>
<p>「全世界人民都知道」还是说的是人。人构成了这个世界，而这个世界有问题了。最后反射到具体的每一个人身上。<br>«</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/read book notes/" term="read book notes"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[简单配置PonyDebugger]]></title>
    <link href="http://iiiyu.com/2013/01/14/simple-configuration-ponydebugger/"/>
    <id>http://iiiyu.com/2013/01/14/simple-configuration-ponydebugger/</id>
    <published>2013-01-13T17:36:00.000Z</published>
    <updated>2013-02-01T18:37:18.000Z</updated>
    <content type="html"><![CDATA[<h2>前言</h2>
<p>iOS的Debug 系统在github上还是有不少。 PonyDebugger是看上去比较牛气的一个。尝试一下</p>
<p><img src="https://github.com/square/PonyDebugger/raw/master/Documentation/Images/Logo.png" alt="Logo"></p>
<p>PonyDebugger</p>
<p>可以监控网络</p>
<p><img src="https://github.com/square/PonyDebugger/raw/master/Documentation/Images/NetworkDebugging.png" alt="NetworkTrafficDebugging"></p>
<p>还可以查看Core Data对象</p>
<p><img src="https://github.com/square/PonyDebugger/raw/master/Documentation/Images/CoreDataBrowser.png" alt="CoreDataBrowser"></p>
<p>view的层级查看</p>
<p><img src="https://github.com/Flipboard/PonyDebugger/raw/master/Documentation/Images/ViewHierarchyDebugging.png" alt="ViewHierarchyDebugging"></p>
<p>这种好东西。 让我们快速开始吧。</p>
<a id="more"></a>



<h2>快速开始</h2>
<h3>服务器端</h3>
<ul>
<li><strong>1.</strong> 安装 Xcode&#39;s Command Line Tools </li>
<li><strong>2.</strong> 在shell里面执行下面命令</li>
</ul>
<figure class="highlight lang-sh"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>curl -sk <span class="symbol">https:</span>/<span class="regexp">/cloud.github.com/downloads</span><span class="regexp">/square/</span><span class="constant">PonyDebugger</span>/bootstrap-ponyd.py | \
  python - --ponyd-symlink=<span class="regexp">/usr/local</span><span class="regexp">/bin/ponyd</span> ~<span class="regexp">/Library/</span><span class="constant">PonyDebugger</span>
</pre></td></tr></table></figure>

<ul>
<li><strong>3.</strong> 安装成功以后，在shell里面执行</li>
</ul>
<figure class="highlight lang-sh"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">ponyd</span> serve --listen-interface=<span class="number">127.0.0.1</span>
</pre></td></tr></table></figure>

<ul>
<li><p><strong>4.</strong> 打开你的浏览器 输入地址</p>
<p>  <a href="http://localhost:9000" target="_blank">http://localhost:9000</a></p>
</li>
</ul>
<p>如果看见的是这样<br><img src="http://ww4.sinaimg.cn/large/a74ecc4cjw1e0sfa4zcdkj.jpg" alt="test1"><br>说明服务器端已经安装好了。</p>
<h3>iOS端</h3>
<ul>
<li><strong>1.</strong> 把PonyDebugger作为你自己的项目的一个git submodule添加到你自己的项目里面</li>
</ul>
<figure class="highlight lang-sh"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="title">cd</span> /path/to/<span class="type">YourApplication</span>
<span class="title">mkdir</span> <span class="type">Frameworks</span>
<span class="title">git</span> submodule add git://github.com/square/<span class="type">PonyDebugger</span>.git <span class="type">Frameworks</span>/<span class="type">PonyDebugger</span>
<span class="title">git</span> submodule update <span class="comment">--init --recursive</span>
</pre></td></tr></table></figure>

<p>PonyDebugger依赖于<a href="https://github.com/square/SocketRocket" target="_blank">SocketRocket</a>所以当你update的时候也会把SocketRocket一起clone下来。</p>
<ul>
<li><strong>2.</strong> 然后把PonyDebugger/PonyDebugger.xcodeproj 增加到你的项目里面去。</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/a74eed94jw1e0sfjqiz56j.jpg" alt=""></p>
<p><img src="https://github.com/square/PonyDebugger/raw/master/Documentation/Images/Installing_Subproject.png" alt=""></p>
<ul>
<li><strong>3.</strong> 在你的Project Settings里面的Build Phases标签里面把PonyDebugger作为Target Dependency的一个添加进去</li>
</ul>
<p><img src="https://github.com/square/PonyDebugger/raw/master/Documentation/Images/Installing_TargetDependencies.png" alt=""></p>
<ul>
<li><strong>4.</strong> 链接libPonyDebugger.a和libSocketRocket.a</li>
</ul>
<p><img src="https://github.com/square/PonyDebugger/raw/master/Documentation/Images/Installing_LinkLibraries.png" alt=""></p>
<ul>
<li><strong>5.</strong> 添加link参数-Objc</li>
</ul>
<p><img src="https://github.com/square/PonyDebugger/raw/master/Documentation/Images/Installing_OtherLinkerFlags.png" alt=""></p>
<ul>
<li><strong>6.</strong> 最后 检查一下你项目的Framework有没有以下Framework如果没有添加一下（包括libPonyDebugger.a和libSocketRocket.a）</li>
</ul>
<p>libicucore.dylib</p>
<p>CFNetwork.framework</p>
<p>CoreData.framework</p>
<p>Security.framework</p>
<p>Foundation.framework</p>
<p>到这里环境就配置好了，下面就来用把。 </p>
<h2>使用</h2>
<h3>基本用法</h3>
<p>PDDebugger是一个单例 这样获得.</p>
<figure class="highlight lang-objc"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">PDDebugger</span> *debugger = [PDDebugger defaultInstance];
</pre></td></tr></table></figure>

<p>自己连接网络</p>
<figure class="highlight lang-objc"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">[debugger autoConnect]</span><span class="comment">;</span>
</pre></td></tr></table></figure>

<p>或者亲自指定服务器端 比如 ws://localhost:9000/device</p>
<figure class="highlight lang-objc"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>[debugger connectToURL:[NSURL URLWithString:<span class="variable">@"</span>ws:<span class="comment">//localhost:9000/device"]];</span>
</pre></td></tr></table></figure>

<p>关闭连接</p>
<figure class="highlight lang-objc"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="title">[debugger disconnect]</span><span class="comment">;</span>
</pre></td></tr></table></figure>

<p>更多用法 参考<br><a href="https://github.com/square/PonyDebugger" target="_blank">主页</a></p>
<p>这篇blog相当于简化翻译 囧。</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[2012年度总结]]></title>
    <link href="http://iiiyu.com/2013/01/01/2012-annual-summary/"/>
    <id>http://iiiyu.com/2013/01/01/2012-annual-summary/</id>
    <published>2013-01-01T11:39:00.000Z</published>
    <updated>2013-02-01T18:37:18.000Z</updated>
    <content type="html"><![CDATA[<h2>扯扯其他</h2>
<p>  又到了一年一度的年度总结了，以前怕写，觉得人生如同复印一般没啥好写的。今年今日却是想好好写一点总结。2012还是自己本命年，12年恰好是一个轮回。12岁那年升入初中，这样使我有机会认识了5个现在值得交心交肺一生的兄弟。虽然现在天各一方，也可能许久没有联系。但是我相信兄弟之间是不必多说什么的。如果没有认识你们，我可能没有这么豁达，开朗。在风华正茂的年纪，我认识你们，你们认识我，是我们的幸运。  2012世界末日年，年初的时候我很彷徨和焦躁。因为我不知道我要做什么，我想做什么。当初觉得自己就是想去做操作系统，什么都不管不顾的去了东莞。其实是毕业那会儿见识的东西不够多，看的书不够多，看问题并不够客观理智。我并看不出来我应该做什么，只觉得做操作系统说出来应该很cool的样子。然而自己其实对这个行业根本不懂。在昆明了四年，虽然互联网触及到了世界。但是在边疆却是跟一线IT距离太过于遥远。<br>  <a id="more"></a></p>
<p>  去东莞是抱着一腔热血去的，觉得能改变点什么。去了6个月以后才发现，其实我什么都改变不了。现实照进梦想，然后把梦想砸了个稀烂。有时候去了公司坐着，就想早点下班去踢球。颇有生活就像是一场强奸，既然你不能躲避，那就好好享受吧的意思。有两本书改变了我当时的心境——「浪潮之巅」「黑客与画家」。「浪潮之巅」告诉我不管IT或者是整个世界，都是一波一波的浪潮。如果在一个浪潮还没影子的时候入水，死。如果浪已经开始能看到形成的的时候入水，可以喝点剩汤吃点剩菜。如果浪已经达到顶峰的时候入水，死。如果是能在浪将起，但是还没有人能看出来的时候入水，就有机会站到浪潮的最高处。Apple是最屌的，硬深深的造出了一个移动互联网的大浪。我看到了浪起来了，所以那时候想趁还没有到最高点感觉去抢点剩菜吃吃。「黑客与画家」告诉我，能力够的话创业比打工好。年初的时候就想着辞职了，投入移动互联网的浪潮中。纠结的只是两个事情，一个是我其实并不会移动互联网的开发，甚至连互联网的开发技术都并不具备。二是并没有做满一年，跳槽是大忌。连一年都没有做满更是不是很好，会给人很浮躁的感觉。直接导致了年初的几个月白天在写linux c。晚上回来ruby iOS的乱弄。貌似精神分裂一般。也天天在想这个事情怎么弄。最后，我还是决定跟着感觉走吧。就辞职了。</p>
<p>  辞职的事情，一直觉得有些窘迫。因为那会儿项目比较紧需要人手的时候，我提出辞职，感觉就像逃兵一样。然后理由就扯了一个其他的，虽然是事实但是也并不是真正的原因。辞职是裸辞，决定破釜沉舟的去帝都找一个房子住下来，然后慢慢学iOS开发。然后一个月后在去找工作。</p>
<p>  直到我遇见了曹哥。在今天回头去看，只能说我的运气确实好了点。本来已经定了去帝都的机票了，结果我收到了一封Email然后加了曹哥的QQ我们聊了聊。曹哥就说要不来厦门当面谈谈把，我那是很是犹豫。虽然在V2EX上就看见招聘，第一是我认为那会儿其实我什么都不会。第二是萌小萌在帝都。这个距离也比较遥远。见我犹豫的时候，曹哥说没关系啊，就当来厦门旅游了。路费住宿报销就好了。士为知己者死，女为悦己者容。在江湖混讲究的就是义气二字。娱乐一下。 我推掉了去帝都的票，赶了火车来到厦门。</p>
<p>  厦门逛了逛，跟曹哥谈了谈。那会儿也不知曹哥是有多猛。毕竟我不是混互动广告的啊。只是觉得曹哥人很好，做东西很用心。对技术很成熟的看法。sumi工作室的环境简直就是我觉得现实中的最理想工作场所。如果留下来能做的肯定是接下来几年都能想做的东西。厦门整个城市的节奏也满好。然后曹哥也愿意手把手的教我。唯一的问题就是萌小萌在帝都。然后当天晚上我跟萌小萌说了一下情况。萌小萌决定支持我留在厦门的时候。感谢萌小萌的理解。这样2012我最后留在了厦门至今。</p>
<h2>工作状态</h2>
<p>也许是我的注意力和意志力的问题吧。100分满分。 同情分 友情分全部加加勉强能给一个60分。我的技术进步速度一直在拖沓在项目的进度。以至于需要停下整体进度来等我的部分完成。本来我应该可以做到80分以上的。可是一直顶多能及格的状态下上起伏。这是我人的问题，懒惰，不上进。</p>
<h2>blog状态</h2>
<p>计划中的blog更本就没有更新完。目测起码欠上了十几篇。完成率相当低。不及格。</p>
<h2>读书状态</h2>
<p>回去有时候都懒得看书了，不过还是断断续续看了一些。勉强70分。但是读书笔记写的少 扣10分。 勉强及格</p>
<h2>感情状态</h2>
<p>和萌小萌除了异地 一起都蛮好。2012的最后一天，wwl当爹了。我突然就很难想象我们在一起一人喝一打啤酒的时光。仿佛那些已经是不可重复的往事。一去不复返了。从小学到高中一直都是同学的张娟同学，在大四才开始谈第一恋爱的人——结婚了，并且在上海买了房子。意料之外，情理之中。我一直觉得结婚就是9块钱的事情而已。何时何地不可以。可惜只是我有情，妾无意啊。就暂时让wwl领先我两个等级咯。</p>
<h2>感谢</h2>
<p>2012要感谢一直让我为所欲为的父母。不管是去东莞去帝都去厦门。他们都一直支持我。尽管他们很想让我留在身边。可是我还是跟着我的心一直走并没理会他们的期望。感谢萌小萌，在她最好的年华里面陪在最一穷二白的我身边，支持我。感谢曹哥在我什么都不会的时候手把手一点一点教我。感谢巧玲姐陪我一起去看租房。感谢sumi的90后们。你们让我知道我之前的见识是有多土鳖。感谢海军教我做菜，一起喝酒。感谢对我好或对我坏的人们这样才能使得人生丰富多彩。感谢肠粉在平日里面带给我们的欢乐，虽然他现在去征服世界了。</p>
<p><strong>我，萧宸宇24岁时2013年1月1日这天，在厦门斗西路58号2楼。希望2013年大家都安好。Sumi必胜 Oh Yeah！</strong></p>
]]></content>
    <category scheme="http://iiiyu.com/categories/just-talk/" term="just-talk"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[为什么小米会成功]]></title>
    <link href="http://iiiyu.com/2012/12/16/why-the-xiaomi-will-be-successful/"/>
    <id>http://iiiyu.com/2012/12/16/why-the-xiaomi-will-be-successful/</id>
    <published>2012-12-16T07:40:00.000Z</published>
    <updated>2013-02-01T18:37:18.000Z</updated>
    <content type="html"><![CDATA[<h1>为什么小米会成功</h1>
<h2>正面</h2>
<h3>赶上了移动互联网这一波浪潮</h3>
<p>这是「浪潮之巅」里面的说法。很显然，互联网那一波浪潮已经不可能再变得更高了。而下一波的移动互联网大浪现在来看，已经是在像最高潮发展了。而小米进入这个市场的时间要比现在早那么2年多。那时候，移动互联网这个浪头已经被Apple带起来了,天朝的移动互联网远远没有现在这么竞争激烈。小米就进入了这个大潮流中。所以，小米能取得多大的成功，依赖着这波移动互联网的浪能打多高。我觉得这波移动互联网的浪头会很高，至少要超越互联网这波浪潮两倍的高度。小米肯定不可能是浪头的最高点，不过由于进入的时间比较早，只是追随着浪头，也能达到一个很成功的高度。对于这样一个企业来说。确实就是成功了。</p>
<a id="more"></a>

<h3>进行了C2C</h3>
<p>但凡在天朝成功的互联网企业很多带有C2C(Copy to China)的基因。究其缘由，第一、KK在「科技元素」里面说过。科技的发展在一段时期内是趋同发展的。何况在现在网络已经无处不在的时代。早上在硅谷出现的新鲜创意，晚上天朝可能就有人开始甩开膀子开干。第二、这里是天朝。</p>
<p>小米在模仿苹果。或许初期的小米并没有想要模仿，又或许小米的决策者们思考做的这些决策只是巧合的跟苹果的发神似。从强调小米是一个移动互联网公司开始，培养出一批big fans。到小米要自己做自己品牌的手机把软硬都控制到自己手里，到小米的发布会，到小米盒子，到小米商店（就是可以充值买主题那个我不太清楚是什么，只是记得看新闻看过）。每一步，其实都已经被Apple证明过实践过。我已经过了会相信巧合的年纪。我只能会说，这一切都是有人在刻意的去把小米运营成中国的苹果。大方向只要对，努力去做，去适应天朝的市场需求。小米会取得巨大的成功。会变成一个在中国最像Apple的公司。</p>
<h3>用心的做了产品</h3>
<p>小米是一个很年轻的公司。而且MIUI能保持长时间的每周一更新这真的很难得。老罗说过他自己为什么要做手机的历程，他去小米谈过一次，虽然雷军不是很感兴趣。但是另外一个高层对老罗的想法很感兴趣。所幸，多多少少反应出来，在小米有一帮人在踏踏实实做事情。在琢磨，在研究。所以，小米一直在进步不是么。MIUI真的算我在天朝能看见定制Android目前最好的。</p>
<h4>锤子科技</h4>
<p>这里还是忍不住插上一段讲老罗的。老罗的音频我在大概06 07年的时候就听过了。那时候高中无聊的慌，听他使劲的扯淡，很是留下了很多欢乐。然后牛博、然后老罗英语、然后西门子、然后演讲、然后手机、然后国航……。经过6-7年的种种事情，其实老罗还是那个我听音频的老罗。他看各种书，扯各种蛋。思考人生。维护自己的权利。跟随着自己的心去做事情。其实只要过了18岁，然后看过几本靠谱的书。能自己思考一下的人都知道目前天朝的所有问题的所在。可是我没有见过能改变这个问题的人或者事出现。所以我觉得老罗折中了一下。他用自己来教我们怎样做一个公民。老罗做ROM，我认为做出一个好ROM没啥大问题。可是现在的问题是ROM跳票了。我能理解要做到完美的产品才拿出来的心情。但是我不认为一个从来没有发布的产品能一出来就做的很好。我认同一句话，就是上线的第一天才是真正开始开发的第一天。只有被用户所使用，才会知道真正的需求。从浩瀚的需求中提取抽象根本问题，然后漂亮的解决这个问题。周而复始，才能渐渐迭代出一个好的产品。而一推在推的发ROM和Android被Google自己版本快速的迭代。会变成一个无期限的事情。我觉得是应该先推出ROM然后在迭代开发会更靠谱一些。</p>
<h3>迎合了市场需求</h3>
<ol>
<li>小米的硬件卖点</li>
<li>小米的营销手段</li>
<li>小米的品牌塑造</li>
</ol>
<p>历史总是相似的。30年前开始的的一场个人电脑战争爆发与微软+英特尔和Apple之间。由于种种因素的影响。我们现在知道那场战争的胜利者是微软+英特尔。虽然是Apple引爆了这个市场，结果还是被后来者统治了整个个人电脑时代。现在的移动互联网仿佛就是历史的重演，开拓市场的领先者依然是Apple，不过对手换成了Google Android阵营。Apple依然是那个对抗整个世界的Apple。而在Android阵营里面的小米，就是深得个人PC中微软+英特尔大败Apple的招数——性价比。小米主要买的是天朝，天朝还处于社会主义beta阶段。所以性价比在天朝乃至世界范围内都是一个很好的招数。小米做到了。</p>
<p>我记得我第一次知道MIUI的时候，那会只有一个论坛，很简陋的样子。虽然说是CM的改版，但是开始了本地化的改造。而且那时候已经是进入市场的小米，国内做ROM的还很少。硬件厂商又在自己开发着各自不咋样的Android版本。导致国内一批整体素质比较好的用户，都在使用。也就是后来小米喊出的口号，为发烧而生。确实，小米的初始用户户就是这些人。记得老罗第一场演讲的时候说过一个新技术产品的周期，具体数值记不得了。大概就是说。有一大部分用户的购买习惯是跟随着他们周围略懂而且愿意追随新技术的用户。他们会咨询和遵循这些略懂的人意见。小米不知是刻意还是无意。恰好赶上了这个点。最骨灰的用户在追寻最新的Android版本，CM的改版，对小米肯定嗤之以鼻。而略懂的用户，真心的觉得小米不错。这就够成了小米后来广告营销的基本条件和品牌的塑造。</p>
<p>小米手机，屌丝专用机。真心没有错。我不希望谁以屌丝自称。事实如此，虽然天朝大部分年轻人没有屌丝的心态，但是却是经济在屌丝状态下生活。高性价比本身就具有广阔的市场。再加上小米多多少少真的用心做了产品。小米会成功。</p>
<h3>小米盒子</h3>
<p>其实我想写这个blog的原因是小米盒子的出现。我觉得小米公司确实就是在C2C Apple。结果文章没有写完。小米盒子就被相关部门干掉了。讽刺啊讽刺。来看看小米盒子就是一个Apple TV的翻版。然后高性价比，根据天朝国情的本地化功能。连我都觉得过年回家给家里带一个，爹妈可能会更开心的看电视剧。</p>
<h2>侧面</h2>
<p>就举一个例子把。360这个老流氓那次打击的不是天朝内行业的最赚钱的公司。这次打小米，很显然是360嗅到了金钱的味道。就是从侧面说明小米在搞的事情很赚钱。成不成是另外一个事情。</p>
<h2>总结</h2>
<p>思绪很多，而且还间隔了这么久的时间。我想接下来的时间里面就不写这种类似的文章了。第一是觉得自己的眼光和阅历并不在一个很高标准的角度上看问题，这样必然有一定的局限性。做不到一个很客观的角度。第二是自己的文字功底确实没有我想象的那么好。第三如果天天写这些快变成光说不练的假把式了，说是天下无敌，打是无能为力。</p>
]]></content>
    <category scheme="http://iiiyu.com/categories/just-talk/" term="just-talk"/>
  </entry>
</feed>
