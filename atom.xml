<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[萧宸宇]]></title>
  <subtitle><![CDATA[如果不能成为拯救世界的神，那就堕落到征服世界的魔吧。]]></subtitle>
  <link href="http://iiiyu.com/atom.xml" rel="self"/>
  <link href="http://iiiyu.com"/>
  <updated>2014-04-08T15:56:00.106Z</updated>
  <id>http://iiiyu.com/</id>
  <author>
    <name><![CDATA[萧宸宇]]></name>
    <email><![CDATA[chenyuxiao@sumi-sumi.com]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[iOS笔记(35) 格志周年系列之夏令时(三) 临时花絮]]></title>
    <link href="http://iiiyu.com/2014/04/08/learning-ios-notes-thirty-five/"/>
    <id>http://iiiyu.com/2014/04/08/learning-ios-notes-thirty-five/</id>
    <published>2014-04-08T14:49:48.000Z</published>
    <updated>2014-04-08T15:55:53.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人学习记录使用,也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="开篇扯淡">开篇扯淡</h2>
<p>说曹操，曹操到。嘛当，还说总结一下时间的问题。这不blog这个系列没有写完。又爆了出一个时间相关的Bug。我只能说编程路茫茫，吾将上下求索。这次就着热乎着，来说是一个遇到了什么问题。</p>
<h2 id="遇到的问题">遇到的问题</h2>
<p>有日本用户反馈，新版本更新以后，他日历上的时间全部乱了。而且无法写入日记。经过与用户沟通（感谢喵神onevcat的日文人肉翻译）分析得到用户使用和历（日本日历）。然后debug进去果然日期全部乱了。跟进去debug了一番，发现是之前解决夏令时的函数只考虑了公历！！！而iOS系统默认有三种日历。公历、和历、佛历。又一次无情的证明了我是一个天朝土包子。</p>
<a id="more"></a>

<h2 id="iOS_&amp;&amp;_OS_X_支持的日历">iOS &amp;&amp; OS X 支持的日历</h2>
<p>这个问题的出现提醒了我，地球上不同的人们其实是使用着不同的日历。（在这之前学习到的是地球上的人们过着不同的时区，有夏令时和没夏令时的时间）。</p>
<p>iOS从Settings-&gt;General-&gt;International-&gt;Calendar。</p>
<p><img src="http://ww4.sinaimg.cn/large/a6d3226bgw1ef8l1icf7pj20hs0vkdgp.jpg" alt=""></p>
<p>可以看到是默认只是支持公历、和历、佛历。</p>
<p><img src="http://ww4.sinaimg.cn/large/a6d3226bgw1ef8lfdww4aj20il0cewfz.jpg" alt=""></p>
<p>OS X 要多一些…（好吧，大部分我都不认识）</p>
<p>那到底iOS &amp;&amp; OS X支持哪些日历呢。</p>
<p>看这里内建的有这些<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSLocale_Class/Reference/Reference.html#jumpTo_50" target="_blank">NSLocale Calendar Keys</a> (PS: 经过测试农历那个之前处于半残疾状态)</p>
<h2 id="用代码测试一下">用代码测试一下</h2>
<p>我遇到的问题是我获得00:00:00的方法是直接用string然后反向设置小时、分钟、秒数得来的。所以，当日历不同的时候date-&gt;string就不一样了！！！这样我只判断了公历的时候，和历和佛历就错了。</p>
<p>详细代码可以查考这个<a href="https://github.com/iiiyu/TestNSDateFormatterOnMac" target="_blank">TestNSDateFormatterOnMac</a></p>
<p>我fork了一个霓虹大神改动的。 添加了佛历的对比。</p>
<p><img src="http://ww1.sinaimg.cn/large/a6d3226bgw1ef8m65ylz2j20lq0gtgo8.jpg" alt=""></p>
<h2 id="总结">总结</h2>
<p>做好一个App其实挺难的，做好一款全球化的App更是难上加难。特别是我这种天朝土鳖，写程序的时候脑子里面就没全球化的意识。</p>
<p>附上一个今天在推上看到的心酸笑话：</p>
<p>编历法的玛雅码农想「我做个日历做上一千年应该就够用了吧」；编UNIX的码农想「我写个OS能用到2038年应该就够用了吧」；编RFC791的码农想「我整个IP能给42.9亿人用应该就够用了吧」——都给全世界添了乱子。我们做码农的一定要引以为戒 #读日语推有感#</p>
<h2 id="一些参考">一些参考</h2>
<p><a href="http://zh.wikipedia.org/wiki/農曆" target="_blank">农历 wiki</a></p>
<p><a href="http://zh.wikipedia.org/wiki/希伯來曆" target="_blank">希伯來历 wiki</a></p>
<p><a href="http://zh.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601 wiki</a></p>
<p><a href="http://www.unicode.org/reports/tr35/tr35-25.html#Date_Format_Patterns" target="_blank">UNICODE LOCALE DATA MARKUP LANGUAGE (LDML)</a></p>
<p><a href="http://balunsoftware.jp/info/2013/06/nsdateformatter-japanese/" target="_blank">NSDateFormatter で、和暦の変換に固定する</a></p>
<p><a href="http://kevin-wu.net/ios-locale-and-calendar-tips/" target="_blank">在开发iOS程序时对日期处理的总结</a></p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[学习UI设计笔记(一)]]></title>
    <link href="http://iiiyu.com/2014/03/25/learn-ui-design-one/"/>
    <id>http://iiiyu.com/2014/03/25/learn-ui-design-one/</id>
    <published>2014-03-25T15:12:21.000Z</published>
    <updated>2014-03-25T16:07:09.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人学习记录使用,也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="开篇扯淡">开篇扯淡</h2>
<p>那啥， 我知道NSDate的坑没有搞定。缓缓，缓缓。我在开个新坑来着。恩恩这个坑就是记录一下怎么学习Sketch 这个软件的。</p>
<p>首先，我买了本<a href="http://www.amazon.cn/更优秀的APP-31个APP用户界面设计经典案例-白润华/dp/B00ELMXLOK/ref=sr_1_1?ie=UTF8&amp;qid=1395760594&amp;sr=8-1&amp;keywords=31app" target="_blank">更优秀的APP-31个APP用户界面设计经典案例</a>。 高手勿喷，这种图文并茂，手把手的交比较适合我这种菜鸟。</p>
<p>这本书的唯一好处是他的例子是Ai的。而Sketch也是矢量图。所以我以为会有些类似的操作。（其实根本是两个软件啊！！！！）</p>
<p>然后我准备把他说的31个例子都用Sketch来模仿一边。恩，先把Sketch的大部分功能运用熟练再说（就是花了小几百不想让他吃灰而已）</p>
<a id="more"></a>

<h2 id="Sketch资料">Sketch资料</h2>
<p><a href="http://www.bohemiancoding.com/sketch/" target="_blank">官网</a></p>
<p>Sketch的资料其实并不是很多，原因之一是能熟练使用Adobe一套的大家（除了我）都能很快的入手。所以像我这样完全没有用过Photoshop的人在贵圈是一种奇葩。</p>
<p>所以中文资料就特别特别不多，不多的意思是图灵社区的某个大神把操作手册翻译了一下</p>
<p><a href="http://www.ituring.com.cn/book/1305?q=Sketch" target="_blank">Sketch中文手册</a></p>
<p>在没有发布的时候我就知道了，我满怀憧憬的等待这本书的上线。结果，嗯嗯很不错的一本使用手册。</p>
<p>洋文资料最多的就是MengTo大神的</p>
<p><a href="http://blog.mengto.com" target="_blank">大神blog</a></p>
<p>而且大神最近在预发售一本<a href="http://designcode.io" target="_blank">design+code</a>。现在购买打5折哦。(免费为大神打个广告)</p>
<p>官方视频都在Vimeo上自带神器</p>
<p><a href="https://vimeo.com/57072774" target="_blank">iOS Design using Sketch. Part one: iOS Navigation Bar</a></p>
<p><a href="https://vimeo.com/57590796" target="_blank">iOS Design using Sketch. Part two: iOS Toolbar</a></p>
<p>对了，据可靠小道消息，这货的3.0要发布了。又是一次交钱的时刻。穷死了。</p>
<h2 id="Github地址">Github地址</h2>
<p>咱程序员就要有程序员的范，每次的Sketch我都会丢到这个地址上，如果需要下源文件研究一下的同学知道去哪里找了把。</p>
<p><a href="https://github.com/iiiyu/learn-ui-design" target="_blank">learn-ui-design</a></p>
<p>鉴于最近的网络情况，自带神器。</p>
<h2 id="大幅大幅的贴图">大幅大幅的贴图</h2>
<h3 id="0">0</h3>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1eesf0yhz53j20zg0lmaew.jpg" alt="0"></p>
<p>恩，按照教程，我手绘了一张图片，然后用手机拍照了放到Sketch里面。</p>
<h3 id="1">1</h3>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1eesf3zl60jj20zg0lmn1i.jpg" alt="1"></p>
<p>拖了一个椭圆，然后选中铅笔工具，描绘了一下那个小尾巴。</p>
<h3 id="2">2</h3>
<p><img src="http://ww4.sinaimg.cn/large/a6d3226bgw1eesf54xa8kj20zg0lmaf1.jpg" alt="2"></p>
<p>选中他们两个，进行Union操作。</p>
<h3 id="3">3</h3>
<p><img src="http://ww3.sinaimg.cn/large/a6d3226bgw1eesf5vjl8kj20zg0lmdkp.jpg" alt="3"></p>
<p>拖一个正方形出来</p>
<h3 id="4">4</h3>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1eesf6sqy2sj20zg0lmwjs.jpg" alt="4"></p>
<p>正方形旋转45度</p>
<h3 id="5">5</h3>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1eesf7fq37ij20zg0lm0xy.jpg" alt="5"></p>
<p>在正方形上双击会出现可以编辑的关键点</p>
<h3 id="6">6</h3>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1eesf7ukiefj20zg0lm0xz.jpg" alt="6"></p>
<p>删除掉最右边的关键点，变成一个三角形</p>
<h3 id="7">7</h3>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1eesf979g3dj20zg0lmtd3.jpg" alt="7"></p>
<p>把气泡弄出来看一下整体效果</p>
<h3 id="8">8</h3>
<p><img src="http://ww3.sinaimg.cn/large/a6d3226bgw1eesf9x1vynj20zg0lmdkr.jpg" alt="8"></p>
<p>随便上个颜色试试</p>
<h3 id="9">9</h3>
<p><img src="http://ww1.sinaimg.cn/large/a6d3226bgw1eesfacyshyj20zg0lm0vn.jpg" alt="9"></p>
<p>最终版本，我尽力了。</p>
<h2 id="总结">总结</h2>
<p>恩，2014年的一个要努力的目标就是把自己的品味搞上去。恩呢，加油。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/Design/" term="Design"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(34) 格志周年系列之夏令时(二)]]></title>
    <link href="http://iiiyu.com/2014/03/19/learning-ios-notes-thirty-four/"/>
    <id>http://iiiyu.com/2014/03/19/learning-ios-notes-thirty-four/</id>
    <published>2014-03-19T12:37:48.000Z</published>
    <updated>2014-03-20T15:28:55.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人学习记录使用,也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="开篇扯淡">开篇扯淡</h2>
<p>恩，两月没更新blog，hexo都出来新主题来着。其实昨天为了找个背景图找了一小时我会随便乱说。就是为了找一个配合网站标题的背景图。其实hexo默认的就蛮好了，但是为了显示那么一点点与众不同还是替换了一下。</p>
<p>扯淡结束，接上一篇<a href="http://iiiyu.com/2014/03/18/learning-ios-notes-thirty-three/">格志周年系列之夏令时(一)</a></p>
<h2 id="第一阶段Bug">第一阶段Bug</h2>
<p>上次说过一个中国高富帅用户发Email来说，他去泰国旅游的时候，日记都不见了。</p>
<p>其实不是日记不见了，日记都好好的躺在sqlite文件里面。而是查询不出来了。日记的保存是用了一个函数去获得了每天的00:00:00. 然后作为唯一标识来区别和查询。  </p>
<p>那日期出了啥问题？</p>
<p>我们来快速的分析一下</p>
<p>调用的是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>- (NSDate *) dateAtStartOfDay
{
	NSDateComponents *components = [CURRENT_CALENDAR components:DATE_COMPONENTS fromDate:self];
	components.hour = 0;
	components.minute = 0;
	components.second = 0;
	return [CURRENT_CALENDAR dateFromComponents:components];
}
</pre></td></tr></table></figure>

<p>里面有两个宏</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="preprocessor">#<span class="keyword">define</span> DATE_COMPONENTS (NSYearCalendarUnit| NSMonthCalendarUnit | NSDayCalendarUnit | NSWeekCalendarUnit |  NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit | NSWeekdayCalendarUnit | NSWeekdayOrdinalCalendarUnit)</span>
<span class="preprocessor">#<span class="keyword">define</span> CURRENT_CALENDAR [NSCalendar currentCalendar]</span>
</pre></td></tr></table></figure>

<p>假设你使用过Cocoa时间这些类的话能很容易的看出。dateAtStartOfDay函数就是把你持有的date以当前日历为基础，其他不改，小时，分钟，秒钟设置都为0。这样就能得到一个基于当前日历下的date这一天的00:00:00。</p>
<p>简单看上去没有什么问题，回到高富帅的问题。他出国玩一圈咋时间就变了呢？答案是[NSCalendar currentCalendar]改变了。NSCalendar的改变使得dateAtStartOfDay返回的时间也变了。debug到这一步才发觉靠当初为什么没有想到有时区的这个问题。</p>
<p>自己给自己找一个理由就是到目前为止，我只用过大天朝的+8时间。潜意识里面根本没有说换一个时区这样的概念。(后来某一天我翻了本C语言的书第一章就说了国际化时间的问题，再后来weibo上大家都纷纷表示时间是编程里面一个基础点而且做好不容易，只能说我还是太菜太年轻了。这些是后话了)</p>
<p>说道这里那就开始科普一下地球上时间的问题</p>
<a id="more"></a>

<h2 id="世界时间">世界时间</h2>
<p>由于人类历史的缘由，地球上以大概的地理位置画分时区。<a href="http://en.wikipedia.org/wiki/Time_zone" target="_blank">Time Zone Wiki</a></p>
<p>我认为时间是大爆炸以后产生的扩张现象，在可预见的人类的历史上肯定是不可逆转的。所以每一个时刻对于人类来说应该是唯一的。但是，在这同一个时刻里面，在地球的不同地方使用着不同的时间格式来表现着。我认为这是相当不科学的一个事情。随着人类文明的进步，我觉得最后应该会全世界时间大统一的。</p>
<p>回到现实中还是要解决现在因为时区而产生的问题。</p>
<h2 id="iOS中的时间">iOS中的时间</h2>
<p>在Cocoa里面，获取一个当前时间是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">NSLog</span>(@<span class="string">"Now:%@"</span>, [<span class="built_in">NSDate</span> date]);
</pre></td></tr></table></figure>

<p>Log出来应该是一个 xxxx-xx-xx xx:xx:xx +0000。但是聪明的你，人如果处在大天朝内马上发现这个时间比你电脑上的时间少了8小时。</p>
<p>恩,因为NSDate记录的是一个绝对的值。这个值代表的意思是UTC时区的绝对时间。我们就把它看作为我们写Cocoa程序的一个绝对时间，千万要记住这一点。因为接下来的一堆概念会把人弄晕的。（我就晕了好久#_#）</p>
<p><a href="http://zh.wikipedia.org/wiki/協調世界時" target="_blank">UTC Wiki</a></p>
<p>与UTC有点关系的GMT时间，稍作了解避免搞混了。（实在分不清，你就记住UTC是一个更加精准的标准时间）</p>
<p><a href="http://zh.wikipedia.org/zh-cn/格林尼治平时" target="_blank">GMT Wiki</a></p>
<p>那NSDate存储了一个什么值来代表时间呢？可以简单的认为他是记录了一个浮点数。这个浮点数代表什么呢？我们注意到头文件里面有个这样的方法timeIntervalSince1970。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="comment">// seconds</span>
<span class="built_in">NSLog</span>(@<span class="string">"seconds %lf"</span>, [[<span class="built_in">NSDate</span> date] timeIntervalSince1970]);
</pre></td></tr></table></figure>

<p>在写文章的此时此刻打印出来是“1395324408.535384”。简单运算一下</p>
<pre><code>1395324408.535384 / 60 / 60 / 24 / 365 ≈ 44.245446745
2014.x - 44.x ≈ 1970
</code></pre><p>看到这里，就可以很明确的认为用NSDate来存储的时间是从1970-01-01 00:00:00 到那个时刻所经历的秒数。</p>
<p>为什么是1970？如果你接触过一些计算机的知识或者其他编程语言或者数据库等。你都可能在时间相关的地方会发现1970很眼熟的样子。<a href="https://duckduckgo.com" target="_blank">放鸭</a>搜索了一下。找到一些比较权威的说法。</p>
<p>首先能找到权威解释是<a href="http://en.wikipedia.org/wiki/Unix_time" target="_blank">Unix time</a>。简单粗暴的来说就是我们现在用的 <em>nix 以及基于 </em>nix的一堆东西（包括了现在使用的绝大部分东西）都是1970年极其以后出现的。那时候大家觉得就从1970-01-01 00:00:00开始算时间是个不错的主意。就这么一直延续下来了。（PS：忽略了一堆32bit or 64bit的点。需要详细解释的看url）</p>
<p>看NSDate头文件还</p>
<p>发现一个有意思的宏</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="preprocessor">#<span class="keyword">define</span> NSTimeIntervalSince1970  978307200.0</span>
</pre></td></tr></table></figure>

<p>稍微做了一下运算。可以知道这是从1970-01-01 00:00:00 到2001-01-01 00:00:00经过的秒数。稍微思考一下应该是用来进行了优化运算的。</p>
<p>待续。。。</p>
<h2 id="小结">小结</h2>
<p>这么一点字又写了两天，还是要每天坚持啊。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(33) 格志周年系列之夏令时(一)]]></title>
    <link href="http://iiiyu.com/2014/03/18/learning-ios-notes-thirty-three/"/>
    <id>http://iiiyu.com/2014/03/18/learning-ios-notes-thirty-three/</id>
    <published>2014-03-18T13:23:35.000Z</published>
    <updated>2014-03-19T13:08:28.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人学习记录使用,也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="开篇扯淡">开篇扯淡</h2>
<p>两月没写blog，没羞没皮了。以后作息规律一些，blog更新还是频繁一些。格志在2014年2月11日就整整上线一周年了。2013一年做格志，由于自己的技术实在比较菜。导致从上线的第一天起，整个团队跟着一直打补丁。小的坑就不说了，大的坑有两，一个iCloud + Core Data世界性难题。一个是全球时间问题。这篇blog就用来专门记下时间的坑。中间还有个插曲——格志在三月上线了2.0的全新专门为iOS 7设计的版本。时间问题在去年10月份改完以为对了就没有改过。结果3月9号是3月的第二个周日，美国地区进入夏令时。格志中又再次发生了时间问题，导致日记显示不全。之前开会说过放错不可怕，可怕的是放同样的错误。再次放错以后我都呆住了。那可是我写过测试用例的啊。结果当时一run测试就挂掉了。瞬间脑子蒙掉。然后上周通宵了一天，基本每天到3点把世界时间问题给彻底搞定。（希望是彻底）所以趁着我现在还有印象，记录一下。</p>
<a id="more"></a>


<h2 id="国际化">国际化</h2>
<p>我们所以会遇到世界时间的问题主要有几个原因：</p>
<ol>
<li>格志的定位是一个全球市场的产品</li>
<li>我们团队(真实情况是我是一个土鳖)并没有很国际化的背景</li>
<li>格志是一个颗粒度为天的日记应用（Day One等另外几个比较出名的App其实是一个moment为颗粒度）</li>
<li>格志在设计数据存储的时候用了时间作为日记的唯一标识符号</li>
</ol>
<p>所以，最初的版本。我是用了一天的00:00:00分来作为日记的时间。</p>
<p>用了这个库</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>https:<span class="comment">//github.com/erica/NSDate-Extensions</span>

<span class="comment">// pod </span>
pod <span class="string">'NSDate-Extensions'</span>, <span class="string">'~&gt; 0.0.1'</span>
</pre></td></tr></table></figure>

<p>里面的这个方法(先贴出来)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>- (NSDate *) dateAtStartOfDay
{
	NSDateComponents *components = [CURRENT_CALENDAR components:DATE_COMPONENTS fromDate:self];
	components.hour = 0;
	components.minute = 0;
	components.second = 0;
	return [CURRENT_CALENDAR dateFromComponents:components];
}
</pre></td></tr></table></figure>

<p>来获取每天开始的时间。</p>
<p>然后第一个版本我们就这样欢乐开心的上线了。然后iCloud爆大坑。开始填了2个月的iCloud坑和数据修复。在某个时间，一个中国高富帅用户发Email来说，他去泰国旅游的时候，日记都不见了。我才隐约发觉日记的时间有问题！！</p>
<p>日期出了啥问题？</p>
<p>待续</p>
<h2 id="小结">小结</h2>
<p>上周作息实在不规律，现在需要调整一下。本来应该一次性写完发的，但是怕自己懒惰（比如上次的开了头就没有继续，所以我决定每天都写一点就算少一点还是把他发掉）</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[读 Jony Ive: The Genius Behind Apple's Greatest Products 笔记]]></title>
    <link href="http://iiiyu.com/2014/01/08/read-jony-ive/"/>
    <id>http://iiiyu.com/2014/01/08/read-jony-ive/</id>
    <published>2014-01-08T12:51:37.000Z</published>
    <updated>2014-03-18T12:27:29.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人记录使用，也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站，这样您将能在第一时间获取本站信息。</p>
<h2 id="开篇扯淡">开篇扯淡</h2>
<p>发现之前的读书笔记写的好少啊。 都是每年的一月份写一次，然后一整年都没有写。其实并不是没有看书而已，只是看了没写而已。2013除了专业的书籍还是看了一些乱七八糟的书籍。比如开始看王小波，看冯唐。对了<a href="http://weibo.com/ooyor" target="_blank">ooyor</a>大神同学去台湾做出国毕业旅行游的时候还给我带来了一本冯唐实体的小黄书《不二》。还有就是2013年初看完柴静的《看见》和李承鹏《全世界人民都知道》,而且还去不在书店签了4本。亲笔签名哦！其他的看了也就没有印象了。</p>
<p>其实读大学以来，每年的书籍开销都是一笔不小的数目。这就造成了一个严重的问题！每次不管是短途迁移还是长途迁移都搬书搬的欲仙欲死。所以，2013我都是可以买电子书坚决不买实体书。如果没有电子书，我就等电子书出来。如果没有电子书，不是很想看的就不买了。电子书多好迁移啊，一个iPad就带走千万本。不过也有些郁闷，我KK的全套在字节社里面结果现在字节社快挂的样子，多看上买了目前最多的书，但是被小米收掉以后不喜欢它的作风。现在我已经全面的转向了豆瓣读书。图灵社区也买了些然后丢多看里面看。（多看在我这里已经沦为Good Reader的替代品）。</p>
<p>恩，2014希望我想看的书都出电子版吧！让电子化来的更加猛烈一些。</p>
<h2 id="Jony_Ive">Jony Ive</h2>
<p>这次的书总有种是为了敛财而来，作为一个Apple的脑残粉。其实Apple这40年来的各种事件和经历。已经在无数的书籍、文章、电影里面一次一次的重复了很多很多次。每看一次就对Apple的印象丰满一些。到现在Apple在我心中已经是一种具体的形状。这次的Jony Ive传记对我来说，也只是对于Apple印象的一个补充而已。</p>
<h3 id="年少成名">年少成名</h3>
<p>大英帝国的子民，而大英帝国好歹是工业革命的发起地。虽然美帝现在势不可挡。但是200年来的现代化进程底蕴是天朝这种年轻的2b国度无法比拟的。而且Jony Ive人家老爸<br>人家16-7岁的时候就已经各种拿奖了。</p>
<h1 id="PS">PS</h1>
<p>这篇blog的创建时间是1月8号。现在时刻是3月18号。所以我还是把他发掉把。只开了头而已。现在记不住了。</p>
<p>一月到三月瞟过的书有：</p>
<p>「从你的全世界路过」 （看错作者买错书了）</p>
<p>三本Objective C的</p>
<p>GEB瞟了几页。</p>
<p>豆瓣上冲了150.忘记买了些啥了记得有几本挺贵。反正是不在多看上买书了。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/read book notes/" term="read book notes"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[2013年度总结]]></title>
    <link href="http://iiiyu.com/2013/12/31/2013-annual-summary/"/>
    <id>http://iiiyu.com/2013/12/31/2013-annual-summary/</id>
    <published>2013-12-31T13:57:54.000Z</published>
    <updated>2014-02-17T04:21:47.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人记录使用，也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站，这样您将能在第一时间获取本站信息。</p>
<h2 id="生活">生活</h2>
<h3 id="注定的漂泊">注定的漂泊</h3>
<p>在16岁的时候，我就会隐约觉得我会一生注定漂泊。这种感觉以我的文字水平很难用完整表达出来。不过18岁以后的每一年换一个住的地方。直接用事实验证了这个16岁的直觉。本来以为我会在厦大住够2年的，命中注定，天煞孤星。房子要拆迁只有另外找地方了。继续这一年一个地方的节奏。</p>
<a id="more"></a>


<h3 id="极品房东">极品房东</h3>
<p>我想如果不是今天发生的事情我是不会写入的。说真的我一直觉得国足，城管，整个教育，盗版，没节操，所有的敏感词。其实都是表面，去深究根本原因的人们都消失不见了。所以在这种无力的大环境前提下。面对这些事情我常常手足无措，不知道应该用什么样的态度去面对这些事情。我只能告诉自己，这是一个又一个生动又真实的移民广告。来生不做中国人。拉回来说，现在应该称为前房东。来厦门几次找房子都很仓促。都没有留下足够的时间来好好的找房子。第一次是来面试结束以后，一直住酒店。厦门的酒店价格大家懂的。然后也是找了中介就草草决定。电梯海景房，一套隔断成6套。我的是其中之一。旁边有个貌似厦大的女生。经常去夜店，凌晨2-3点回来。这个没啥，关键带一群女生回来。喝了些多不多的酒。然后开始评论男人，给男人打电话扯淡。嘛当，几个月搞的神经衰弱啊。 直接说了没有用。几次想怕起来搞个小电影开最大声音。但是觉得我都出声提醒警告无效的情况下。貌似也没用。然后就是住了半年房东要涨200，当时怕过不了试用，就直接滚蛋没干签一年。然后最后几天天天中介带人过来看，态度很嚣张。最后退房的时候，我在帝都找妹子去了。委托了蒋韩同学过去退押金。一个很能扯淡的河南汉子硬是被两中年妇女说的毫无招架之力。唉。反正被扣了钱。不过也难为他了。找啊找，然后我们投资人说有个朋友的朋友有住房子。当时遇到国庆要去帝都找妹子。找房子带搬家就一周时间。然后想着恩好像有点熟人类似的关系应该没啥问题就定下来了，没有签合同（这个为现在埋下了巨大的隐患）。厦大里面最古老的房子没有之一，每层有共用厕所（没有独立卫生间）。唯一两个电器空调和热水器。我进去的时候起码画了2000添置洗衣机，电磁炉等物品才能住的。第二次交租突然告诉我有个物业管理费，嘛当，当初就写了个收据，没啥合同。一定说是跟我说过的。恶心坏了。没窗帘，我自己挂。空调坏了，我自己修。电灯坏了我自己换。嘛当，想着也没有啥大事情就自己弄好了。不要这么娘炮。天天找房东。结果呢一年到期人家2话不说，呵呵因为物价上涨，所以房租也要涨。我从来没有拖欠过每次交租。而且他是教职工租房房子，很是便宜，然后一年到期的头7天突然跟我说下一年的房租要涨200.之前跟我没有任何联系。因为没有合同人家就是要涨就涨。但是他的房子几乎没啥成本，是厦大租给教职工做福利的。然后我想找房子，但是那个月突然有工作要忙。最后没能找到满意的。我只能说是要继续住。然后叫他过来当面说了1小时。晓之以情，动之以理。最后喉咙都感觉出血的情况下。在他带来各种不平等条约的合同上只涨100.签了1年。这不，住了没2月就要拆。收到消息到搬走也之有10天左右的时间。就在2013.12.30日我打电话跟房东说我2013.12.31日要搬走。然后晚上过来交接一下房租的事情。（这个时候我有一个月的押金，和交了3个月只住了两个月的房租）他满口答应没有问题。 2013.12.31日晚我回到老房子跟他打电话问他什么时候过来交接。第一，他矢口否认我交过一个月的押金。并且否认之后签的合同上同样写着交了押金的条目。第二，以其他理由推脱不能来交接。真的，当时我整就无语在空中。然后我叫他当面过来对质。我还有他写的收据。然后我拍照发过去给他。他又说2014年1月1日。转帐给我。基于很多很多小的细节。我在离开房子的时候拍了些照片。以防止要出什么妖蛾子。</p>
<p>在这个劣币驱逐良币。权利利益群体更加压迫普通群体的地方。我唯一找到的解决方案就是移民。</p>
<p>这段写的异常愤怒。下面写点轻松的。</p>
<h3 id="完全正版化">完全正版化</h3>
<p>其实，全面转到Linux的时候，已经很少用盗版了，除了虚拟机里面的Windows是盗版。然后全面用Mac以后，几乎没有啥盗版。只是一开始的时候也没入啥App。但是2013年，我买正版没有三千也有两千了把。第一次买超过100rmb App的时候还是很纠结。但是买过了以后就没啥感觉了。然后买了几次以后。感觉300左右的App还是能在接受的范围内。所以，看到心仪的App一般就入了。6rmb这种几乎都是顺点的。所以，2013年对我来说是完全正版化的一年。对了，我没有虚拟机，所以我也没有用Windwos。所以，现在我可以自豪的说，我现在Mac上面全部App是正版。当然今年的正版化，我还尝试过音乐。不过iTunes里面中国区买不到。天朝的几家付费的我都冲过一两个月尝试了一下。但是都没有心仪的。不过后来Xiami For Mac。确实做的好，本来我对虾米的印象是很糟糕的。但是Xiami For Mac居然能改变我对虾米的看法。真的做的好。然后今年去电影院的次数也满多，iMax也看了不少场。对了，如果你一定要揪出来说，我只能说我承认我看的爱情动作片还是盗版。不过我也会尝试着弄成正版。</p>
<h2 id="工作">工作</h2>
<h3 id="Sumi">Sumi</h3>
<p>来厦门也快两年，其实长开智以后，只要某一刻突然停下来回头瞅瞅，都会发出时间过的好快的感觉。文人骚客说就是“人生天地之间，若白驹过隙，忽然而已”。 </p>
<p>2013过年一来，大概迷茫过3-4个月的样子。迷茫的原因是我周围都是一堆“一条龙”能搞定的人儿。我所谓的”一条龙”就是现在流行的”full stack developer”。</p>
<p>我boss Kevin Cao。 泪流满面，工作室来过好多波人参观。如果是熟悉的人都会说一句“Kevin是我见过从设计到技术都能达到国际水准的一个人”。如果不熟悉的人听到啥“Grid Diary是你设计的？还是你写的？我这么多年来第一次见过又能设计又能写代码的”。可想我一个hello world级别的小菜程序员压力有多大了么。</p>
<p>90后”一条龙”王放放同学，泪流满面，从后端，前端，设计，iOS，Android, MacOSX App.一条龙了。居然tm的还是文科生跨界友情客串。你叫一个读了破壁坑爹4年的软件工程专业的88年大龄hello world级别程序员情何以堪。</p>
<p>90后“一条龙”廖逸聪小朋友， 泪流满面，又是一个从后端，前端，设计，iOS，Android, MacOSX App.一条龙了。而且华丽丽的看清楚了破壁坑爹的软件学院本质。大二休学闯荡江湖。然后见到我的时候大部分时间拉着我聊南怀瑾。然后时不时的送自己烤的小饼干给我吃。嘛当，不仅可以写的一手好代码，还能做的好一手小饼干。恩我去面壁思过去了。</p>
<p>当看到我司RoR高富帅写起iOS也绝不含糊。旁边的100平土豪灰用起Photoshop也是一溜一溜的时候。我就纠结了，嘛当，写个程序写hello world级别。连个PS都不会用。太丢人了。</p>
<p>在这样一群优秀的人儿当中，那时候我想，嘛当我也可以画图的嘛。好歹小学时候画小金鱼拿过小红花的。这样我跟小聪妹子骗来了一本「像艺术家一样思考」。然后郑重其事的去厦大小超市里面买了铅笔和纸准备学习画画。初级目标是理解美。中级目标是也能自己熟练的捣鼓点UI。终极目标是向Boss那样一条龙下来。而且是高水准的一条龙。</p>
<p>可是事实就是任何东西没有经过一万小时的锤炼是无法成为专家的。只有幼儿园水平却想着要弄出专家级别的东西。而弄不出来的时候我心情就会变的很压抑、烦躁。白天工作的时候思绪就会不集中，素描也没有能坚持下去。就画了大概2周左右的时间。</p>
<p>在学习素描的过程中，我不仅仅想学画画这样一个技能。我就是想一口吃成一个胖子。我还同时看着后端而且后端我还在Golang Ruby NodeJS中徘徊。今天这个配置环境Go写个hello world折腾一下。明天弄个Vim环境试试Ruby的写法。 大后天弄个Textmate的bundle写一下NodeJS。每个东西都浅尝辄止的学习。却想做出一个庞大的系统出来。</p>
<p>最后，我居然还在开始看着OSX编程。也不知道脑子咋想的。觉得自己在iOS端输出不够，就逃避的想说恩。我去先学一学OSX。到时候项目快速推进到OSX上。来弥补我在iOS端的薄弱输出。事实是OSX上面的坑更多。各种API一点都没有iOS上的好用。而且桌面端的思路跟移动端的思路完全是两个概念。双修其实是有难度有门槛的事情。</p>
<p>各种折腾2-3个月，我还是那个我。无法画出漂亮的UI，写不出比hello world更加复杂的后端，写不了OSX的程序，本来应该写好的iOS代码的质量也没有得到提高。时间成本在折腾中流失。</p>
<p>在我的各种愤怒中。萌小萌同学和Boss让我意识到。如果单项技能没有一万小时的修炼是无法达到我想要的高度的。而我不能三心二意的做事情。这样反而影响到了工作质量。</p>
<p>我用了一段时间艰难的让自己承认自己只是一个天资普通的人。我只有踏踏实实的一个小时一个小时单线程的努力。累计到了一万小时才是最终的王道。</p>
<h3 id="代码_&amp;&amp;_技术">代码 &amp;&amp; 技术</h3>
<p>今年早些时候，Allen Xu（又是一个全端工程师，你们够了！！！天天刺激我）的引荐。我有幸被唐巧加入他的群里。诚惶诚恐，巧哥的群有点像传说中大佬caoz的群的方式。进群的唯一标准是巧哥觉得你ok。虽然不可能像caoz的群里那种随便一个都是大佬。但是目测巧哥的群里大部分伙伴们的实力（其实就是除了我）应该能代表目前中国iOS&amp;&amp;Cocoa的顶级实力。肯定有一些潜伏的大神还没有露面出现。不过现在群列表里都是开发这百万用户，千万用户，亿级用户产品的大大们。平时有个啥问题丢进群里。几乎是立马可以得到解决方案。群里也经常分享整个业界的最新资讯。2013年能进巧哥的群，是一个非常大的惊喜。从里面收获颇多。</p>
<p>2013年的代码质量从被review的情况上来看，可读性依然一塌糊涂。最更本的原因是我只会一个一个的单词（还经常打错）。而无法连成一句完整的话。其实我有很努力的去改进这个问题。都变成每次写代码，起函数名字是整个写代码过程中花费时间最长的部分。但是效果不明显。</p>
<p>今年技术关注的重点依然集中于iCloud。由于过年前的匆忙修改，并且没有覆盖测试，导致iCloud出错。最终导致Grid Diary没能一炮而红。其实主要责任是我的。为了解决第一次发布版本的错误。我们用了整整2个月，不停的推出版本来修复错误。而因为没有写测试用例覆盖测试。往往我们修复了一个问题，结果就引出了其他问题。关于Gird Diary这一年遇到的坑。我觉得可以重新写一篇blog了。</p>
<p>然后为了解决iCloud + Core Data同步的问题。又去尝试设计过iCloud + Document的方法去同步。然后在建立索引。但是由于demo完成度太低。和老用户升级带来的麻烦。此方案最终抛弃。所以现在依然是iCloud + Core Data的同步方式。</p>
<p>今年另外一个重点关注的东西是ReactiveCocoa。虽然我还是hello world级别。不过在github上watch一个这样活跃的项目收获还是巨大的。可以看到什么是开发的热情和执行的高效。看到他们为了一个名字而讨论怎么样才合适。所以ReactiveCocoa对我来说不仅仅带来了一种新的设计思想和代码编写方式。它还为我展示了一个国际化开源项目的活力。</p>
<h2 id="感情">感情</h2>
<h3 id="父母">父母</h3>
<p>其实在16-7岁的时候跟父母的关系其实蛮紧张的。因为年少吧，现在能多为其他人考虑问题以后。那就多体谅父母。只是亲尚在，不远游。自己在外面漂泊着如果父母有个什么事情也帮助不了的时候觉得自己挺自私的。不过爸妈还是很尊重我的意思，我也很感谢他们并没有强迫我去做我不喜欢做的事情。</p>
<h3 id="萌小萌">萌小萌</h3>
<p>和萌小萌有时候也会斗斗小脾气，拌拌小嘴。经过无数次的商量。异地恋的弊端应该都全部解决了。然后今年准备去给未来丈母娘看看，希望能是一个好的结果。</p>
<h3 id="兄弟">兄弟</h3>
<p>今年好兄弟应该说还是比较圆满了。老闷和飞哥多年后的今天终于找到了各自的真爱，可喜可贺。wwl荣升当爹不说，多年的盘终于出去取得突破性进展。回去抱大腿的日子指日可待。六的结婚日程应该已经提上日程，大豪宅已经住上，差不多也是当爹的节奏了。鑫哥？鑫哥号称只剩下钱了。随时可以回去抱大腿了。</p>
<h2 id="计划">计划</h2>
<p>说好听点我并不是一个循规蹈矩的人。说实际情况就是自制力极其差，拖延症状严重。每次制定的新年计划都是像是个安慰剂。安慰一下拖沓了一年的自己。给自己心里暗示说恩下一年会做的好一点。其实25年来每次都这样的说法，而每次只有等到12月31日的时候来悔恨自己。</p>
<p>所以此时此刻我很矛盾。 不知道是否应该把2014年的计划下来。</p>
<p>2014年，我希望我能好好的学习一下洋文。</p>
<p>2014年，我希望萌小萌能快乐过每一天。</p>
<p>2014年，我希望长辈身体健康。</p>
<p>2014年，我希望我能和Sumi继续走在改变世界的路上。</p>
<h2 id="最后">最后</h2>
<p>最后，这就是我2013年的一些碎碎念。从2013一直写到了2014. 就给我的伙伴们当个乐呵乐呵的东西看看呗。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/just-talk/" term="just-talk"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(32) UbiquityStoreManager 学习笔记1]]></title>
    <link href="http://iiiyu.com/2013/12/25/learning-ios-notes-thirty-two/"/>
    <id>http://iiiyu.com/2013/12/25/learning-ios-notes-thirty-two/</id>
    <published>2013-12-25T15:22:33.000Z</published>
    <updated>2014-04-01T04:25:19.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人学习记录使用,也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站,这样您将能在第一时间获取本站信息.</p>
<h2 id="开篇扯淡">开篇扯淡</h2>
<p>现在都是进入互联网时代，一个互联网的App数据肯定是存在互联网上的。到处都是云，到处都是服务器。如果数据是存储在云端or服务器端。每次数据的读取和修改直接作用于服务器。这样不管你用多少设备，多少平台。数据都能保证是唯一的。但是还有些App需要一些更好的性能和效果的时候往往等不起网络的数据传来传去。这时候需要一些折中的办法来解决这些问题。iCloud就是Apple给出的解决方案。就普通用户来看，iCloud应该是在Apple系中的最优选择。但是从开发者的角度来看iCloud就是个无穷无尽的深渊。</p>
<p>全球有很多开发者致力开发第三方库以便让iCloud能被使用。 </p>
<p>UbiquityStoreManager就是其中之一。</p>
<a id="more"></a>

<h2 id="UbiquityStoreManager">UbiquityStoreManager</h2>
<p><a href="https://github.com/lhunath/UbiquityStoreManager" target="_blank">UbiquityStoreManager</a>是一个core data持久化层的控制器.</p>
<p>UbiquityStoreManager在iOS 6时代是使用GPLv3协议。所以好像使用者不是很多。iOS 7 Core Data 关于iCloud引入了新的机制和新API以后UbiquityStoreManager迅速跟进。并且更换了协议使用了Apache v2。所以如果你有iOS 7的App想使用iCloud + Core Data这种hard模式。UbiquityStoreManager是第一个应该推荐的库.</p>
<p>UbiquityStoreManager不同于其他解决方案。大部分都是在iCloud上面继续构建一层来保证数据同步的完整一致性。UbiquityStoreManager仅仅是解决了就只单纯使用iCloud就会遇到的问题。比如数据出错了怎么办。从本地数据迁移到iCloud数据。从修改日记来重建数据库等。</p>
<h2 id="UbiquityStoreManager解决的问题">UbiquityStoreManager解决的问题</h2>
<ul>
<li>提供在iCloud和本地Store直接切换</li>
<li>在用户没有iCloud store 的时候自动的把local data 合并到iCloud(使用本地数据重建iCloud)</li>
<li>所有与iCloud有联系的事件处理 iCloud帐号删除、iCloud数据删除、本地数据导入、其他设备变换ubiquitous、恢复有错误的transaction logs</li>
<li>其他的一些实用功能：从transaction logs重建cloud store、 从cloud store 重建transaction logs、 删除cloud store、 Ability to nuke the entire cloud container、 把一个store里面全部的entities合并到另外一个store</li>
</ul>
<p>在iCloud + CoreData的官方解决方案中，对于开发者来说完全的黑箱子操作。难于开发和调试bug。而且经验不足完全会被很多坑拉进泥潭里面。使得开发更本无法进行下去。所以仔细研究UbiquityStoreManager。是我建议踏入iCloud + Core Data开发的必修课。</p>
<h2 id="总结">总结</h2>
<p>只是我学习中的一点笔记和注释翻译而已。留给自己看看。如果有不对的地方，欢迎指出。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[简单测评Bong(深度吐槽,胆小、承受能力差和心脏病人需要陪同观看。谢谢合作)]]></title>
    <link href="http://iiiyu.com/2013/12/21/evaluation-bong/"/>
    <id>http://iiiyu.com/2013/12/21/evaluation-bong/</id>
    <published>2013-12-21T11:47:02.000Z</published>
    <updated>2014-02-17T04:21:39.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人记录使用，也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站，这样您将能在第一时间获取本站信息。</p>
<h2 id="开篇扯淡">开篇扯淡</h2>
<p>今天为了测试Bong支持游泳的说法，我差点挂在厦大的游泳馆里面。这天太冷了，而我自己又对自己的身体素质预估不住，跑去露天的游泳池。偌大一个标准池就我一个人，随意做了几下准备运动抵不住冷风吹，深吸一口气眼睛一闭跳进去。XXX，我能说脏话么。蛋都要冻掉的节奏啊，心中顿时把年少时候在电视上看到冬天跳入结冰河水游泳的新闻编者草泥马过了千万遍。顿时想转身起来，但是一想到下去还钥匙时候丢人死了。就奋力的向前游。接下来，我体验到了在水里皮肤会有痛的经历。记忆力从来没有过的。由于水温比身体温度低很多全身的皮肤感到刺痛，寒冷刺皮肤啊。扛着想今天至少要游1km吧。游了200m的时候开始全身麻木or适应了刺痛感，好过一点。咬牙游到600m的时候还觉得可以到1000m的结果650m米的时候开始感到不适。以自己科学常识隐约觉得是体温下降太多导致。所以就在700m的时候翻身上岸。经过长途跋涉回到宿舍里面赶紧冲了一个热水澡。然后躲到被窝里面小睡了1个小时才感觉命回来了。</p>
<p>我并没有才入手就吐槽，而是使用了5天。打了两次羽毛球，游了一次泳。才开始吐槽的哦。</p>
<a id="more"></a>

<h2 id="缘由">缘由</h2>
<p>2013这一年没入啥大件，但是小东西弄了一堆。也蛮浪费钱的唉。智能穿戴设备去年年末火的时候就一直寻思着入一个看看，不过一直狠不下心来。而今年入夏以后主要运动几经波折固定在了游泳上，深度观察以后觉得靠谱的两家<a href="http://www.fitbit.com" target="_blank">fitbit</a>和<a href="https://jawbone.com" target="_blank">jawbone</a>的手环都不能支持游泳。所以一直在等待一个支持游泳的手环出来。</p>
<p>然后在11月的某天，看weibo的时候看到kenwone上在卖一个国产手环，听说过的另外一个国产手环(咕咚)节操早就掉没了。这个好像还不错的样子。点过去一看。靠可以检测游泳，最重要的是一个VIP特权。号称这一批用户可以永久享受每一代设备更新。我靠爱占小便宜技能开启。然后怂恿着大厨先弄了一个。然后自己也就付款了一个。小算盘打着，这么高调。至少能撑过2代吧。那就至少有两个。有两个的话，就差不多保本有赚了。啊哈哈。</p>
<p>所以我入Bong有三个理由</p>
<ol>
<li>我想试试智能手环之类</li>
<li>支持游泳</li>
<li>性价比</li>
</ol>
<h2 id="Bong的整个运营">Bong的整个运营</h2>
<p>买了bong，然后关注了多关注了bong。weibo时不时瞅两眼。</p>
<p>说微信公共帐号。这次发现公共帐号还是蛮有必要的。</p>
<ol>
<li>保存了每天更新</li>
<li>虽然在我看来每天的内容做的一般。但是起码有人味。不那么机械冷冰冰。</li>
</ol>
<p>通过weixin好感度提高蛮多的。</p>
<p>然后说第一次跳票，其实都很能理解。所以第一次听说也才10几个的退款率。整个前期运营功不可没。</p>
<p>不过后来的整个运营就只能用惨不忍睹来形容了。</p>
<p>跳票以后的进度不清楚。然后承诺的15号发货。15号虽然发了大部分(猜测)。但是被发货的用户们(我)对整个顺丰订单毫无信息。已经习惯了taobao系流程的我来说很不习惯。没有安全感。就算整个订单系统来不及做。丢一个excel表格起码也能丢上去把。起码能有个地方能查到啊。很遗憾什么都没有。</p>
<p>我知道bong现在才8个人。按照官方说法是有1400个要发。算发一个需要5分钟。简单算术8个人需要做15个小时才能发完。按照官方说法感觉肯定发一个的时间超过5分钟。所以觉得他们在一天之类肯定发不完。</p>
<p>我想说的是，说是跳票到15号。不是就算到15号才拿到货开始发把。既然跳票了，应该把这个发货时间也算进去。比如说15号发，应该是13号左右开始包装填写。然后15号叫来顺丰就妥妥的一次性发出去。坐等用户反馈。都使用跳票技能，就多跳两天准备充分肯定更好。</p>
<h2 id="开启吐槽模式">开启吐槽模式</h2>
<h3 id="到手">到手</h3>
<p>恩，怀着激动的心情。我在17号拿到了bong。</p>
<p>下面是多图杀流量时间</p>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1ebrmul7yq1j20hs0nutcs.jpg" alt=""></p>
<p>盒子怎么说呢。之前在weixin上运营的时候玩了一手，说是第一批盒子质量不好，换了一批，当时似曾相识的感觉。不过我以为是为了追求品质。不过打开顺丰袋子的一个感觉是。艹，这个不会是第一批盒子吧。浓浓的山寨感觉。</p>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1ebrn32vsfkj20hs0nujuy.jpg" alt=""></p>
<p>恩knewone还多送了点东西，不过自己这张贴纸感觉不喜欢。本来想贴到电脑上的。但是上手感觉质量跟github的贴纸有一定差距加上这个小怪物不是我的菜。就没有贴了。然后是钥匙收纳盒。没想到用到哪里。自己住的地方被告知20天内搬离。又是一把辛酸泪。</p>
<p><img src="http://ww1.sinaimg.cn/large/a6d3226bgw1ebrn7laek8j20hs0nuwhv.jpg" alt=""></p>
<p>恩 bong的包装盒就不多说了，几张卡片。一张有团队成员签名。一张是类似说明书。两张强调VIP的尊贵身份。</p>
<h3 id="吐槽手环本身">吐槽手环本身</h3>
<p>首先是外形</p>
<p>官网上是这样<br><img src="http://ww1.sinaimg.cn/large/a6d3226bgw1ebrnhjrlbuj20z10k9769.jpg" alt=""></p>
<p>实际上是这样</p>
<p><img src="http://ww1.sinaimg.cn/large/a6d3226bgw1ebrnospqpyj20jm0qadj0.jpg" alt=""></p>
<p>首先，两头是细的这种设计。啥时候变成了水桶腰设计。</p>
<p>第二，我买的是黑色的把。为啥看着跟银色一个样子。这是cosplay iPhone5s的太空灰么。</p>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1ebrnxonhknj20hs0nuwi1.jpg" alt=""><br>我不知道这张能不能清楚的看到。灯的地方被胶糊住了。这个感觉太恶心了。是拿到手以后最恶心的地方。也可能是期望抱太高了，导致的心里落差。前期的运营以为bong是注重细节的团队。但是嘴上说说和实际做到是有差距的。这里我看见了bong的差距。</p>
<p><img src="http://ww2.sinaimg.cn/large/a6d3226bgw1ebro51k5cqj20hs0nuwi1.jpg" alt=""><br>转过来，我第一次看见bong是怎么充电的。一直说的都是点触式充电。才知道 原来后面有两个孔啊。保密性做的很好啊。然后图上在两个充电孔下面也能清楚的看到，明显的由于某次没有对准而导致使劲压下去造成的刮痕。再次觉得嘴上说说和实际做到是有差距的。</p>
<p>手环的两侧接缝触有一层摸上去明显不平整。</p>
<p>正面上有一条淡淡的线。觉得应该是材质本身的线。但是出现在正面稍微仔细就能看见。</p>
<p>嗯，基本上硬件部分就这么多了。</p>
<h3 id="吐槽说明书以及整个引导流程">吐槽说明书以及整个引导流程</h3>
<p>说明书叫那个简单啊，一个卡片几句话搞定。还以为是已经设计到返璞归真的地步了手上即用。但是还是看了一遍。(此时此刻卡片没在，而且是5天前发生的事情了，凭借印象说了)</p>
<p>首先出现的是一句最好使用PC链接。环顾四周，方圆10米内没有发现一台PC。那OSX可以不可以，我也不知道。唉，先插上试试呗。</p>
<p>接下来一句话引起了我的注意。说的是插上大概五分钟就可以拿下来使用了。！！！！！</p>
<p>插上大概五分钟？是多于五分钟 还是小于5分钟？如果不插会发生什么呢？插到5分钟的时候会发生什么呢？ 插久了又会发生什么呢？有没有提示啊。靠。那5分钟我需要怎么计算呢。打开手机的秒表功能么。我很难想象一个让我都手足无措的东西。去介绍给媳妇儿用。或者带给爸妈用。</p>
<p>然后我以为App里面应该会有详细说明的！！！！结果没有！！！连接前和连接后都没有。</p>
<h3 id="吐槽App">吐槽App</h3>
<p>自己做iOS的，难免吐狠了点。bong团队看到了不要介意。又或者你们都拿到投资了要不把App外包给我们国际大厂Sumi来做把。</p>
<ol>
<li>第一次发短信的时候注册不上</li>
<li>远看想扁平化设计 近看背景还有材质</li>
<li>这是Moves的白天版本么</li>
<li>每次打开都要Loading。为啥不先打开再载入数据啊</li>
<li>我在第三天的时候app叫重新登录一次。然后第一天的数据没了。</li>
<li>为啥tableview上的排列时间是00:00在最上面。不应该是当前时间在第一个位置么</li>
<li>除了跑步以外，其他的都归类到运动里面去了么。分类太少了</li>
<li>各种统计图表有待改进</li>
<li>电量检测不准确 第一次使用了一小时看掉了10%多的电量。现在用了5天了。掉了7%的电量。而且最近两天都没有电量变化</li>
</ol>
<h2 id="吐槽使用中的情况">吐槽使用中的情况</h2>
<ol>
<li>早上唤醒的时候只有一次。现在是冬天啊，不能多摇几次么</li>
<li>一开始我带左手，后来打羽毛球的时候想想带在了右手。导致刷牙的时候会震动一下进入类似散步模式。</li>
<li>不能识别多种运动</li>
<li>记得说过可以记步的。但是实际没有。觉得有记步的数据会更好。</li>
</ol>
<h2 id="总结">总结</h2>
<p>好累啊 写一晚上了就这么多把</p>
<h3 id="优点">优点</h3>
<ul>
<li>自动识别睡眠</li>
<li>防水 可游泳， 虽然我也游了200m的自由泳但是没有识别</li>
<li>如果发第二代的话性价比高</li>
</ul>
<h3 id="缺点">缺点</h3>
<p>今天blog内容。</p>
<h2 id="One_more_thing">One more thing</h2>
<p>如果给我来运营，我会把这次bong的人数控制在200人左右。尽量做好第一批口碑。然后把第一批变成死忠粉。根据反馈来不断迭代很进化。然后在把已经行之有效的小米打法拿来打一次。</p>
<p>其实跳票的时候 只退了10几个人我觉得已经几乎要做到了。但是如果说能收到以后在退款。我想这个数量应该是惊人的。而且把之前前期做的所有努力付之一炬。</p>
<p>然后App的话我会提供很多种运动种类给用户选择。然后数据上传做数据分析和机器学习。这样以后就能识别更多的运动类型了。</p>
<p>恩 福利就说这么多。多的留着啊哈哈。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/just-talk/" term="just-talk"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(31) CocoaPods 手把手五分钟教你制作自己的podspec文件]]></title>
    <link href="http://iiiyu.com/2013/12/19/learning-ios-notes-thirty-one/"/>
    <id>http://iiiyu.com/2013/12/19/learning-ios-notes-thirty-one/</id>
    <published>2013-12-19T12:11:16.000Z</published>
    <updated>2014-02-17T04:20:45.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人记录使用，也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站，这样您将能在第一时间获取本站信息。</p>
<h2 id="开篇扯淡">开篇扯淡</h2>
<p>圣诞渐进，各种App都在黑五一波冰点。可以遇见的是12月25号前也会有一大波来临。但是！！！今年买软件貌似已经花了很多钱了。而且，也没有几个想入的了。所以就忍忍吧。</p>
<p>然后，做个宣传啊。我们国际化大厂Sumi的App Grid Diary在紧锣密鼓的开发2.0. 完全iOS7设计。各种给力。到时候希望能给大家带来一个好的App吧。</p>
<a id="more"></a>

<h2 id="CocoaPods">CocoaPods</h2>
<p>CocoaPods 不必在介绍了吧。如果你是一个iOS or OSX的开发者。然后你跟我说你还没有用过CocoaPods。我肯定会觉得你不够潮(low爆了)。</p>
<p>其实我之前又写过两篇介绍CocoaPods的</p>
<p>只不过时间有点久远了。而且CocoaPods更新很快。有了很多新的特性和功能。 截至我写这篇blog。我的pod version是0.28.0。</p>
<p>不过还是具有参考价值</p>
<p><a href="http://iiiyu.com/2012/10/26/learning-ios-notes-fourteen/">使用CocoaPods</a></p>
<p><a href="http://iiiyu.com/2013/03/01/learning-ios-notes-sixteen/">配置自己的CocoaPods库</a></p>
<h2 id="五分钟手把手">五分钟手把手</h2>
<p>在上面的<a href="http://iiiyu.com/2013/03/01/learning-ios-notes-sixteen/">配置自己的CocoaPods库</a>里面。当时只是初步的使用pods。在学习的过程中。很多理解都很浅显。现在终于用了一年多CocoaPods。有点小心得就来记录一下。</p>
<p>github现在每天必看网站。一个是工作需要，另外一个是上面神奇的东西太多太多了。学无止境啊。</p>
<p>使用CocoaPods管理第三方库有时候就会遇到这样的尴尬。好不容易找到了一个心仪的库,却发现CocoaPods里面搜索不到。</p>
<p>怎么办 怎么办</p>
<p>来乖。手把手交你来写hello world。</p>
<p>栗子：  <a href="https://github.com/premosystems/XCAsyncTestCase" target="_blank">XCAsyncTestCase</a></p>
<p>首先，去把它fork到自己的项目里面去。(什么不会fork？去面壁去)</p>
<p>然后，把fork到自己帐号下的项目clone出来 cd进去</p>
<p>输入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>pod spec <span class="built_in">create</span> <span class="keyword">https</span>://github.com/iiiyu/XCAsyncTestCase
</pre></td></tr></table></figure>

<p>接着你会看到</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613gw1ebpcdvd99xj20lc09f0ui.jpg" alt=""></p>
<p>这个很正常，很多项目都没有tag。反正在自己的下面。可以瞎搞。给项目加入一个tag。以便pod能自动识别。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>git <span class="built_in">tag</span> <span class="attribute">-a</span> <span class="number">0.0</span><span class="number">.1</span> <span class="attribute">-m</span> <span class="string">"Tag release 0.0.1”

git push —tags

rm -rf XCAsyncTestCase.podspec

pod spec create https://github.com/iiiyu/XCAsyncTestCase</span>
</pre></td></tr></table></figure>

<p>接着你会看到</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613gw1ebpcfwf0wsj20i6023mxh.jpg" alt=""></p>
<p>OK。 然后用你自己喜欢的编辑器打开。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>mate XCAsyncTestCase<span class="preprocessor">.podspec</span>
</pre></td></tr></table></figure>

<p>接着其实不用怎么改里面的内容 </p>
<p>我把注释删掉 作者改成原来的作者。然后需要的源码位置改成正确的</p>
<p>大概就是这样</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613gw1ebpcik0lh1j20ry0db0v9.jpg" alt=""></p>
<p>当然 最重要的是s.source_files这个。你要把你要包含的文件路径找对了。 然后用通配符匹配好了。就OK了。</p>
<p>当然其他项，你看看注释啥的 选择性的填一些。在这里是一个五分钟的hello world。不深入讨论</p>
<p>接着 把修改好的文件push到github上去</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>git add XCAsyncTestCase.podspec

git commit -am <span class="string">"add XCAsyncTestCase.podspec file”</span>

git push
</pre></td></tr></table></figure>

<p>最后，在你项目的Podfile里面加入这个第三方库的地址。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>pod <span class="string">'XCAsyncTestCase'</span>, <span class="symbol">:git</span> =&gt; <span class="string">'https://github.com/iiiyu/XCAsyncTestCase.git'</span>
</pre></td></tr></table></figure>

<p>就可以畅快的使用pod install了</p>
<p>五分钟打完收工有木有。很简单直白有木有。</p>
<p>当然这里只是一个hello world。 如果库中有一些高端设置比如要包含资源文件啊。 加入库依赖啊。 配置一些xcconfig。更多内容 请查看<a href="http://cocoapods.org" target="_blank">越来越好看的官方网站</a></p>
<h2 id="CocoaPods福利时间">CocoaPods福利时间</h2>
<p>以下是我平时使用经常用到的Podfile会用到的一些写法。</p>
<h3 id="福利一">福利一</h3>
<p>首先是有一些库编译时候会有警告。但是作为一个有洁癖的人呢不想看见这些</p>
<p>可以在platform :ios,  ‘x.0’的后面加入这句</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="function_or_atom">inhibit_all_warnings</span><span class="exclamation_mark">!</span>
</pre></td></tr></table></figure>

<p>这样编译这些第三方库的时候就没有那些烦人的小警告了。</p>
<h3 id="福利二">福利二</h3>
<p>使用福利一是不是很爽呢。但是有一个神库ReactiveCocoa。当你关闭所有警告的时候。它就编译不过了。可急坏了。其实很简单对他单独设置打开编译警告就好了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>pod <span class="string">'ReactiveCocoa'</span>, <span class="string">'~&gt; 2.1.8'</span>, <span class="symbol">:inhibit_warnings</span> =&gt; <span class="keyword">true</span>
</pre></td></tr></table></figure>

<h3 id="福利三">福利三</h3>
<p>如果你有多个Targets需要pod的库怎么办<br>也很简单。Podfile的头部加入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>link_with [<span class="string">'AAAAA'</span>, <span class="string">'BBBBB'</span>]
</pre></td></tr></table></figure>

<p>AAAAA和BBBBB都是你target的名字，这样不同的target都会有pod库了。我主要是用来解决Unit Test需要pod install一些库的问题。当初也是找了老半天才找到。</p>
<h2 id="总结">总结</h2>
<p>CocoaPods很好用。而且一直在进化。我发现我怎么写介绍都只停留在很浅显的基础上。更多更深入的内容需要自己使用了。然后慢慢积累的。总之。不用CocoaPods的Cocoa开发太不潮了。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(30) Core Data是如何保存的？]]></title>
    <link href="http://iiiyu.com/2013/12/02/learning-ios-notes-thirty/"/>
    <id>http://iiiyu.com/2013/12/02/learning-ios-notes-thirty/</id>
    <published>2013-12-02T10:33:18.000Z</published>
    <updated>2014-02-17T04:20:41.000Z</updated>
    <content type="html"><![CDATA[<p>本文仅作为个人记录使用，也欢迎在<a href="http://creativecommons.org/licenses/by-nc/3.0/deed.zh" target="_blank">许可协议</a>范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用<a href="http://iiiyu.com/atom.xml">RSS</a>方式订阅本站，这样您将能在第一时间获取本站信息。</p>
<h2 id="开场扯淡">开场扯淡</h2>
<p>恩 一个月没有写一篇blog了。恩。就这样把。</p>
<a id="more"></a>

<p>学习使用Core Data也一年多了。之前以为3个月就可以登堂入室。事实是我图样图森破。到现在我也才勉强hello world而已。</p>
<p>比如这个问题 <strong>Core Data是如何保存的</strong>。</p>
<p>一直使用<a href="http://github.com/magicalpanda/MagicalRecord" target="_blank">MagicalRecord</a> 都被宠习惯了。 直接就调用MR_saveToPersistentStoreAndWait。反正能存进去，也没有太仔细的思考。</p>
<p>恩 最近对Core Data的技能点在进行增加中。所以还是多记录一些。</p>
<p>恰好看见了 DM大神的 blog <a href="http://mentalfaculty.tumblr.com/post/65682908577/how-does-core-data-save" target="_blank">How Does Core Data Save?</a></p>
<p>也不算翻译，就是自己写个自己的精简版本看看。</p>
<h2 id="Core_Data是如何保存的">Core Data是如何保存的</h2>
<ol>
<li>当然是NSManagedObjectContext调用save方法的时候。</li>
<li>这时候context里面持有的那些NSManagedObject将会自己调用自己的willSave方法。</li>
<li>NSManagedObjectContextWillSaveNotification发出。</li>
<li>开始验证。这个验证可能是你在data model里面写的。也可以是在NSManagedObject里面代码写的。</li>
<li>验证结束以后数据就合并到NSPersistentStoreCoordinator和NSPersistentStore里面。</li>
<li>如果你在合并的时候更改了数据。这时候会重新验证数据。</li>
<li>这个时候已经把需要验证过的合并数据存到持久化介质当中。</li>
<li>最后NSManagedObjectContextDidSaveNotification这个通知发出。</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<p><a href="http://mentalfaculty.tumblr.com/post/65682908577/how-does-core-data-save" target="_blank">How Does Core Data Save?</a></p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(29) 爱不释手的ReactiveCocoa之UIButton]]></title>
    <link href="http://iiiyu.com/2013/10/15/learning-ios-notes-twenty-nine/"/>
    <id>http://iiiyu.com/2013/10/15/learning-ios-notes-twenty-nine/</id>
    <published>2013-10-15T13:53:11.000Z</published>
    <updated>2014-02-17T04:20:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="开场扯淡">开场扯淡</h2>
<p>ReactiveCocoa的迭代速度相当快，一群富有才华和激情的人们在不断的进化ReactiveCocoa。欣欣向荣的景象啊。我这种hello world级别的也就只能使用他们的劳动成果了。上篇blog的时候我还在用1.9.x的版本 现在我已经全面转向2.x了。值得注意的是霓虹友人提交的cocoapods上ReactiveCocoa 2.1 版本我无法编译通过。目前我使用的还是2.0的版本。</p>
<p>介于一个月没有更新blog的速度，这次来写少一点的内容。</p>
<a id="more"></a>


<h2 id="传统的UIButton_Target_Action_方式">传统的UIButton Target Action 方式</h2>
<p>之前我们使用UIButton的点击方法一般有两种。一种是直接从xib里面拖一个IBAction出来在里面写代码。</p>
<p>另外一种是代码创建的 比如这样 </p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="built_in">UIButton</span> *myButton = [[<span class="built_in">UIButton</span> alloc] init...];
[myButton addTarget:something action:<span class="keyword">@selector</span>(myAction) forControlEvents:UIControlEventTouchUpInside];
</pre></td></tr></table></figure>

<p>然后在下面写一个myAction的方法来进行操作。</p>
<p>这样对我来说存在两个问题：</p>
<ol>
<li>button对应的方法分开了。在阅读代码的时候，当我想知道这个button对应的方法或者反过来action方法对应的button。通常需要跳转一次以上才能知道。(也许是我的阅读代码习惯比较原始)</li>
<li>我在action方法里面如果需要引用一个变量的时候，无法使用局部变量。通常就需要把这个资源设计为一个property。尽管这个资源或者变量只是在action里面调用一次。(这个也许是我写代码的问题)</li>
</ol>
<p>这两个可能在我遇见ReactiveCocoa都不能叫问题。但是在ReactiveCocoa里面我发现了更加优美的解决方法。好开心。</p>
<h2 id="ReactiveCocoa方式的UIButton">ReactiveCocoa方式的UIButton</h2>
<p>由于ReactiveCocoa高深的知识点，我也弄不太清楚。下面我只是说明怎么用的hello world级别。更多内容请阅读github上的项目主页。</p>
<p>如果使用xib。只需拖一个IBOutlet的property出来。比如这样</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIButton</span> *xibButton;
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="built_in">NSString</span> *helloWorld = @<span class="string">"hello world!!!"</span>;
<span class="keyword">self</span><span class="variable">.xibButton</span><span class="variable">.rac_command</span> = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) {
	<span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, helloWorld);
	<span class="keyword">return</span> [RACSignal empty];
}];
</pre></td></tr></table></figure>

<p>如果是代码创建一切照旧</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="built_in">NSString</span> *helloWorld = @<span class="string">"hello world!!!"</span>;
<span class="built_in">UIButton</span> *myButton = [<span class="built_in">UIButton</span> buttonWithType:UIButtonTypeSystem];
myButton<span class="variable">.frame</span> = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">50</span>);
[myButton setTitle:@<span class="string">"Say"</span> forState:UIControlStateNormal];
[<span class="keyword">self</span><span class="variable">.view</span> addSubview:myButton];
myButton<span class="variable">.rac_command</span> = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(<span class="keyword">id</span> input) {
	<span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, helloWorld);
	<span class="keyword">return</span> [RACSignal empty];
}];
</pre></td></tr></table></figure>

<p>这些代码我一般写在viewDidLoad方法里面。当然你可以在正确的地方使用他们。<br>运行试试。哇。魔法一般。完全解决我在传统的UIButton遇到的两个问题。</p>
<h2 id="总结">总结</h2>
<p>嗯嗯，这种小主题的blog写起来轻松愉快。大概40分钟就可以完成。以后要多多写小主题。这样跟写程序一样，化繁为简。这次就少扯淡了。期待我的下篇blog。啊哈哈</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(28) ReactiveCocoa 迎接下一个更加美好的世界（2013-10-13 update 2.0）]]></title>
    <link href="http://iiiyu.com/2013/09/11/learning-ios-notes-twenty-eight/"/>
    <id>http://iiiyu.com/2013/09/11/learning-ios-notes-twenty-eight/</id>
    <published>2013-09-11T12:45:13.000Z</published>
    <updated>2014-02-17T04:20:35.000Z</updated>
    <content type="html"><![CDATA[<h2 id="扯淡">扯淡</h2>
<p>习惯了，每次再写技术的东西的时候总要唠叨几句。本来唠叨的东西我应该会写成另外的blog。不过每次给自己下了一个底线要少少的写这些唠叨的话语。原因一是觉得我爱唠叨的话语可能会导致blog被墙。原因之二我不希望我变成一个IT评论家。</p>
<p>对了,我发现我还是挺爱挖坑的。目前有两坑没有填完。一个是Core Data系列。一个是iCloud系列。两个系列我都只写了一个Hello World级别并没有再深入的继续写。恩，要抓紧了。其实ReactiveCocoa这个我觉得也可以作为一个系列来写。不过想了想我这种Hello World的水平。也写不出这么多来。就暂时写一篇好了。</p>
<a id="more"></a>

<h2 id="什么是ReactiveCocoa">什么是ReactiveCocoa</h2>
<p>如果你有看Github的Trending Objective-C榜单，那你肯定是见过ReactiveCocoa了。如果你在weibo上关注唐巧、onevcat等国内一线知名开发者。那也应该听说过ReactiveCocoa了。</p>
<p>ReactiveCocoa更加被Mattt Thompson大神称为开启一个新Objective-C纪元。</p>
<p>当然也有人声称ReactiveCocoa是Cocoa的未来。<a href="http://spin.atomicobject.com/2013/04/28/reactivecocoa/" target="_blank">ReactiveCocoa: The Future of Cocoa Programming</a></p>
<p>我自己粗犷把现在的Objective-C分为两个阶段。</p>
<p>第一个阶段就是我学Cocoa开发之前的阶段：就是把Objective-C做出来的那群NeXT的大神，确定面向对象思想，确定消息机制，确定各种模式最后变成了Apple的主力开发语言。到后面OS X的各种库。iOS的各种库。</p>
<p>第二个阶段就是我学Cocoa开发之后的阶段：开始clang发力，配合Objective-C的快速进化：ARC，block，现代Objective-C语法。使其Objective-C不断获得现代语言类如Ruby, Python的优秀特性。</p>
<p>现在，说的最多的就是ReactiveCocoa将会把Objective-C带到下一个里程碑中。</p>
<p>ReactiveCocoa是一个基于Functional Reactive Programming编程思想的Objective-C实现开源的第三方库。最初的作者是Github的大神（Josh Abernathy &amp; Justin Spahr-Summers）。应该是再开发Github For Mac时候的附属产物。当然，我们必需得明白有时候附属产物要比真主牛逼的多了去了。比如万艾可，再比如青霉素，再再比如老干妈。</p>
<p>等等 什么是Functional Reactive Programming</p>
<h3 id="Functional_Reactive_Programming">Functional Reactive Programming</h3>
<p><a href="http://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank">wiki解释</a></p>
<h4 id="Reactive_Programming">Reactive Programming</h4>
<p><a href="http://zh.wikipedia.org/wiki/响应式编程" target="_blank">wiki 响应式编程</a></p>
<h4 id="Functional_programming">Functional programming</h4>
<p><a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank">wiki Functional programming</a></p>
<p>恩 简单来说 </p>
<pre><code><span class="attribute">Functional Reactive Programming </span>=<span class="string"> Functional programming + Reactive Programming</span>
</code></pre><p>(PS:特么太偷懒了还是解释一下)</p>
<p>简单以</p>
<p>a = b + c</p>
<p>为例</p>
<p>通常情况下在执行a = b + c的值的时候b和c当时是什么值。a就是当时的b+c。然后后来不管b和c怎么变化，a都不会改变。</p>
<p>但是在Execl中设置a格子=b格子+c格子的值。a的值就会随着b和c值的改变而改变。然后我还可以搞的高级一点f = a + d。 f格子的值也会随着b、c、d的值而改变。这就是使用Functional Reactive Programming以后会发生的情况。</p>
<p>Reactive的特性使得可以随时响应变化。Functional的特性使得他们可以串起来。</p>
<h3 id="来自微软实验室的编程思想">来自微软实验室的编程思想</h3>
<p>在<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/README.md#more-info" target="_blank">ReactiveCocoa的readme</a>我们看到ReactiveCocoa是基于.NET的Reactive Extensions(Rx)来的。啧啧身为一个脑残果粉不解释的我。也必须承认微软其实曾经一度集聚这世界上一大批大牛。这批大牛在闲着玩的时候做出来的玩具也指不定哪天就拯救世界了。</p>
<h4 id="Rx">Rx</h4>
<p>所以我也找了点Rx的资料来看看</p>
<p>中文里面比较全面的是这个<br><a href="http://www.cnblogs.com/yangecnu/archive/2012/11/03/Introducting_ReactiveExtensions.html" target="_blank">Reactive Extensions入门</a></p>
<p>里面有一堆链接和一个视频。c#实在看不懂，就只看了15分钟左右。不过那看上去蛮帅的哥们一开始说他在编程中遇到的问题。恰巧是我最近遇到的问题：就是我有两个在非主线程的异步操作。而我有可能需要等两个异步操作都完成的时候进行下一步操作。这种情况我一直没有找到比较优美的解决方法。直到遇见ReactiveCocoa，仿佛看见了希望。</p>
<h4 id="Model-View-ViewModel">Model-View-ViewModel</h4>
<p><a href="http://en.wikipedia.org/wiki/Model_View_ViewModel" target="_blank">洋文wiki</a></p>
<p><a href="http://baike.baidu.com/view/3507915.htm" target="_blank">中文wiki</a></p>
<p>FRP倾向于技术理论上的方法论。MVVM则是程序模式的方法论。就好比FRP给了一把解牛的刀。MVVM就是如何解牛的方法论。</p>
<p>相对来说MVVM通常跟MVC拿来比较。在我看来，没有绝对的好和坏。找个适合的就好了。再说我对两个东西的了解不够深入。</p>
<p><a href="http://cocoasamurai.blogspot.com/2013/03/basic-mvvm-with-reactivecocoa.html" target="_blank">Basic MVVM with ReactiveCocoa</a></p>
<p>这篇blog应该就写的蛮清楚了。</p>
<p>这是github上iOS的 MVVM例子<a href="https://github.com/Machx/MVVM-IOS-Example" target="_blank">MVVM-IOS-Example</a></p>
<p>大家可以感受一下。</p>
<h2 id="ReactiveCocoa的基本使用方法">ReactiveCocoa的基本使用方法</h2>
<p>(终于写到正主了,泪流满面)</p>
<p>这里借用Limboy的<a href="http://blog.leezhong.com/ios/2013/06/19/frp-reactivecocoa.html" target="_blank">blog</a>中的一段话作为开场解释。(因为我想了好久都没有想出超过他的比喻方法)</p>
<pre><code><span class="tag">ReactiveCocoa</span>是<span class="tag">github</span>去年开源的一个项目，是在<span class="tag">iOS</span>平台上对<span class="tag">FRP</span>的实现。<span class="tag">FRP</span>的核心是信号，信号在<span class="tag">ReactiveCocoa</span>(以下简称<span class="tag">RAC</span>)中是通过<span class="tag">RACSignal</span>来表示的，信号是数据流，可以被绑定和传递。
可以把信号想象成水龙头，只不过里面不是水，而是玻璃球(<span class="tag">value</span>)，直径跟水管的内径一样，这样就能保证玻璃球是依次排列，不会出现并排的情况(数据都是线性处理的，不会出现并发情况)。水龙头的开关默认是关的，除非有了接收方(<span class="tag">subscriber</span>)，才会打开。这样只要有新的玻璃球进来，就会自动传送给接收方。可以在水龙头上加一个过滤嘴(<span class="tag">filter</span>)，不符合的不让通过，也可以加一个改动装置，把球改变成符合自己的需求(<span class="tag">map</span>)。也可以把多个水龙头合并成一个新的水龙头(<span class="tag">combineLatest</span><span class="pseudo">:reduce</span><span class="pseudo">:)</span>，这样只要其中的一个水龙头有玻璃球出来，这个新合并的水龙头就会得到这个球。
</code></pre><h3 id="替代KVO">替代KVO</h3>
<p><del>官方例子：官方的例子貌似用了比较老的函数。我改完以后看见<a href="http://www.jdon.com/45581" target="_blank">什么是函数响应式编程(Functional Reactive Programming:FRP)</a>他也是这么改的。说明一下。</del></p>
<p>经过后来的使用才发现特么官方例子是2.0的。 现在重新改一下。随便说一句，用cocoapods安装的2.1.编译不过。具体原因还没有看。建议使用2.0</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">@property</span> (<span class="keyword">strong</span>) <span class="built_in">NSString</span> *username;

[RACObserve(<span class="keyword">self</span>, username) subscribeNext:^(<span class="built_in">NSString</span> *newName) {
								<span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, newName);
							}];
</pre></td></tr></table></figure>

<p>在这句代码以后，只要你的username有变化。都可以打印出来。实现了KVO的功能却减少了无数的代码。体现了绑定和响应。</p>
<p>高级一个点的官方例子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>[[RACObserve(<span class="keyword">self</span>, username)
  filter:^(<span class="built_in">NSString</span> *newName) {
		<span class="keyword">return</span> [newName hasPrefix:@<span class="string">"j"</span>];
	}]
 subscribeNext:^(<span class="built_in">NSString</span> *newName) {
	 <span class="built_in">NSLog</span>(@<span class="string">"%@"</span>, newName);
 }];
</pre></td></tr></table></figure>

<p>第一个例子是简单的所有变化都会响应到。但是可能我只想响应部分情况。这时候就用filter来过滤。filter的block返回YES的情况就是需要触发的情况。其他就补返回。所以这代码以后。 username以j开头的才能打印出来。</p>
<h3 id="流的实现">流的实现</h3>
<p>以下是<a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/" target="_blank">Getting Started with ReactiveCocoa</a>的例子和图片</p>
<p>如何以最少的代码实现一个时钟应用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>RAC(<span class="keyword">self</span>, timeLabel<span class="variable">.text</span>) = [[[RACSignal interval:<span class="number">1</span> onScheduler:[RACScheduler currentScheduler]] startWith:[<span class="built_in">NSDate</span> date]] map:^<span class="keyword">id</span> (<span class="built_in">NSDate</span> *value) {
	<span class="built_in">NSLog</span>(@<span class="string">"value:%@"</span>, value);
	NSDateComponents *dateComponents = [[<span class="built_in">NSCalendar</span> currentCalendar] components:NSHourCalendarUnit |
	 NSMinuteCalendarUnit | 
	 NSSecondCalendarUnit fromDate:value];
	<span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:@<span class="string">"%02ld:%02ld:%02ld"</span>, (<span class="keyword">long</span>)dateComponents<span class="variable">.hour</span>, (<span class="keyword">long</span>)dateComponents<span class="variable">.minute</span>, (<span class="keyword">long</span>)dateComponents<span class="variable">.second</span>];
}];
</pre></td></tr></table></figure>

<p>实现的逻辑顺序是这样的。设置一个间隔为一秒。从现在开始调用的函数。并把当前实际传入。 这个函数返回一个NSString。 然后把这个NSString和界面上的textField绑定在了一起。从而实现了我认为我见过最简单时钟程序。表现了流和绑定响应。</p>
<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/chaining.png" alt="原blog中对上述代码的流的形容图"></p>
<h3 id="组合">组合</h3>
<p>几乎每个ReactiveCocoa的Demo里面都会出现的例子。</p>
<p>(继续盗图图)</p>
<p><img src="http://blog.leezhong.com/image/FRP_register_demo.png" alt=""></p>
<p>这个是用的leezhong的图。 应该是从<a href="https://speakerdeck.com/andrewsardone/reactivecocoa-at-mobidevday-2013" target="_blank">这个演讲PPT里面来的，点过去还有视频哦</a></p>
<p>就是说在必需验证每个所填写的数值符合标准。Button才能点击。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>RAC(<span class="keyword">self</span>, submitButton<span class="variable">.enabled</span>) = [RACSignal combineLatest:@[<span class="keyword">self</span><span class="variable">.usernameField</span><span class="variable">.rac_textSignal</span>,
				 <span class="keyword">self</span><span class="variable">.passwordField</span><span class="variable">.rac_textSignal</span>]
	reduce:^<span class="keyword">id</span> (<span class="built_in">NSString</span> *userName, <span class="built_in">NSString</span> *password) {
	<span class="keyword">return</span> @(userName<span class="variable">.length</span> &gt;= <span class="number">6</span> && password<span class="variable">.length</span> &gt;= <span class="number">6</span>);
}];
</pre></td></tr></table></figure>

<p>简单的解释就是把usernameField和passwordField的信号绑定在了一起做reduce处理以后。返回一个BOOL值去跟self.submitButton.enabled进行绑定。</p>
<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/combining.png" alt=""></p>
<p>囧。再次发现和leezhong借用的代码和图都是一样的。</p>
<h3 id="异步和网络">异步和网络</h3>
<p>(丢个链接 等心情好了 在补。。。)</p>
<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa#when-to-use-reactivecocoa" target="_blank">when-to-use-reactivecocoa</a></p>
<h2 id="总结">总结</h2>
<p>其实我对ReactiveCocoa了解还是在hello world阶段。 很多东西都理解的很粗糙。上面这一大陀blog。很多地方写的肯定不好。欢迎指出。其实很多时候觉得确实中文原创的技术文章十分少。很大一部分都是翻译的。国外的技术文章也确实写的牛写的好。但是总觉得自己应该写点自己思考的东西。</p>
<p>对于ReactiveCocoa来说，我认为它确实是一个好东西。正如leezhong所说<br>    RAC统一了对KVO、UI Event、Network request、Async work的处理，因为它们本质上都是值的变化(Values over time)。</p>
<p>其实App上90%的操作不就只有这些么。所以我会一直对ReactiveCocoa投入时间去学习和使用。顺便说一句。阿里Mac Lab出品的Xiami for Mac。是我见过国内最好的Mac App之一。他们也用了ReactiveCocoa。然后你可以想象对他们做出那些响应交互ReactiveCocoa为他们提供了强有力的输出。</p>
<h2 id="参考资料">参考资料</h2>
<h3 id="FRP">FRP</h3>
<p><a href="http://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank">wiki Functional reactive programming</a></p>
<p><a href="http://blog.zhaojie.me/2009/09/functional-reactive-programming-for-csharp.html" target="_blank">趣味编程：Functional Reactive Programming</a></p>
<p><a href="http://www.haskell.org/haskellwiki/Functional_Reactive_Programming" target="_blank">haskell Functional Reactive Programming</a></p>
<p><a href="http://zh.wikipedia.org/wiki/响应式编程" target="_blank">wiki 响应式编程</a></p>
<p><a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank">wiki Functional programming</a></p>
<p><a href="http://www.infoq.com/cn/articles/functional-reactive-programming" target="_blank">函数式反应型编程(FRP) —— 实时互动应用开发的新思路</a></p>
<p><a href="http://www.jdon.com/45581" target="_blank">什么是函数响应式编程(Functional Reactive Programming:FRP)</a></p>
<p><a href="http://www.cnblogs.com/yangecnu/archive/2012/11/03/Introducting_ReactiveExtensions.html" target="_blank">Reactive Extensions入门</a></p>
<h3 id="ReactiveCocoa">ReactiveCocoa</h3>
<p><a href="http://blog.leezhong.com/ios/2013/06/19/frp-reactivecocoa.html" target="_blank">ReactiveCocoa与Functional Reactive Programming</a></p>
<p><a href="https://speakerdeck.com/joshaber/better-code-for-a-better-world" target="_blank">Better Code for a Better World by Josh Abernathy</a></p>
<p><a href="http://nshipster.com/reactivecocoa/" target="_blank">nshipster Reactive​Cocoa</a></p>
<p><a href="http://spin.atomicobject.com/2013/04/28/reactivecocoa/" target="_blank">ReactiveCocoa: The Future of Cocoa Programming</a></p>
<p><a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/" target="_blank">Getting Started with ReactiveCocoa</a></p>
<p><a href="http://www.teehanlax.com/blog/reactivecocoa/" target="_blank">Functional Reactive Programming on iOS with ReactiveCocoa</a></p>
<p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/BasicOperators.md" target="_blank">Basic Operators</a></p>
<p><a href="http://cocoasamurai.blogspot.com/2013/03/basic-mvvm-with-reactivecocoa.html" target="_blank">Basic MVVM with ReactiveCocoa<br>MVC - One Pattern to Rule them all</a></p>
<p><a href="http://twocentstudios.com/blog/2013/04/03/the-making-of-vinylogue/#design" target="_blank">How I Wrote Vinylogue for iOS With ReactiveCocoa</a></p>
<p><a href="https://github.com/RoCry/rocry.github.com/wiki/Project_ReactiveCocoa" target="_blank">来自好友RoCry的推荐</a></p>
<p><a href="https://speakerdeck.com/andrewsardone/reactivecocoa-at-mobidevday-2013" target="_blank">ReactiveCocoa at MobiDevDay 2013</a></p>
<p><a href="https://vimeo.com/65637501" target="_blank">ReactiveCocoa at MobiDevDay 2013视频</a></p>
<p><a href="http://blog.maybeapps.com/#fn:p42894317939-5" target="_blank">Input and Output</a></p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(27) iCloud(三) key-Value Stroe]]></title>
    <link href="http://iiiyu.com/2013/09/02/learning-ios-notes-twenty-seven/"/>
    <id>http://iiiyu.com/2013/09/02/learning-ios-notes-twenty-seven/</id>
    <published>2013-09-02T14:21:13.000Z</published>
    <updated>2014-02-17T04:20:22.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是NSUserDefaults">什么是NSUserDefaults</h2>
<p>NSUserDefaults的持久化本体是一个<a href="http://zh.wikipedia.org/zh/Plist" target="_blank">plist</a>.内存单例是一个操作类似NSDictionary的类。 而NSUserDefaults的出现我想是因为在每一个程序当中。我们都会设定一些选项。比如桌面壁纸、声音大小、提醒日期等，我们希望就算App关闭以后。我们再次打开的时候还在的东西。但是它并不适合存储App中关键的内容和用户自己产生的大量数据。 大量数据应该用更加合理的方式去做持久化(Document or Core Data).</p>
<a id="more"></a>

<h3 id="NSUserDefaults简单代码讲解">NSUserDefaults简单代码讲解</h3>
<p>使用NSUserDefaults其实巨简单。 </p>
<p>大概步骤如下:</p>
<ol>
<li>首先通过一个单例获得持久化plist的内存映射。</li>
<li>然后就可以用这个单例的实例类进行读写操作。</li>
<li>读当然没啥问题，但是写了的话这时候只是操作了在内存里面的这个单例实例。需要做持久化的动作。为什么这个动作要自己来做呢。我想是持久化都是进行IO操作。而IO操作其实很多时候就是性能的瓶颈所在。我们可能很短的时间内一次性操作很多次NSUserDefaults。这样就只用在结束的时候保存一次。IO操作就很少。反之如果每次写NSUserDefaults的时候都去做持久化。那刚刚的情况就会在很短的时间内操作多次IO。这是应该避免的。</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="comment">// 首先把数据从plist里面读到内存里面的单例来</span>
<span class="built_in">NSUserDefaults</span> *standardDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];

<span class="comment">// 进行增加or修改操作</span>
[standardDefaults setObject:@<span class="string">"a123456789"</span> forKey:@<span class="string">"userID"</span>];
[standardDefaults setInteger:<span class="number">24</span> forKey:@<span class="string">"age"</span>];
[standardDefaults setBool:<span class="literal">YES</span> forKey:@<span class="string">"isLogin"</span>];

<span class="comment">// 删除操作</span>
[standardDefaults removeObjectForKey:@<span class="string">"debts"</span>];

<span class="comment">// 从内存里面写入plist进行持久化</span>
[standardDefaults synchronize];

<span class="comment">// 读取操作</span>
<span class="built_in">NSString</span> *userID = [standardDefaults stringForKey:@<span class="string">"userID"</span>];
<span class="built_in">BOOL</span> isLogin = [standardDefaults boolForKey:@<span class="string">"isLogin"</span>];
</pre></td></tr></table></figure>

<p>当然还有现代一点的写法。下面两种都是一个效果</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// 常见方法</span>
<span class="built_in">NSUserDefaults</span> *standardDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];
<span class="keyword">if</span> ([standardDefaults stringForKey:@<span class="string">"favoriteColor"</span>] == <span class="literal">nil</span>) {
[standardDefaults setObject:@<span class="string">"Green"</span> forKey:@<span class="string">"favoriteColor"</span>];
[standardDefaults synchronize];
}

<span class="comment">// 现代高端上档次方法</span>
<span class="built_in">NSUserDefaults</span> *standardDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];
[standardDefaults registerDefaults:@{@<span class="string">"favoriteColor"</span>: @<span class="string">"Green"</span>}];
[standardDefaults synchronize];
</pre></td></tr></table></figure>

<h2 id="iCloud的Key-Value">iCloud的Key-Value</h2>
<p>简单的，可以把iCloud的key-value当作一个在云端的NSUserDefaults。</p>
<p>我的用法是，App的Setting最终设置决定的还是NSUserDefaults。iCloud的Key-Value作为数据源来对NSUserDefaults进行修改。这样的优点在于，就算iCloud关闭或者iCloud的数据没有同步回来。你的App依然可以正常的工作和运行。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">NSUserDefaults</span> *standardDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];
</pre></td></tr></table></figure>

<p>对应</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="attribute">NSUbiquitousKeyValueStore* store </span>=<span class="string"> [NSUbiquitousKeyValueStore defaultStore];</span>
</pre></td></tr></table></figure>

<p>其他操作跟NSUserDefaults一样一样的。</p>
<p>只有一个值得注意的是NSUbiquitousKeyValueStore需要去监听<br>NSUbiquitousKeyValueStoreDidChangeExternallyNotification事件。就可以知道NSUbiquitousKeyValueStore是否已经同步更新完成。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>NSUbiquitousKeyValueStore* store = [NSUbiquitousKeyValueStore defaultStore];
[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span>
          selector:<span class="keyword">@selector</span>(updateKVStoreItems:)
          name:NSUbiquitousKeyValueStoreDidChangeExternallyNotification
          object:store];
[store synchronize];
</pre></td></tr></table></figure>

<p>然后实现updateKVStoreItems:方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)updateKVStoreItems:(<span class="built_in">NSNotification</span>*)notification {
   <span class="comment">// Get the list of keys that changed.</span>
   <span class="built_in">NSDictionary</span>* userInfo = [notification userInfo];
   <span class="built_in">NSNumber</span>* reasonForChange = [userInfo objectForKey:NSUbiquitousKeyValueStoreChangeReasonKey];
   <span class="built_in">NSInteger</span> reason = -<span class="number">1</span>;
 
   <span class="comment">// If a reason could not be determined, do not update anything.</span>
   <span class="keyword">if</span> (!reasonForChange)
      <span class="keyword">return</span>;
 
   <span class="comment">// Update only for changes from the server.</span>
   reason = [reasonForChange integerValue];
   <span class="keyword">if</span> ((reason == NSUbiquitousKeyValueStoreServerChange) ||
         (reason == NSUbiquitousKeyValueStoreInitialSyncChange)) {
      <span class="comment">// If something is changing externally, get the changes</span>
      <span class="comment">// and update the corresponding keys locally.</span>
      <span class="built_in">NSArray</span>* changedKeys = [userInfo objectForKey:NSUbiquitousKeyValueStoreChangedKeysKey];
      NSUbiquitousKeyValueStore* store = [NSUbiquitousKeyValueStore defaultStore];
      <span class="built_in">NSUserDefaults</span>* userDefaults = [<span class="built_in">NSUserDefaults</span> standardUserDefaults];
 
      <span class="comment">// This loop assumes you are using the same key names in both</span>
      <span class="comment">// the user defaults database and the iCloud key-value store</span>
      <span class="keyword">for</span> (<span class="built_in">NSString</span>* key in changedKeys) {
         <span class="keyword">id</span> value = [store objectForKey:key];
         [userDefaults setObject:value forKey:key];
      }
   }
}
</pre></td></tr></table></figure>

<p>超级简单吧。</p>
<h2 id="第三方库推荐">第三方库推荐</h2>
<p>当然有大神写的第三方库。并且实现了NSUserDefaults白名单功能。因为可能你存在NSUserDefaults里面的东西不想要也不需要全部同步到NSUbiquitousKeyValueStore上去把。</p>
<p>对了忘记说一点NSUbiquitousKeyValueStore可是有大小和条目限制的。你不要把他当作无穷无尽的东西来用。具体限制是最大空间1 MB。 最多1024个key。记住不要拿来当作主要数据存储哦。</p>
<p>MK大神应该还是如雷贯耳的把。 不知道么。 MKNetworkKit是他写的。还不知道么。<br><a href="http://www.amazon.com/gp/product/1118449959/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1118449959&amp;linkCode=as2&amp;tag=blogmugunthku-20" target="_blank">iOS 6 Programming Pushing the Limits: Advanced Application Development for Apple iPhone, iPad and iPod Touch</a> 可是他写的哦。我和我的小伙伴都从MK大神的书里面学到很多不错的东西</p>
<p><a href="https://github.com/MugunthKumar/MKiCloudSync" target="_blank">MKiCloudSync</a></p>
<p><a href="https://github.com/Daij-Djan/DDiCloudSync" target="_blank">DDiCloudSync</a></p>
<p><a href="https://github.com/futuretap/FTiCloudSync" target="_blank">FTiCloudSync</a></p>
<h2 id="总结">总结</h2>
<p>参考资料：</p>
<p><a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/UserDefaults/Introduction/Introduction.html" target="_blank">Preferences and Settings Programming Guide</a></p>
<p><a href="http://gibuloto.com/blog/nsuserdefaults/" target="_blank">NSUserDefaults (plist) 筆記</a></p>
<p><a href="http://www.doubleencore.com/2013/03/back-to-basics-forgotten-nsuserdefaults/" target="_blank">Back to Basics: Forgotten NSUserDefaults</a></p>
<p><a href="http://www.techotopia.com/index.php/Synchronizing_iPhone_iOS_5_Key-Value_Data_using_iCloud" target="_blank">Synchronizing iPhone iOS 5 Key-Value Data using iCloud</a></p>
<p><a href="http://useyourloaf.com/blog/2011/10/24/sync-preference-data-with-icloud.html" target="_blank">Sync Preference Data With iCloud</a></p>
<p><a href="http://www.raywenderlich.com/6015/beginning-icloud-in-ios-5-tutorial-part-1" target="_blank">Beginning iCloud in iOS 5 Tutorial Part 1</a></p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(26) iCloud(二) 准备工作]]></title>
    <link href="http://iiiyu.com/2013/08/26/learning-ios-notes-twenty-six/"/>
    <id>http://iiiyu.com/2013/08/26/learning-ios-notes-twenty-six/</id>
    <published>2013-08-26T14:43:11.000Z</published>
    <updated>2014-02-17T04:20:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="开发支持iCloud的上半部分前期准备">开发支持iCloud的上半部分前期准备</h2>
<ul>
<li><p>需要申请一个开发者的帐号。理论上iOS和Mac OSX的都OK。考虑到我只有iOS的情况下，我的文章里面的例子默认只是iOS的。</p>
</li>
<li><p>你需要一台iOS设备，并且iOS版本必须大于等于5.最好大于等于6. 最最好大于等于7。</p>
</li>
<li><p>Xcode不用说至少是MAS里面最新的</p>
</li>
<li><p>然后去建立App Bundle ID的页面去把iCloud支持打开。</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e88hq7q78aj20sa0g2tav.jpg" alt="1"></p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e88hqn9gdej20s60h2wgz.jpg" alt="2"></p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e88hqn9gdej20s60h2wgz.jpg" alt="3"></p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e88hts5dkpj20k70en75m.jpg" alt="4"></p>
<ul>
<li>bundle id需要生成带你测试设备的证书</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e88htyxylrj20rw0egmzm.jpg" alt="5"></p>
<p>(PS:截图太累了 换成文章描述)</p>
<p>这样才能算iCloud的前期工作做完了一半。</p>
<p><strong>以下涉及到NDA内容请自行屏蔽</strong><br><a id="more"></a></p>
<ul>
<li>据说Xcode5里面支持直接开启iCloud支持，推送服务支持等。不用去登录网页了。</li>
</ul>
<ul>
<li>据说Xcode5支持iCloud调试了不需要真机了。可是特么只是支持iCloud Key-Value。Document和Core Data还是需要你一台强力的真机。</li>
</ul>
<p>(详细和剩下的大家自行脑补)</p>
<h2 id="开发支持iCloud的下半部分前期准备">开发支持iCloud的下半部分前期准备</h2>
<ul>
<li>建立一个跟上部分bundle id一样的工程项目</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e88iciw7yaj212w0qfn0a.jpg" alt="6"></p>
<ul>
<li><p>然后在工程里面把entitlements勾上以后。</p>
</li>
<li><p>支持key-value stroe把勾选上</p>
</li>
<li><p>支持Document和Core Data要添加ubiquity containers</p>
</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e88id4vlv3j20jc0a63z9.jpg" alt="7"></p>
<p>到这里，总算是把准备工作弄好了。每一个支持iCloud的App。都必须经过上面的步骤。不可跳过直接去写代码。切记切记。</p>
<h2 id="开发iCloud基本思维">开发iCloud基本思维</h2>
<ol>
<li>iCloud是网络远端的数据存储服务。最终目的是确保所有设备上的所有数据一致性。 </li>
<li>使用iCloud的机制不是纯网络服务。简单的说就是在没有网络的情况下。你的App应该是可以畅通无阻的运行，并且没有缺失功能。iCloud存储的是数据的源头，App里面应该会有对应的缓存确保这样的机制。所以有多少台设备，就有多少份缓存的数据。</li>
<li>缓存数据的份数多了，为了保持数据的一致性。需要同步机制来保持更新，这时候不可避免的会产生数据冲突。就需要解决冲突。</li>
</ol>
<p>所以，只要是使用了iCloud。不论那种形式。我们都必须面对下面的几种情况并且需要对这些情况进行响应的处理：</p>
<ol>
<li>何时开启iCloud同步服务</li>
<li>在App内部关闭了iCloud以后，App的应对措施。</li>
<li>在App外部关闭了iCloud以后，App的应对措施。</li>
<li>开启iCloud以后，iCloud数据和本地数据之间的处理。</li>
<li>开启iCloud以后，正在同步数据时，UI的应对措施。</li>
<li>使用iCloud以后，当数据完成更新的时候。UI的应对措施。</li>
<li>iCloud数据冲突时候App的处理。</li>
</ol>
<p>以上是临时能回忆起来的一些需要处理的情况。真实情况可能要复杂的多。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[深夜吐槽多看]]></title>
    <link href="http://iiiyu.com/2013/08/22/tu-cao-duo-kan/"/>
    <id>http://iiiyu.com/2013/08/22/tu-cao-duo-kan/</id>
    <published>2013-08-21T17:48:34.000Z</published>
    <updated>2014-02-17T04:19:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="深夜吐槽多看">深夜吐槽多看</h2>
<p>好吧，作为一个喜欢看书的人和觉得多看做的确实好的普通用户。我把我个人的想法完整的表达一下。</p>
<a id="more"></a>

<h2 id="前提">前提</h2>
<p>首先，在国内阅读App上对我来说。多看目前已经遥遥领先。其实记得当初在iOS上引爆中文阅读的是唐茶从&lt;失控&gt;到&lt;史蒂夫·乔布斯传&gt;。让人觉得电子中文阅读还可以这么美。而多看是从Kindle起来，所以说做阅读的时间不比唐茶短。真正的混战是在字节社、多看(更新了一个版本)、豆瓣阅读上。三个App我都在对比，都在用。KK的全部书籍我都是在字节社买的。当时字节社的书更新较快。多看出于一个跟随者的角色当中。一般是字节社上了多看才上。两个都想做成中文电子书的最大平台，那时候机会看起来势均力敌甚至字节社还要有一些优势。其实那时候我喜欢的豆瓣阅读的风格。豆瓣阅读的设计平淡如茶。不像字节社的大红和多看的大黄。可惜豆瓣貌似没有想往阅读方向上大力发展。至于现在，半年都不更新一次的豆瓣阅读已经很少打开了。简单点说后来是字节社被下架很长时间。书目的种类和网上书店被多看给超越。多看也在一直努力。App做的越来越好,UI交互的重新设计，PDF的重排达到逆天的级别(我想这跟Kindle的技术积累密不可分)。至于我现在想买书的首选是多看。这段主要是表达我确实是喜欢多看阅读的。</p>
<p>其次，说一下我不喜欢的。 我不喜欢小米。跟我不喜欢隔壁大胸的妹子理由一样。 不喜欢就不喜欢呗，跟她胸大不大没关系。虽然现在多看和小米是好基友。看意图也是多看要成为小米整个体系重要的一部分。问题是我特么的不喜欢小米，没有小米手机。我就是一个普普通通的多看用户。我想用多看，而不是想用小米的一部分。然后这里就能说到帐号迁移了。我根本不想迁移去变成小米帐号。为此我还特意去多看的官网上面去看了Q&amp;A.得到的结论就是迁移是必需的。必需就是没有选择的余地。我真心觉得这个迁移很恶心，至少恶心到我觉得如果我能找到一个替代的App。我宁愿去用其他的App。结果目前还真没有能替代多看的。悲从心中来啊。虽然说迁移给了5米币啥的。但是感觉上就是把人领出去卖了，然后在卖的路上买了颗糖给吃的感觉。</p>
<h2 id="发现Bug">发现Bug</h2>
<p>相当相当的不爽。但是这些恶心的事情，都没有能阻止我想用多看看书的欲望。当我发现多看居然在搞活动。100以下卖多少送多少。想想每月买书支出应该也有个两三百。所以相当于5折了。心想还不错。暂时不想迁移这个事情来恶心自己了。结果特么在开始前的半小时我发现，特么只能是Android用户才有优惠顿时崩溃了。感觉不会在爱了，赶紧在微波上@多看的运营妹子问怎么办。然后回复我叫我借一台Android在上面购买。我方圆几百公里就特么认识一台Android。赶紧过去献媚的叫人家借我用用。 当我小心翼翼的捧这高端大气上档次的米1笨手笨脚的登录多看的时候。觉得能剩点钱还是值得的。当我点开多看准备把冯唐的书全部收掉的时候。发现都是下载。没有购买。赶紧问问手机的高富帅。人家说刚刚买了这几本！！！！多看你是闹那样。登出了这种私人用户信息都不清空。思考了一下。征求了高富帅的意见，我把多看App删除了。然后用高富帅的3G网络畅快的重新下载了一个多看App。然后又小心翼翼的捧这高端大气上档次的米1笨手笨脚的登录多看。结果特么结果还是一样的啊。人家购买过的。我没有购买的登录进去是下载，不是购买。简单点说就是大Bug啊。用户信息都特么乱穿掉了。这时候我只能手里握着100块。以45度仰望天空。默默的在微波上留言吐槽一下。</p>
<h2 id="回应反馈">回应反馈</h2>
<p>接下来是回应一下 happia 这位应该是多看员工。</p>
<p>happia的回复我整理一下大概内容如下：</p>
<p>我：为什么只有Android做活动？</p>
<p>happia：这次之所以指定了平台，是米币中心出于安全考虑，只允许在手机上进行。其实iOS平台和Kindle平台都不支持用米币买书，这个限制只是不允许在网页上参与。</p>
<p>我：为什么会有用户信息在登出的情况下还会混乱的bug？</p>
<p>happia：1、因为这次是米币第一次做公开的优惠活动，所以会谨慎很多，涉及到大规模交易的事情都要很小心，弄不好最后银行结算会出大问题。现在还在积累电子支付经验的阶段。2、这本书如果已经下载了，那就不会再显示购买按钮，而是显示阅读。你在书架上看看有没有这本书？</p>
<p>对于绝大多数情况，这样是最好的选择</p>
<p>简单的说，一个手机上在多看阅读上上用多个账户的情况很少，而且既然书架上已经有了，又要去换个账号买一次的情况更少。既然书架上已经有了，一般人都会直接打开，而不会再去买一次。这个情况已经属于特例中的特例了。</p>
<p>下面是回复吐槽：</p>
<p>至今没有搞懂你们策划为什么不允许在网页上参与。解释为支付安全考虑。毫无说服力，就算说策划的只想做Android就不做其他我都能接受。因为根本无法理解Android上支付能比网页支付安全。更何况可以是在你Android上购买了然后跳转到支付宝去网页上支付。还是说只要对普通用户解释为安全问题比较好解释？</p>
<p>米币。呵呵都往虚拟货币搞。 想的倒是很美好。这也是为什么我不想迁移的原因。</p>
<p>然后是bug的解释。我在微波上回复了一句：神逻辑。现在来解释一下什么意思.我工作以后渐渐的受到影响还是蛮尊重版权。现在电脑上可以自豪的说是全正版。反正买不起的就不用了呗。因为既然我喜欢的软件我希望作者在把他做的更好。对于书也是一样，我喜爱的文字，喜欢的思想。我都愿意付出一点。让作者能够收获一些。继续写出好看的文字，重要的智慧。让他知道自己的付出是有收获的。扯远了。 拉回来。</p>
<p>所以，当我用我的帐号去登录多看的时候。这时候的信息应该是我的。就算之前的帐号有下载过书籍作为缓存。但是我的帐号里面没有这本书，这本书是不应该显示在书架上的。然后我也可以购买啥的。这个对于我来说才是正常逻辑。也符合目前看起来的版权问题。</p>
<p>关于电子书的版权的情况现在我自己也很纠结。实体书，我买了。我可以随便借给任何人看。没有任何问题。但是电子书呢？公然的丢到网络上必然是不行的。但是我周围的人呢。可以借给他们看么。我也不知道答案。所以，现在我周围都是一本书说好看。然后大家就一起买。一个是电子书总体来说还是相对较便宜。一个是大家版权意思都在逐渐提高了。</p>
<p>最后扯回来这个bug。大可有一个帐号买了所有的书。然后进行分享。然后大家也只是偶然登录了一下这个有所有书的帐号。然后下载了全部的书。然后登录回来了自己的帐号。那这个时候，我看的书是正版？盗版？</p>
<h2 id="总结吐槽">总结吐槽</h2>
<p>哎。没忍住。一下吐槽这么多。</p>
<p>最后的吐槽： 进来多看上的书是越来越多了。但是质量下降的厉害。比如那本&lt;改变未来的九大算法&gt; 翻译如同丢到google翻译 然后就拿出来卖。很是失望，希望能有退款通道。对这种没有节操的书进行退款处理</p>
<p>还有就是为啥自己导入的PDF观看的时间没有进入阅历中啊！！！！！</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/just-talk/" term="just-talk"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS学习笔记(25) iCloud(一) 概览]]></title>
    <link href="http://iiiyu.com/2013/08/19/learning-ios-notes-twenty-five/"/>
    <id>http://iiiyu.com/2013/08/19/learning-ios-notes-twenty-five/</id>
    <published>2013-08-19T14:29:37.000Z</published>
    <updated>2014-04-01T03:48:59.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是iCloud">什么是iCloud</h2>
<p>iCloud是苹果公司提供的云服务的总称。每一个拥有Apple ID的用户都拥有5G大小的空间使用权。用户可以使用iCloud的空间来进行数据的备份，联系人备份，照片备份，应用备份等。好处就是当你有多台设备或者是换新的设备的时候。可以有无差别的体验。</p>
<p>对于开发者来说，iCloud相当于提供了一种官方形式的云端存储形式。帮助你的App实现所谓理想的状态。不论用户在什么设备打开App。 里面的数据，设置，形状，大小。都跟他上次打开的一模一样。这样你的App会给你的用户非一般的体验。</p>
<h2 id="开发慎用iCloud">开发慎用iCloud</h2>
<p>上一段说了iCloud的优点，其实是接近意淫中的理想状态。我以近一年的血泪史告诫，初级开发者，应该避免使用iCloud。中高级开发者视项目规划内容酌情使用。如果能有其他方案替代iCloud，建议优先使用其他方案。</p>
<p>初级开发者: iCloud的三种存储方式 Key-Value， Documents， Core Data都是在之前已有的框架上进行扩展的高级接口。换言之，你应该先具备了这三种技术的基本知识再开始考虑学习iCloud。 iCloud + Key-Value对应的基础是NSUserDefaults。 iCloud + Documents对应的基础是使用文档进行数据存储(NSFileManager,NSFileCoordinator,NSFileWrapper,NSCoding等一系列持久化数据存储到文件的问题). iCloud + Core Data的对应基础就是Core Data。本来是强烈建议如果没有这些基础的人不要直接来学习iCloud的。但是谁都是一步一步走过来的，如果要用到iCloud的某一种方式。建议先把基础的持久化方式原理弄懂了，在看iCloud的部分。不然学习门槛的过高，会使得进度无法按时推进。</p>
<p>中高级开发者：如果是已经用过Key-Value，Documents，Core Data的。应该会很快能明白iCloud的原理。 而进行开发。但是值得注意的是，iCloud的使用和调试会非常的消耗时间和精力。并且和你的当前网络状态息息相关。然后会出现各种诡异的情况。这个时候你都需要淡定很超级的耐心。去找到这些坑，然后慢慢的积累经验去绕过这些坑。（在这里先挖坑，后面在慢慢写我的一些使用经验）</p>
<a id="more"></a>

<h1 id="为什么要用iCloud">为什么要用iCloud</h1>
<p>既然iCloud这么多坑。为什么还要使用iCloud进行开发呢？这个问题最近半年的每周的某些时候我都会这样的问自己。 </p>
<p>个人觉得最重要的是:</p>
<p><strong>在需要数据统一的服务里面，几乎所有的第三方服务和自己搭建服务器为了识别唯一的用户。都需要进行一次注册流程。这是不可避免的。但是把注册用户的流程接入App里面。对我来说不能第一次打开就畅快的使用App是难以忍受的。iCloud由于是基于Apple ID的，相当于一个正常的用户来说是必备的。所以，使用iCloud技术可以避免注册用户流程。和App登入功能。即开即用的体验会大大提高。</strong></p>
<p>(注意，在这里我说的是几乎所有的第三方服务不包括Dropbox。Dropbox<a href="https://www.dropbox.com/developers/datastore" target="_blank">新的Datastore API</a>和本身Dropbox的普及率感觉会比注册要好一些。继续挖坑以后填)</p>
<p>其他的原因我觉得不是很重要但是还是列出来：</p>
<ol>
<li>iCloud是Apple的服务。好歹是市值4000亿刀的公司。理论上来说比小公司靠谱一些把。</li>
<li>iCloud是Apple自家的服务。App里面如果使用到了iCloud服务。理论上来说会被官方推荐的机率大了一些</li>
<li>如果以后做Apple全平台(iOS,Mac)自然对接起来应该方便一些。(感觉这个是YY)</li>
</ol>
<h2 id="除了iCloud还能用啥">除了iCloud还能用啥</h2>
<h3 id="Dropbox">Dropbox</h3>
<p>第一个顺位的自然是<a href="https://www.dropbox.com/developers" target="_blank">Dropbox</a>.</p>
<p>Dropbox不仅仅是一个无处不在的U盘。它还可以变成你App的数据存储端。而且新的Datastore API也显示着Dropbox会大力的发展成为App的数据端的决心。</p>
<h3 id="Parse">Parse</h3>
<p><a href="https://www.parse.com" target="_blank">Parse</a>的顺位也相当高。 原因在于，Parse的服务不仅仅有Data。还具备推送、社交分享等一系列高端大气上档次的功能。而且它的SDK覆盖了所有主流平台(iOS OSX Android JS WP8 W8 .NET)。更加重要的是，它在一定数据和请求量上是免费的。如果你的用户做到超过它的免费额度。我觉得这个时候你也就能轻松负担起它的付费版了。顺便说一句Parse应该是被Facebook收了。所以，应该对他们充满信心。</p>
<h3 id="avoscloud">avoscloud</h3>
<p>推荐<a href="https://cn.avoscloud.com" target="_blank">avoscloud</a>的理由很简单。这是好基友Summer参与开发的。 作为好基友肯定要鼎力推荐一下。 AVOS看起来是国际高端大气上档次的大厂。但是这个cloud，应该是完全由在天朝的团队开发的(个人猜想). 为什么要推荐？起码人家的文档是中文的，阅读起来没障碍。 有问题了，还可以直接去weibo吐槽也不当心人家看不懂好吧。</p>
<h3 id="helios">helios</h3>
<p>当然如果你喜欢自己搞定一切。那你还是可以自己搭建自己的服务器的。如果你需要一个类似的参考<a href="http://helios.io" target="_blank">Mattt大神的helios</a>你不应该错过。如果你写iOS or Mac OS X开发超过三月，还不知道Mattt大神。那你应该恶补一下圈子里面的知识了。Mattt大神就是主导AFNetworking的那个啊。 不说围绕着AFNetworking衍生出来的庞大类库。 当一个<a href="http://nshipster.com" target="_blank">NSHipster</a>就造福一方啊。</p>
<h2 id="总结_&amp;&amp;_瞎扯蛋">总结 &amp;&amp; 瞎扯蛋</h2>
<p>好久好久没有更新Blog。鄙视一下自己懒的不成样子了。其实好几次想写点扯淡的东西。但是总觉得技术Blog就应该有个技术Blog的样子。不要总是在扯淡。扯着扯着就变成IT评论家的感觉。今天黑这个，明天黑那个的。不好，应该自己踏踏实实的静心学习。最近就是因为心太乱了，导致各种问题。不过期待能把这个iCloud的系列坑给填好。也能算给自己学习了一年iCloud的使用做出一个总结不至于白弄了一年。</p>
<p>最后嫌弃我写的太慢的同学。那就给一个入口地址：从<a href="http://developer.apple.com/library/Mac/documentation/General/Conceptual/iCloudDesignGuide/Chapters/Introduction.html#//apple_ref/doc/uid/TP40012094-CH1-SW1" target="_blank">这里</a>加油把</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(24) 关于使用xCode的Tab来提高开发效率]]></title>
    <link href="http://iiiyu.com/2013/06/03/learning-ios-notes-twenty-fort/"/>
    <id>http://iiiyu.com/2013/06/03/learning-ios-notes-twenty-fort/</id>
    <published>2013-06-03T08:32:08.000Z</published>
    <updated>2014-02-17T04:20:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>通过Google分析来看blog的访问统计。发现评价阅读时间也就一分钟不到。但是之前都习惯性写长篇大论。这次换一种方式来写blog。尽量写短一些的小一些的题目。使得更新数量上去。</p>
<p>这次我来说说怎么设置Tab来提高在xCode的工作效率。</p>
<h1 id="我是如何使用Tab来提高效率的">我是如何使用Tab来提高效率的</h1>
<h2 id="xCode的Tab是什么">xCode的Tab是什么</h2>
<p>诺，就是这一个东西。 </p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e5b26nmyqij20oq00v0sp.jpg" alt=""></p>
<p>使用过各种浏览器的你一定不会陌生。对在xCode里面我们也可以开出多个页面。而且每一个页面的状态是单独保存的。</p>
<a id="more"></a>

<h2 id="如何提高效率">如何提高效率</h2>
<p>因为在实际的代码编写过程中，我们可能需要来回的查找和阅读代码。会很自然的在多个文件中跳转编辑。这时候单个编辑页面明显拖累了速度。所以我们需要多个页面来回切换就会很爽。</p>
<p>如上图所示。我习惯性长开着这几个Tab。</p>
<h2 id="UI">UI</h2>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e5b1quy5pij207409wt99.jpg" alt=""></p>
<p>如图所示，我们可以在圈起来的地方设置关键词过滤显示的文件<br>这样我的名为UI的Tab就只会显示storyboard。这样改UI点击起来会很方便</p>
<h2 id="Data">Data</h2>
<p>同理可得这个表情用来显示data model的。</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e5b1uqa7yhj207w094mxd.jpg" alt=""></p>
<h2 id="VC">VC</h2>
<p>显示ViewController的</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e5b1v4lkuyj207x0933z6.jpg" alt=""></p>
<h2 id="Debug">Debug</h2>
<p>Debug这个Tab有些特殊。并不是我手动创建的。而且我配置了编译行为出来的。<br>这样每次Run的时候都会跳到这个名为Debug的Tab里面。这样做的原因是，我改了一个地方的代码。运行以后可能在其他地方挂掉了（或者在其他地方打了断点）。然后跟着进去看了看。然后想回到之前改代码的地方就会很麻烦。</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e5b1ws3qu9j20ku0f8mzu.jpg" alt=""></p>
<p>这样设置了以后，就没有上述烦恼了。</p>
<h1 id="顺便说一句">顺便说一句</h1>
<p>希望这些对你有所帮助。</p>
<p>顺便说一句：Tab直接的切换可以使用快捷键 Command + Shift + ([, ]) 其实这个快捷键适用于绝大部分有Tab的App。 都可以完成切换功能</p>
<p>再顺便说一句： xCode本身内存消耗很大，开Tab。感觉很是消耗内存。如果内存吃紧的话。应该去升级内存了。不然开多个Tab只会降低工作效率并不会提高。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(23) iOS进行单元测试OCUnit+xctool]]></title>
    <link href="http://iiiyu.com/2013/05/23/learning-ios-notes-twenty-three/"/>
    <id>http://iiiyu.com/2013/05/23/learning-ios-notes-twenty-three/</id>
    <published>2013-05-23T06:51:31.000Z</published>
    <updated>2014-02-17T04:20:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="iOS进行单元测试OCUnit+xctool">iOS进行单元测试OCUnit+xctool</h1>
<h2 id="单元测试">单元测试</h2>
<h3 id="什么是单元测试">什么是单元测试</h3>
<p><a href="http://zh.wikipedia.org/wiki/单元测试" target="_blank">wiki解释</a></p>
<p>简单说来就是为你的方法多专门写一个测试函数。以保证你的方法在不停的修改开发中。保持正确。如果出错，第一时间让你知道，这样从最小单位开始监控来保证软件的质量。</p>
<h3 id="我为什么要单元测试">我为什么要单元测试</h3>
<p>其实要开始写单元测试的原因是，由于我的原因格志的存储逻辑一直有问题。 一个是代码写的比较搓，一个是修改存储的逻辑的话。影响面比较大。可能修复了一个bug而引入了未知的多个bug。为了Sumi早日达到国际化大厂的标准。决定上单元测试于格志。其实最根本的目的还是想要项目变的更加可靠。</p>
<h3 id="单元测试的一般方法">单元测试的一般方法</h3>
<p>关于测试的书，一搜就一大把。都有高深的理论和方法来指导怎么写单元测试的方法。我觉得嘛不用搞了这么复杂。 无非就3种时候会去想写测试：</p>
<ol>
<li>代码完成以后</li>
<li>开始写代码之前</li>
<li>修复了一个bug以后</li>
</ol>
<p>第一种是完成了代码，恩我要测试一下我写的这些方法可靠不可靠。那这时候可以写测试。</p>
<p>第二种一个著名的方法论TDD。主要思想就是在写代码之前，就全部设计好借口。函数名字什么的。然后在写能通过测试的函数。</p>
<p>第三种就是发现了bug，我修复了这个bug。为了确保修复是成功的。那就写个测试吧。</p>
<p>我觉得啊，着三种都没有什么好或差。能写测试的少年都是好少年。何必这么在意什么时候去写呢。</p>
<p>一个完整的测试类组成像下图</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e58jl2toiej20fh0a1aam.jpg" alt=""></p>
<p>在一开始可能测试方法里面需要一些上下文环境。这些可以在Setup里面去完成。然后才可是执行自己写的测试方法。 然后测试结束以后，可能产生了一些垃圾数据文件什么的。这时候你可以在TearDown方法里面把他们处理掉。</p>
<p>以上大部分都是我自己的粗浅理解，如果你需要更多关于单元测试请阅读更加系统专业的书籍。</p>
<a id="more"></a>


<h2 id="OCUnit">OCUnit</h2>
<p>OCUnit是xCode里面自己带的单元测试框架。不必安装第三方的其他库就可以使用。最简单的就是创建项目的时候你把单元测试的那个勾点上。xCode就会自动的为你加入一个单元测试的target。快捷键Command + U。就可以运行测试。最喜欢这样方便又好用的东西了。当然运行OCUnit的测试输出的内容实在惨不忍睹。</p>
<h3 id="创建一个OCUnit的Unit_Test">创建一个OCUnit的Unit Test</h3>
<h4 id="新项目使用OCUnit">新项目使用OCUnit</h4>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58kyt9nyhj20k80dnabp.jpg" alt=""></p>
<p>选上Unit Test</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58kzfmxkij20ei0c93zt.jpg" alt=""></p>
<p>会自动的建立一个Target</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58l0l72wvj20uf0b4q51.jpg" alt=""></p>
<p>自动的为你添加好需要的类库</p>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e58l164wjkj20al0d7dh0.jpg" alt=""></p>
<p>为你添加一个Unit Test的类</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e58l1uogchj20an03cq39.jpg" alt=""></p>
<p>看一眼Scheme 只有一个。</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58l315fwmj20jg0d70ua.jpg" alt=""></p>
<p>看看Scheme里面是怎么写的。</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58l4n4ozrj209c04vdg1.jpg" alt=""></p>
<p>用Command + U运行一下测试看看结果。这是没有通过的。因为自动生成的模板就是不通过的。具体一会儿分析代码。</p>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e58l6bue5gj20zc070mze.jpg" alt=""></p>
<p>看看终端的输出。渣一般的难看。根本无法高识别度的分清。</p>
<h4 id="已经存在的项目使用OCUnit">已经存在的项目使用OCUnit</h4>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58t46ki0fj20770cgdgd.jpg" alt=""></p>
<p>这是一个一开始没有选择过Unit Test的项目</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58t52kpxhj20ce0jg0tn.jpg" alt=""></p>
<p>点击增加Target</p>
<p><img src="http://ww2.sinaimg.cn/large/686e6613jw1e58t5vnb0bj20k80dndhf.jpg" alt=""></p>
<p>选择Unit testing Bundle</p>
<p><img src="http://ww1.sinaimg.cn/large/686e6613jw1e58t6jsonij20k80dnmys.jpg" alt=""></p>
<p>为我们的测试bundle取一个名字</p>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e58t75sbt3j20bq03h3yu.jpg" alt=""></p>
<p>我们可以看到Scehme多出来了一个。这时候如果选择的是App的Scehme。Command + U。是没有运行测试的。要选择我们新建立的Test Scehme。再按Command + U.就运行了测试了。</p>
<p><img src="http://ww3.sinaimg.cn/large/686e6613jw1e58t96mpj1j20jg0d775q.jpg" alt=""></p>
<p>如何为App的Scehme添加Test。使得不用切换Scehme，就可以运行Unit Test。</p>
<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58thyodnkj20b40cswet.jpg" alt=""></p>
<p>然后选择你建立的Unit Test bundle。 打完收工。</p>
<h3 id="OCUnit使用的宏">OCUnit使用的宏</h3>
<p>STAssertEqualObjects(a1, a2, description, …)</p>
<p>STAssertEquals(a1, a2, description, …)</p>
<p>STAssertEqualsWithAccuracy(a1, a2, accuracy,description, …)</p>
<p>STFail(description, …)</p>
<p>STAssertNil(a1, description, …)</p>
<p>STAssertNotNil(a1, description, …)</p>
<p>STAssertTrue(expr, description, …)</p>
<p>STAssertTrueNoThrow(expr, description, …)</p>
<p>STAssertFalse(expr, description, …)</p>
<p>STAssertFalseNoThrow(expr, description, …)</p>
<p>STAssertThrows(expr, description, …)</p>
<p>STAssertThrowsSpecific(expr, specificException, description, …)</p>
<p>STAssertThrowsSpecificNamed(expr, specificException, aName, description, …)</p>
<p>STAssertNoThrow(expr, description, …)</p>
<p>STAssertNoThrowSpecific(expr, specificException, description, …)</p>
<p>STAssertNoThrowSpecificNamed(expr, specificException, aName, description, …)</p>
<h3 id="比较经常使用的宏">比较经常使用的宏</h3>
<p>STAssertTrue(expr, description, …)<br>STAssertFalse(expr, description, …)<br>STAssertNil(a1, description, …)<br>STAssertNotNil(a1, description, …)<br>STAssertEqualObjects(a1, a2, description, …)<br>STAssertEquals(a1, a2, description, …)<br>STFail(description, …)<br>STAssertThrows(expr, description, …)</p>
<h3 id="写了几个测试方法的例子">写了几个测试方法的例子</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)testOne {
	<span class="built_in">NSString</span> *string1 = @<span class="string">"test"</span>;
	<span class="built_in">NSString</span> *string2 = @<span class="string">"test"</span>;
	STAssertThrows([string1 isEqualToString:string2], @<span class="string">"FAILURE"</span>);
}

- (<span class="keyword">void</span>)testTwo
{
    <span class="keyword">int</span> i = <span class="number">0</span>;
    <span class="keyword">int</span> j = <span class="number">1</span>;
    STAssertTrue(i &lt; j, @<span class="string">" i: %d, j: %d"</span>, i,j);
}

- (<span class="keyword">void</span>)testThree
{
    
    <span class="built_in">NSString</span> *oneStr = @<span class="string">"hello"</span>;
    <span class="built_in">NSString</span> *twoStr = @<span class="string">"world"</span>;
    STAssertFalse([oneStr isEqualToString:twoStr], @<span class="string">"oneStr:%@, twoStr:%@"</span>, oneStr, twoStr);
}

- (<span class="keyword">void</span>)testFour
{
    <span class="built_in">NSArray</span> *array = <span class="literal">nil</span>;
    STAssertNil(array, @<span class="string">"array:%@"</span>, array);
}


- (<span class="keyword">void</span>)testFive
{
    <span class="built_in">NSDictionary</span> *dict = @{@<span class="string">"hello"</span>: @<span class="string">"word"</span>};
    STAssertNotNil(dict, @<span class="string">"dict:%@"</span>, dict);
}

- (<span class="keyword">void</span>)testSix
{
    <span class="built_in">NSNumber</span> *oneNum = @<span class="number">100</span>;
    <span class="built_in">NSNumber</span> *twoNum = @<span class="number">200</span>;
    STAssertEqualObjects(oneNum, twoNum, @<span class="string">"oneNum:%@ twoNum:%@"</span>,oneNum, twoNum);
}

- (<span class="keyword">void</span>)testSeven
{
    <span class="built_in">NSArray</span> *oneArray = @[@<span class="number">11</span>, @<span class="number">22</span>, @<span class="number">33</span>];
    <span class="built_in">NSArray</span> *twoArray = [oneArray copy];
    STAssertEqualObjects(oneArray, twoArray, @<span class="string">"oneArray:%@, twoArray:%@"</span>, oneArray, twoArray);
}


- (<span class="keyword">void</span>)testEight
{
    NSUInteger uint_1 = <span class="number">4</span>;
	NSUInteger uint_2 = <span class="number">4</span>;
	STAssertEquals(uint_1, uint_2, @<span class="string">"FAILURE"</span>);
}
    
    
- (<span class="keyword">void</span>)testExample
{
    STFail(@<span class="string">"Unit tests are not implemented yet in HelloAfterAddOCUnitUnitTest"</span>);
}
</pre></td></tr></table></figure>

<p>一会儿用xctool跑个华丽丽的出来看。</p>
<h2 id="xctool">xctool</h2>
<h3 id="xctool是什么">xctool是什么</h3>
<p>xctool是Facebook开源的一个命令行工具，用来替代苹果的xcodebuild工具。</p>
<p><a href="https://github.com/facebook/xctool" target="_blank">github</a></p>
<p>官方演示</p>
<p><img src="https://fpotter_public.s3.amazonaws.com/xctool-uicatalog.gif" alt=""></p>
<p>你可以用它来Build你的App。跑Tests。而且它跑Test输出是华丽丽的彩色。比xCode自带的不知好看多少倍。OCUnit本来被吐槽无数，遇上了xctool以后就逆袭了啊。</p>
<p>世界上最最牛的SNS出品，肯定不会坑爹啊。</p>
<h3 id="安装xctool">安装xctool</h3>
<p>最方便 最推荐的是用Homebrew。如果你的Mac里面没有安装Homebrew我觉得是你的损失。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>brew <span class="operator"><span class="keyword">update</span>
brew install xctool</span>
</pre></td></tr></table></figure>

<h3 id="使用xctool来跑OCUnit测试">使用xctool来跑OCUnit测试</h3>
<p>关于如何使用xctool，你去看官方文档肯定要比我结束好的多。 我就是过来跑测试的例子给你看而已。</p>
<h4 id="测试一">测试一</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>xctool <span class="attribute">-project</span> HelloOCUnit<span class="built_in">.</span>xcodeproj <span class="attribute">-scheme</span> HelloOCUnit  test
</pre></td></tr></table></figure>

<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58zjmagi8j20eh0li0wx.jpg" alt=""></p>
<h4 id="测试二">测试二</h4>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>xctool <span class="attribute">-project</span> HelloAfterAddOCUnit<span class="built_in">.</span>xcodeproj <span class="attribute">-scheme</span> HelloAfterAddOCUnit  test

xctool <span class="attribute">-project</span> HelloAfterAddOCUnit<span class="built_in">.</span>xcodeproj <span class="attribute">-scheme</span> HelloAfterAddOCUnitUnitTest  test
</pre></td></tr></table></figure>

<p><img src="http://ww4.sinaimg.cn/large/686e6613jw1e58zk5dk34j20h70li43i.jpg" alt=""></p>
<p><a href="http://d.pr/f/EUCR" target="_blank">项目一下载</a></p>
<p><a href="http://d.pr/f/LPaY" target="_blank">项目二下载</a></p>
<h2 id="总结">总结</h2>
<p>以上就是OCUnit的使用建议。建议OCunit+xctool。来进行你的单元测试构建。更多信息请阅读相关资料。我这里只是写了入门而已。接下来的测试之路就靠你了。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(22) CoreData (四) 监听NSFetchedResultsController]]></title>
    <link href="http://iiiyu.com/2013/04/29/learning-ios-notes-twenty-two/"/>
    <id>http://iiiyu.com/2013/04/29/learning-ios-notes-twenty-two/</id>
    <published>2013-04-29T04:03:11.000Z</published>
    <updated>2014-02-17T04:20:13.000Z</updated>
    <content type="html"><![CDATA[<h1 id="CoreData_(四)">CoreData (四)</h1>
<h2 id="监听NSFetchedResultsController">监听NSFetchedResultsController</h2>
<p>之前说过, NSFetchedResultsController是有两个重要的功能。</p>
<p>第一:NSFetchedResultsController是作用在Core Data上的,通过NSFetchRequest来查询Core Data里面的数据.可以返回按照组分好的数据.这样便于UITableView来显示.</p>
<p>第二:但Model改变的时候NSFetchedResultsController能及时的发出通知.准确的说,应该是当NSManagedObjectContext发生改变的时候,NSFetchedResultsController能知道这些变化,然后发出通知出来.以便UITableview能及时的更新.</p>
<p>上一篇写了第一点. 现在写第二点.</p>
<a id="more"></a>

<h2 id="背景">背景</h2>
<p>如果在数据改变了的时候,我们用UITableView reload. 整个UITableView的数据确实能保持最新的情况. 但是问题是这样做的效率很低. 更希望的情况是,我哪一条数据增加,修改,删除. 就对应着UITableView里面的那一条数据在UI上增加,修改,删除.这样效率会有很大的提升. </p>
<h2 id="直接操作">直接操作</h2>
<p>首先是用Delegate来进行UITableView的改变.</p>
<p>第一个方法,告诉UITableView数据要开始更新了,你UITableView赶紧准备好更新.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)controllerWillChangeContent:(<span class="built_in">NSFetchedResultsController</span> *)controller
{
    [[<span class="keyword">self</span> tableView] beginUpdates];
}
</pre></td></tr></table></figure>

<p>当然有开始就有结束,下面的方法就是告诉UITableView结束更新.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)controllerDidChangeContent:(<span class="built_in">NSFetchedResultsController</span> *)controller
{
    [[<span class="keyword">self</span> tableView] endUpdates];
}
</pre></td></tr></table></figure>

<p>这两个方法一看命名规则就能看出来是一个Delegate.在NSFetchedResultsController将要变换的时候,我们开启UITableView的编辑,然后在NSFetchedResultsController已经改变结束的时候结束UITableView的编辑.思维上自然而然,有始有终.</p>
<p>接下来我们要在begin和end之间对tableview做出改变.</p>
<p>改变section的方法.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)controller:(<span class="built_in">NSFetchedResultsController</span> *)controller
  didChangeSection:(<span class="keyword">id</span> &lt;NSFetchedResultsSectionInfo&gt;)sectionInfo
           atIndex:(NSUInteger)sectionIndex
     forChangeType:(<span class="built_in">NSFetchedResultsChangeType</span>)type
{
    NSIndexSet *indexSet = [NSIndexSet indexSetWithIndex:sectionIndex];
    <span class="keyword">switch</span>(type) {
        <span class="keyword">case</span> NSFetchedResultsChangeInsert:
        {
            [[<span class="keyword">self</span> tableView] insertSections:indexSet
                            withRowAnimation:UITableViewRowAnimationFade];
            <span class="keyword">break</span>;
        }
        <span class="keyword">case</span> NSFetchedResultsChangeDelete:
        {
            [[<span class="keyword">self</span> tableView] deleteSections:indexSet
                            withRowAnimation:UITableViewRowAnimationFade];
            <span class="keyword">break</span>;
            
        }
    }
}
</pre></td></tr></table></figure>

<p>这个方法是在section改变的时候调用.改变类型支持两种NSFetchedResultsChangeInsert和NSFetchedResultsChangeDelete..这样我们能操作UITableView里面section变化了.</p>
<p>接下来的方法是改变cell内容的.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)controller:(<span class="built_in">NSFetchedResultsController</span> *)controller didChangeObject:(<span class="keyword">id</span>)anObject
       atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
     forChangeType:(<span class="built_in">NSFetchedResultsChangeType</span>)type
      newIndexPath:(<span class="built_in">NSIndexPath</span> *)newIndexPath
{
    <span class="built_in">NSArray</span> *newArray = [<span class="built_in">NSArray</span> arrayWithObject:newIndexPath]; <span class="built_in">NSArray</span> *oldArray = [<span class="built_in">NSArray</span> arrayWithObject:indexPath]; <span class="keyword">switch</span>(type) {
        <span class="keyword">case</span> NSFetchedResultsChangeInsert:
            [[<span class="keyword">self</span> tableView] insertRowsAtIndexPaths:newArray
                                    withRowAnimation:UITableViewRowAnimationFade];
            <span class="keyword">break</span>;
        <span class="keyword">case</span> NSFetchedResultsChangeDelete:
            [[<span class="keyword">self</span> tableView] deleteRowsAtIndexPaths:oldArray
                                    withRowAnimation:UITableViewRowAnimationFade];
            <span class="keyword">break</span>;
        <span class="keyword">case</span> NSFetchedResultsChangeUpdate: {
            <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>;
            NSManagedObject *object = <span class="literal">nil</span>;
            cell = [[<span class="keyword">self</span> tableView] cellForRowAtIndexPath:indexPath];
            object = [[<span class="keyword">self</span> fetchedResultsController] objectAtIndexPath:indexPath]; [[cell textLabel] setText:[object valueForKey:@<span class="string">"name"</span>]];
            <span class="keyword">break</span>;
        }
        <span class="keyword">case</span> NSFetchedResultsChangeMove:
            
            [[<span class="keyword">self</span> tableView] deleteRowsAtIndexPaths:oldArray
                                    withRowAnimation:UITableViewRowAnimationFade];
            [[<span class="keyword">self</span> tableView] insertRowsAtIndexPaths:newArray
                                    withRowAnimation:UITableViewRowAnimationFade];
        <span class="keyword">break</span>; }
}
</pre></td></tr></table></figure>

<p>在这个方法里面我们可以增删改Cell的.并且可以有动画.</p>
<h2 id="NSFetchedResultsController的原理">NSFetchedResultsController的原理</h2>
<p>上面我们已经可以无痛的使用NSFetchedResultsController了。而且各种数据都可以自动更新，但是它是一个什么原理呢？</p>
<p>NSFetchedResultsController的核心其实是作为一个观察者去监听NSManagedObjectContext的通知。当NSManagedObjectContext发生改变的时候NSFetchedResultsController就知道了变化。所以，我们初始化一个NSFetchedResultsController的时候，也就监听了对应的NSManagedObjectContext的通知。具体的是三个通知。</p>
<p><em>NSManagedObjectContextObjectsDidChangeNotification</em></p>
<p><em>NSManagedObjectContextWillSaveNotification</em></p>
<p><em>NSManagedObjectContextDidSaveNotification</em></p>
<p>其实看名字都可以猜测一些他们的具体发出通知的时机。</p>
<h4 id="NSManagedObjectContextObjectsDidChangeNotification">NSManagedObjectContextObjectsDidChangeNotification</h4>
<p>当任何一个Object中的任何属性有改变的时候，会发出此通知。然后NSFetchedResultsController会去用设置好的NSFetchRequest查处结果进行参数传递。当这些改变发送的时候，我们就只用在 -controller: didChangeObject: atIndexPath: forChangeType: newIndexPath:判断改变类型是 NSFetchedResultsChangeUpdate或者 NSFetchedResultsChangeMove就可以做相应的数据到UI的变更操作了。</p>
<h4 id="NSManagedObjectContextWillSaveNotification">NSManagedObjectContextWillSaveNotification</h4>
<p>这个通知是在删除Object的情况下。 这时候可能删除的是section。用-controller: didChangeSection: atIndex: forChangeType:。 如果只是一个Object的删除。就用-controller: didChangeObject: atIndexPath: forChangeType: newIndexPath:。 类型都是NSFetchedResultsChangeDelete.</p>
<h4 id="NSManagedObjectContextDidSaveNotification">NSManagedObjectContextDidSaveNotification</h4>
<p>这个通知对应的delegate方法就是-controller: didChangeSection: atIndex: forChangeType: 和 -controller: didChangeObject: atIndexPath: forChangeType: newIndexPath:。 </p>
<p>了解了NSFetchedResultsController的原理。事实上自己就可以写NSFetchedResultsController了。</p>
<p>事实上，这篇blog写的确实很糟糕。 而且看日期已经写了20多天了。这样的拖沓让我很不开心。 所以我决定快速的结束这篇blog。 以后就算写的糟糕也不应该拖沓的。</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[iOS笔记(21) CoreData (三) NSFetchedResultsController]]></title>
    <link href="http://iiiyu.com/2013/04/17/learning-ios-notes-twenty-one/"/>
    <id>http://iiiyu.com/2013/04/17/learning-ios-notes-twenty-one/</id>
    <published>2013-04-17T07:06:24.000Z</published>
    <updated>2014-02-17T04:20:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="CoreData_(三)">CoreData (三)</h1>
<h2 id="NSFetchedResultsController">NSFetchedResultsController</h2>
<h3 id="什么是NSFetchedResultsController">什么是NSFetchedResultsController</h3>
<p>NSFetchedResultsController是一个让人爱恨交加的一个类。如果使用得当，NSFetchedResultsController能帮组减少很多代码。如果使用不当，整个App就随时崩溃。</p>
<p>NSFetchedResultsController我觉得最初的设计应该是为了配合UITableView来使用的。因为UITableView在iOS的应用App中出场次数实在是太高了.而且UITableView是重要的数据展示View,所以需要频繁的向Model去请求数据,但是根据MVC来说,V不应该直接跟M联系的.这样就在Core Data下面出现了一个C—NSFetchedResultsController来把V和M协调起来. NSFetchedResultsController就是这个C. </p>
<p>NSFetchedResultsController是有两个重要的功能。</p>
<p>第一:NSFetchedResultsController是作用在Core Data上的,通过NSFetchRequest来查询Core Data里面的数据.可以返回按照组分好的数据.这样便于UITableView来显示.</p>
<p>第二:但Modle改变的时候NSFetchedResultsController能及时的发出通知.准确的说,应该是当NSManagedObjectContext发生改变的时候,NSFetchedResultsController能知道这些变化,然后发出通知出来.以便UITableview能及时的更新.</p>
<a id="more"></a>


<h2 id="实现一个NSFetchedResultsController作为Data_source的UITableView">实现一个NSFetchedResultsController作为Data source的UITableView</h2>
<h3 id="创建一个最小带Core_Data的工程">创建一个最小带Core Data的工程</h3>
<p><img src="http://ww3.sinaimg.cn/large/a74ecc4cjw1e3tlc32lbhj20k80dndhr.jpg" alt=""></p>
<p>选择Master-Detail Application</p>
<p><img src="http://ww4.sinaimg.cn/large/a74eed94jw1e3tle5fxqnj20k80dn0uf.jpg" alt=""></p>
<p>整理一下显示层级和结构使其看起来顺眼一些</p>
<p><img src="http://ww2.sinaimg.cn/large/a74e55b4jw1e3tlnesq81j20750dut9e.jpg" alt=""></p>
<h3 id="确立目标">确立目标</h3>
<p>打开看以后 发现建立的工程是已经使用了NSFetchedResultsController<br>我们的目标是改写这个项目支持UITableView分组显示</p>
<h4 id="首先修改Data_Model">首先修改Data Model</h4>
<p>增加一个字段用来分组. 我们增加一个同样的Date用来记录此时的分钟数量.</p>
<p><img src="http://ww4.sinaimg.cn/large/bfadf3bejw1e3tn8pouqgj.jpg" alt=""></p>
<h3 id="初始化一个NSFetchedResultsController">初始化一个NSFetchedResultsController</h3>
<p>这里假设你看过我的Core Data笔记1,2.默认你已经做好了Core Data stack的全部工作.然后再开始NSFetchedResultsController的初始化.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre>- (<span class="built_in">NSFetchedResultsController</span> *)fetchedResultsController
{
    <span class="keyword">if</span> (_fetchedResultsController != <span class="literal">nil</span>) {
        <span class="keyword">return</span> _fetchedResultsController;
    }

    NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
    <span class="comment">// Edit the entity name as appropriate.</span>
    NSEntityDescription *entity = [NSEntityDescription entityForName:@<span class="string">"Event"</span> inManagedObjectContext:<span class="keyword">self</span><span class="variable">.managedObjectContext</span>];
    [fetchRequest setEntity:entity];

    <span class="comment">// Set the batch size to a suitable number.</span>
    [fetchRequest setFetchBatchSize:<span class="number">20</span>];

    <span class="comment">// Edit the sort key as appropriate.</span>
    NSSortDescriptor    *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@<span class="string">"timeStamp"</span> ascending:<span class="literal">NO</span>];
    <span class="built_in">NSArray</span>             *sortDescriptors = @[sortDescriptor];

    [fetchRequest setSortDescriptors:sortDescriptors];

    <span class="comment">// Edit the section name key path and cache name if appropriate.</span>
    <span class="comment">// nil for section name key path means "no sections".</span>
    <span class="built_in">NSFetchedResultsController</span> *aFetchedResultsController = [[<span class="built_in">NSFetchedResultsController</span> alloc] initWithFetchRequest:fetchRequest managedObjectContext:<span class="keyword">self</span><span class="variable">.managedObjectContext</span> sectionNameKeyPath:@<span class="string">"sectionMinute"</span> cacheName:@<span class="string">"Master"</span>];
    aFetchedResultsController<span class="variable">.delegate</span> = <span class="keyword">self</span>;
    <span class="keyword">self</span><span class="variable">.fetchedResultsController</span> = aFetchedResultsController;

    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;

    <span class="keyword">if</span> (![<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> performFetch:&error]) {
        <span class="comment">// Replace this implementation with code to handle the error appropriately.</span>
        <span class="comment">// abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.</span>
        <span class="built_in">NSLog</span>(@<span class="string">"Unresolved error %@, %@"</span>, error, [error userInfo]);
        abort();
    }

    <span class="keyword">return</span> _fetchedResultsController;
}
</pre></td></tr></table></figure>

<p>这里是工程里面的NSFetchedResultsController的set方法.可以看出,第一我们创建一个NSFetchRequest查询.然后在用这个NSFetchRequest去创建一个NSFetchedResultsController.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="built_in">NSFetchedResultsController</span> *aFetchedResultsController = [[<span class="built_in">NSFetchedResultsController</span> alloc] initWithFetchRequest:fetchRequest managedObjectContext:<span class="keyword">self</span><span class="variable">.managedObjectContext</span> sectionNameKeyPath:@<span class="string">"sectionMinute"</span> cacheName:@<span class="string">"Master"</span>];
</pre></td></tr></table></figure>

<p>第一个参数就是NSFetchRequest.</p>
<p>第二个参数是要指定在哪个context里面进行查询</p>
<p>第三个参数是根据什么key来分组.sectionNameKeyPath本来是nil是不分组,我改为我们需要分组的key值”sectionMinute”.</p>
<p>第四个参数  <a href="http://developer.apple.com/library/ios/#documentation/CoreData/Reference/NSFetchedResultsController_Class/Reference/Reference.html" target="_blank">官方解释是这里</a>点到The Cache的地方. 我的理解是cache只保留很少的一部分数据在磁盘上面,如果使用了Cache,在重建UITableView的时候, 就优先查询cache里面的数据.然后要在-performFetch:执行的时候才会去刷新新的数据.这样有助于UITableView的流畅性.</p>
<p>然后我加入Sections的方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>- (<span class="built_in">NSString</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView titleForHeaderInSection:(<span class="built_in">NSInteger</span>)section
{
    <span class="built_in">NSArray</span> *sections = [[<span class="keyword">self</span> fetchedResultsController] sections]; <span class="keyword">id</span> &lt;NSFetchedResultsSectionInfo&gt; sectionInfo = <span class="literal">nil</span>;
    sectionInfo = [sections objectAtIndex:section];
    
    <span class="keyword">return</span> [sectionInfo name];
}
</pre></td></tr></table></figure>

<p>接着我添加</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="label">https:</span>//github<span class="preprocessor">.com</span>/erica/NSDate-Extensions<span class="preprocessor">.git</span>
</pre></td></tr></table></figure>

<p>这个NSDate库进来.自己按照他的写法,写一个能获得当前时间秒数为0的方法.用来分组.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>- (<span class="built_in">NSDate</span> *) dateAtStartOfMinutes
{
    NSDateComponents *components = [CURRENT_CALENDAR components:DATE_COMPONENTS fromDate:<span class="keyword">self</span>];
	[components setSecond:<span class="number">0</span>];
	<span class="keyword">return</span> [CURRENT_CALENDAR dateFromComponents:components];
}
</pre></td></tr></table></figure>

<p>然后改写insert方法</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre>- (<span class="keyword">void</span>)insertNewObject:(<span class="keyword">id</span>)sender
{
    NSManagedObjectContext *context = [<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> managedObjectContext];
    NSEntityDescription *entity = [[<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> fetchRequest] entity];
    NSManagedObject *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context];
    
    <span class="comment">// If appropriate, configure the new managed object.</span>
    <span class="comment">// Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.</span>
    [newManagedObject setValue:[<span class="built_in">NSDate</span> date] forKey:@<span class="string">"timeStamp"</span>];
    [newManagedObject setValue:[[<span class="built_in">NSDate</span> date] dateAtStartOfMinutes]  forKey:@<span class="string">"sectionMinute"</span>];
    
    <span class="comment">// Save the context.</span>
    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
    <span class="keyword">if</span> (![context save:&error]) {
         <span class="comment">// Replace this implementation with code to handle the error appropriately.</span>
         <span class="comment">// abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. </span>
        <span class="built_in">NSLog</span>(@<span class="string">"Unresolved error %@, %@"</span>, error, [error userInfo]);
        abort();
    }
}
</pre></td></tr></table></figure>

<p>其实就是加入了</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>[newManagedObject <span class="keyword">set</span>Value:[[NSDate date] dateAtStartOfMinutes]  <span class="keyword">for</span>Key:@<span class="string">"sectionMinute"</span>];
</pre></td></tr></table></figure>

<p>这句.</p>
<p>这样,简单的使用NSFetchedResultsController来显示分组的UITableView就搞定了.<br>当然因为建立的工程模板原因.很大一部分都是xCode搞定的.</p>
<h3 id="被遗忘的地方">被遗忘的地方</h3>
<p>Sections数量,决定了有多少组</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView
{
    <span class="keyword">return</span> [[<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> sections] count];
}
</pre></td></tr></table></figure>

<p>如果在初始化NSFetchedResultsController的时候sectionNameKeyPath为nil.这里应该会返回1.(就算没有数据也会返回1)</p>
<p>Row数量,决定每一组分别有多少行数据.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section
{
    <span class="keyword">id</span> &lt;NSFetchedResultsSectionInfo&gt; sectionInfo = [<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> sections][section];
    <span class="keyword">return</span> [sectionInfo numberOfObjects];
}
</pre></td></tr></table></figure>

<p>我前面说过NSFetchedResultsController就是为了配合UITableView而设计的.所以自然有根据indexPath来取对应的NSManagedObject的方法.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
{
    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:@<span class="string">"Cell"</span> forIndexPath:indexPath];
    [<span class="keyword">self</span> configureCell:cell atIndexPath:indexPath];
    <span class="keyword">return</span> cell;
}

- (<span class="keyword">void</span>)configureCell:(<span class="built_in">UITableViewCell</span> *)cell atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath
{
    NSManagedObject *object = [<span class="keyword">self</span><span class="variable">.fetchedResultsController</span> objectAtIndexPath:indexPath];
    cell<span class="variable">.textLabel</span><span class="variable">.text</span> = [[object valueForKey:@<span class="string">"timeStamp"</span>] description];
}
</pre></td></tr></table></figure>

<h3 id="show">show</h3>
<p><img src="http://ww3.sinaimg.cn/large/a74ecc4cjw1e3tydp5hsqj208w0geabq.jpg" alt=""></p>
<h2 id="总结">总结</h2>
<p>写Blog实在是太累了. NSFetchedResultsController努力一天也才一点点.回去继续写. 下次要写NSFetchedResultsController通知方法.</p>
]]></content>
    <category scheme="http://iiiyu.com/tags/iOS/" term="iOS"/>
  </entry>
</feed>
